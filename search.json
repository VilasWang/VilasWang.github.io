[{"title":"Ubuntu CPP 开发环境配置指南","url":"/posts/e0946359/","content":"Ubuntu CPP 开发环境配置指南目录\n概述\n第一步：系统更新和基础工具安装\n第二步：安装编译器工具链\n第三步：安装构建工具\n第四步：安装调试工具\n第五步：安装常用开发库\n第六步：配置 IDE 和编辑器\n第七步：验证开发环境\n第八步：配置环境变量\n附录：常用命令速查\n常见问题\n\n概述本文档提供了在 Ubuntu 22.04 LTS 系统上搭建完整 C++ 开发环境的详细步骤。无论您是 C++ 初学者还是有经验的开发者，都可以按照本指南快速配置一个功能完整的开发环境。\n主要组件\n编译器: GCC&#x2F;G++ (支持 C++11&#x2F;14&#x2F;17&#x2F;20)\n构建系统: CMake, Make\n调试器: GDB\n包管理: apt, vcpkg\nIDE: Visual Studio Code (可选)\n版本控制: Git\n\n第一步：系统更新和基础工具安装1. 更新系统包# Ubuntu CPP 开发环境配置指南sudo apt update# Ubuntu CPP 开发环境配置指南sudo apt upgrade -y# Ubuntu CPP 开发环境配置指南sudo apt dist-upgrade -y\n\n2. 安装基础开发工具# Ubuntu CPP 开发环境配置指南sudo apt install -y build-essential# Ubuntu CPP 开发环境配置指南sudo apt install -y git wget curl unzip tar software-properties-common# Ubuntu CPP 开发环境配置指南sudo apt install -y manpages-dev man-db\n\n3. 验证基础安装# Ubuntu CPP 开发环境配置指南gcc --version# Ubuntu CPP 开发环境配置指南g++ --version# Ubuntu CPP 开发环境配置指南make --version\n\n第二步：安装编译器工具链1. 安装最新版本的 GCC&#x2F;G++Ubuntu 22.04 默认提供 GCC 11，如需更新版本：\n# Ubuntu CPP 开发环境配置指南sudo add-apt-repository -y ppa:ubuntu-toolchain-r/testsudo apt update# Ubuntu CPP 开发环境配置指南sudo apt install -y gcc-11 g++-11sudo apt install -y gcc-12 g++-12  # 如可用# Ubuntu CPP 开发环境配置指南sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 11sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 11\n\n2. 配置编译器支持 C++ 标准默认情况下，GCC 支持 C++17。确保支持最新标准：\n# Ubuntu CPP 开发环境配置指南echo &#x27;#include &lt;iostream&gt;#include &lt;ranges&gt;#include &lt;vector&gt;int main() &#123;    std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;;    auto even = v | std::views::filter([](int n) &#123; return n % 2 == 0; &#125;);    for (int n : even) std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;    return 0;&#125;&#x27; &gt; test_cpp20.cppg++ -std=c++20 -o test_cpp20 test_cpp20.cpp./test_cpp20rm test_cpp20.cpp test_cpp20\n\n第三步：安装构建工具1. 安装 CMake# Ubuntu CPP 开发环境配置指南sudo apt install -y cmake# Ubuntu CPP 开发环境配置指南cmake --version\n\n2. 安装 Ninja (可选，更快的构建工具)# Ubuntu CPP 开发环境配置指南sudo apt install -y ninja-build# Ubuntu CPP 开发环境配置指南ninja --version\n\n3. 安装其他构建工具# Ubuntu CPP 开发环境配置指南sudo apt install -y autotools-dev autoconf automake# Ubuntu CPP 开发环境配置指南sudo apt install -y pkg-config\n\n第四步：安装调试工具1. 安装 GDB# Ubuntu CPP 开发环境配置指南sudo apt install -y gdb# Ubuntu CPP 开发环境配置指南sudo apt install -y gdbserver# Ubuntu CPP 开发环境配置指南gdb --version\n\n2. 安装 Valgrind (内存检查工具)# Ubuntu CPP 开发环境配置指南sudo apt install -y valgrind# Ubuntu CPP 开发环境配置指南valgrind --version\n\n3. 安装其他调试工具# Ubuntu CPP 开发环境配置指南sudo apt install -y strace# Ubuntu CPP 开发环境配置指南sudo apt install -y ltrace# Ubuntu CPP 开发环境配置指南sudo apt install -y lsof\n\n第五步：安装常用开发库1. 标准库和 STL 扩展# Ubuntu CPP 开发环境配置指南sudo apt install -y libboost-all-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libstdc++-12-dev\n\n2. 网络和通信库# Ubuntu CPP 开发环境配置指南sudo apt install -y libzmq3-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libgrpc++-dev libprotobuf-dev protobuf-compiler-grpc# Ubuntu CPP 开发环境配置指南sudo apt install -y libcurl4-openssl-dev\n\n3. 数据库库# Ubuntu CPP 开发环境配置指南sudo apt install -y libsqlite3-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libmysqlclient-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libpq-dev\n\n4. 图形和 GUI 库# Ubuntu CPP 开发环境配置指南sudo apt install -y qt6-base-dev qt6-tools-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libgtk-3-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libgl1-mesa-dev libglu1-mesa-dev libglut-dev\n\n5. 数学和科学计算库# Ubuntu CPP 开发环境配置指南sudo apt install -y libblas-dev liblapack-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libfftw3-dev# Ubuntu CPP 开发环境配置指南sudo apt install -y libeigen3-dev\n\n第六步：配置 IDE 和编辑器1. 安装 Visual Studio Code# Ubuntu CPP 开发环境配置指南wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpgsudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&#x27;sudo apt updatesudo apt install -y code# Ubuntu CPP 开发环境配置指南code --install-extension ms-vscode.cpptoolscode --install-extension ms-vscode.cmake-toolscode --install-extension ms-vscode.makefile-toolscode --install-extension vadimcn.vscode-lldb\n\n2. 安装 CLion (JetBrains IDE，可选)# Ubuntu CPP 开发环境配置指南# Ubuntu CPP 开发环境配置指南wget -O - https://download.jetbrains.com/toolbox/jetbrains-toolbox.tar.gz | tar xz./jetbrains-toolbox/jetbrains-toolbox\n\n3. 配置 Vim&#x2F;Neovim (可选)# Ubuntu CPP 开发环境配置指南sudo apt install -y neovim# Ubuntu CPP 开发环境配置指南mkdir -p ~/.config/nvimcat &gt; ~/.config/nvim/init.vim &lt;&lt; &#x27;EOF&#x27;&quot; C++ 开发配置set numberset syntax=onset tabstop=4set shiftwidth=4set expandtab&quot; 插件管理器 vim-plugsh -c &#x27;curl -fLo &quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim --create-dirs \\       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&#x27;&quot; 插件配置call plug#begin()Plug &#x27;derekwyatt/vim-cpp&#x27;Plug &#x27;rhysd/vim-clang-format&#x27;Plug &#x27;majutsushi/tagbar&#x27;call plug#end()EOF\n\n第七步：验证开发环境1. 创建测试项目# Ubuntu CPP 开发环境配置指南mkdir ~/cpp_test_projectcd ~/cpp_test_project# Ubuntu CPP 开发环境配置指南cat &gt; main.cpp &lt;&lt; &#x27;EOF&#x27;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;int main() &#123;    std::vector&lt;std::string&gt; names = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;&#125;;    std::cout &lt;&lt; &quot;Hello from C++!&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Names:&quot; &lt;&lt; std::endl;    for (const auto&amp; name : names) &#123;        std::cout &lt;&lt; &quot;- &quot; &lt;&lt; name &lt;&lt; std::endl;    &#125;    // 使用 STL 算法    std::sort(names.begin(), names.end());    std::cout &lt;&lt; &quot;\\nSorted names:&quot; &lt;&lt; std::endl;    for (const auto&amp; name : names) &#123;        std::cout &lt;&lt; &quot;- &quot; &lt;&lt; name &lt;&lt; std::endl;    &#125;    return 0;&#125;EOF# Ubuntu CPP 开发环境配置指南g++ -std=c++17 -Wall -Wextra -o main_g++ main.cpp# Ubuntu CPP 开发环境配置指南cat &gt; Makefile &lt;&lt; &#x27;EOF&#x27;CXX = g++CXXFLAGS = -std=c++17 -Wall -Wextra -O2TARGET = main_makeall: $(TARGET)$(TARGET): main.cpp\t$(CXX) $(CXXFLAGS) -o $(TARGET) main.cppclean:\trm -f $(TARGET).PHONY: all cleanEOFmake\n\n2. 使用 CMake 构建项目# Ubuntu CPP 开发环境配置指南cat &gt; CMakeLists.txt &lt;&lt; &#x27;EOF&#x27;cmake_minimum_required(VERSION 3.16)project(CppTestProject VERSION 1.0)set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)# Ubuntu CPP 开发环境配置指南if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang&quot;)    add_compile_options(-Wall -Wextra -Wpedantic)endif()# Ubuntu CPP 开发环境配置指南add_executable(main_cmake main.cpp)# Ubuntu CPP 开发环境配置指南target_compile_features(main_cmake PRIVATE cxx_std_17)# Ubuntu CPP 开发环境配置指南# Ubuntu CPP 开发环境配置指南# Ubuntu CPP 开发环境配置指南# Ubuntu CPP 开发环境配置指南EOF# Ubuntu CPP 开发环境配置指南mkdir buildcd buildcmake ..makecd ..# Ubuntu CPP 开发环境配置指南echo &quot;Testing g++ compiled version:&quot;./main_g++echo -e &quot;\\nTesting Make compiled version:&quot;./main_makeecho -e &quot;\\nTesting CMake compiled version:&quot;./build/main_cmake# Ubuntu CPP 开发环境配置指南make cleanrm -rf build\n\n3. 测试调试功能# Ubuntu CPP 开发环境配置指南g++ -std=c++17 -g -o main_debug main.cpp# Ubuntu CPP 开发环境配置指南echo &quot;Testing GDB:&quot;echo &quot;run&quot; | gdb -batch -ex &quot;break main&quot; -ex &quot;next&quot; -ex &quot;next&quot; ./main_debug# Ubuntu CPP 开发环境配置指南echo -e &quot;\\nTesting Valgrind:&quot;valgrind --leak-check=full --error-exitcode=1 ./main_debug\n\n第八步：配置环境变量1. 创建开发环境配置文件# Ubuntu CPP 开发环境配置指南cat &gt; ~/.cpp_dev_env &lt;&lt; &#x27;EOF&#x27;#!/bin/bash# Ubuntu CPP 开发环境配置指南# Ubuntu CPP 开发环境配置指南export CC=gccexport CXX=g++# Ubuntu CPP 开发环境配置指南export CMAKE_GENERATOR=Ninja  # 使用 Ninja 作为默认生成器# Ubuntu CPP 开发环境配置指南export DEV_HOME=$HOME/Developmentexport CPP_PROJECTS=$DEV_HOME/cpp_projects# Ubuntu CPP 开发环境配置指南mkdir -p $CPP_PROJECTS# Ubuntu CPP 开发环境配置指南alias cmake-build=&#x27;mkdir -p build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make&#x27;alias cmake-clean=&#x27;rm -rf build&#x27;alias cpp-run=&#x27;g++ -std=c++17 -Wall -Wextra -O2&#x27;alias cpp-debug=&#x27;g++ -std=c++17 -g -DDEBUG -Wall -Wextra&#x27;# Ubuntu CPP 开发环境配置指南git config --global init.defaultBranch maingit config --global pull.rebase falseEOF# Ubuntu CPP 开发环境配置指南echo &#x27;source ~/.cpp_dev_env&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc\n\n2. 配置 vcpkg (C++ 包管理器，可选)# Ubuntu CPP 开发环境配置指南git clone https://github.com/Microsoft/vcpkg.git ~/vcpkg~/vcpkg/bootstrap-vcpkg.sh# Ubuntu CPP 开发环境配置指南echo &#x27;export PATH=&quot;$PATH:~/vcpkg&quot;&#x27; &gt;&gt; ~/.bashrc# Ubuntu CPP 开发环境配置指南~/vcpkg/vcpkg integrate install# Ubuntu CPP 开发环境配置指南vcpkg version\n\n附录：常用命令速查编译命令# Ubuntu CPP 开发环境配置指南g++ -std=c++17 -o program source.cpp# Ubuntu CPP 开发环境配置指南g++ -std=c++17 -Wall -Wextra -O2 -o program source.cpp# Ubuntu CPP 开发环境配置指南g++ -std=c++17 -g -o program_debug source.cpp# Ubuntu CPP 开发环境配置指南g++ -std=c++17 -S -o program.s source.cpp# Ubuntu CPP 开发环境配置指南g++ -std=c++17 -o program source.cpp -lpthread -lm\n\nCMake 命令# Ubuntu CPP 开发环境配置指南cmake -B build -S .# Ubuntu CPP 开发环境配置指南cmake --build build# Ubuntu CPP 开发环境配置指南rm -rf build# Ubuntu CPP 开发环境配置指南cmake -B build -S . -DCMAKE_BUILD_TYPE=Releasecmake -B build -S . -DCMAKE_BUILD_TYPE=Debug\n\n调试命令# Ubuntu CPP 开发环境配置指南gdb ./program# Ubuntu CPP 开发环境配置指南(gdb) run                 # 运行程序(gdb) break main          # 在 main 函数设置断点(gdb) next               # 单步执行(gdb) step               # 进入函数(gdb) print variable     # 打印变量值(gdb) continue           # 继续执行(gdb) quit               # 退出 GDB# Ubuntu CPP 开发环境配置指南valgrind --leak-check=full ./programvalgrind --tool=callgrind ./program\n\n常见问题Q1: 编译时提示找不到头文件？A: 检查是否安装了对应的开发包。例如，找不到 &lt;boost/filesystem.hpp&gt; 时，运行：\nsudo apt install libboost-filesystem-dev\n\nQ2: 链接时提示找不到库？A: 使用 apt search 查找对应的开发包，或使用 pkg-config：\npkg-config --cflags --libs library_name\n\nQ3: GDB 调试时看不到变量值？A: 确保使用 -g 选项编译，并且没有启用优化：\ng++ -std=c++17 -g -O0 -o program source.cpp\n\nQ4: CMake 找不到包？A: 安装对应的开发包，或者使用 CMAKE_PREFIX_PATH 指定安装路径：\ncmake -DCMAKE_PREFIX_PATH=/usr/local ..\n\nQ5: 程序运行时提示 Segmentation fault？A: 使用 GDB 或 Valgrind 进行调试：\ngdb ./program(gdb) run(gdb) bt  # 查看调用栈# Ubuntu CPP 开发环境配置指南valgrind ./program\n\nQ6: 如何切换不同版本的 GCC？A: 使用 update-alternatives：\nsudo update-alternatives --config gccsudo update-alternatives --config g++\n\n通过本指南，您应该已经成功搭建了一个功能完整的 Ubuntu 22 C++ 开发环境。建议创建一个示例项目来测试所有组件是否正常工作。\n","categories":["C++核心开发","开发环境"],"tags":["Ubuntu","C++","开发环境","GCC","G++","CMake","GDB","VSCode","包管理"]},{"title":"HM MES 部署指南","url":"/posts/616ce96e/","content":"HM MES 部署指南目录\n概述\n环境准备\n后端编译与部署\n前端部署与反向代理\n常见问题排查\n\n概述Hm-MES 是一个基于 Java Spring Boot 的制造执行系统（MES），提供生产管理、质量控制、设备管理等一系列功能。本指南提供在 Windows 和 Ubuntu 系统上完整编译和部署 Hm-MES 的详细步骤。\n系统架构\n后端: Java Spring Boot + MyBatis\n前端: HTML5 + JavaScript\n中间件: Apache Tomcat\n数据库: MySQL 8.0\n消息队列 (可选): RabbitMQ\n反向代理 (可选): Nginx\n\n环境准备1. 软件依赖\nJDK: 11 (推荐，LTS版本)\nMaven: 3.6+\nTomcat: 9.0+\nMySQL: 8.0+\nGit\n\n2. 硬件要求\n最小配置: 2核CPU, 4GB内存, 20GB磁盘空间\n推荐配置: 4核CPU, 8GB内存, 50GB磁盘空间\n生产环境: 8核CPU, 16GB内存, 100GB SSD磁盘\n\n2. Windows 环境准备\n安装 JDK: 从 Adoptium 下载并安装。确保 JAVA_HOME 环境变量已设置。\n安装 Maven: 从 Maven 官网 下载并解压到 &lt;Your-Maven-Path&gt;。将 &lt;Your-Maven-Path&gt;\\bin 添加到系统 Path 环境变量。\n安装 Tomcat: 从 Tomcat 官网 下载并解压到 &lt;Your-Tomcat-Path&gt;。\n安装 MySQL: 使用 MySQL Installer 安装，并记住设置的 root 密码。\n\n3. Ubuntu 环境准备# HM MES 部署指南sudo apt update &amp;&amp; sudo apt upgrade -ysudo apt install -y openjdk-11-jdk maven tomcat9 mysql-server git# HM MES 部署指南sudo mysql_secure_installation# HM MES 部署指南sudo systemctl start tomcat9 &amp;&amp; sudo systemctl enable tomcat9sudo systemctl start mysql &amp;&amp; sudo systemctl enable mysql\n\n后端编译与部署1. 获取源码git clone https://gitee.com/liangshengpan/hm-MES.gitcd hm-MES\n\n2. 配置数据库# HM MES 部署指南mysql -u root -p# HM MES 部署指南CREATE DATABASE hm_mes CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;CREATE USER &#x27;hm_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;your_strong_password&#x27;;GRANT ALL PRIVILEGES ON hm_mes.* TO &#x27;hm_user&#x27;@&#x27;localhost&#x27;;# HM MES 部署指南ALTER USER &#x27;hm_user&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;your_strong_password&#x27;;FLUSH PRIVILEGES;EXIT;# HM MES 部署指南# HM MES 部署指南mysql -u hm_user -p hm_mes &lt; doc/hm-mes.sql\n\n3. 修改应用配置编辑后端项目的核心配置文件：mes-backend/src/main/resources/application.yml\nspring:  datasource:    # 确保这里的地址、数据库名、用户名和密码正确    url: jdbc:mysql://localhost:3306/hm_mes?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;allowPublicKeyRetrieval=true    username: hm_user # 使用我们刚创建的用户    password: your_strong_password # 替换为你的密码    driver-class-name: com.mysql.cj.jdbc.Driver  # 文件上传配置  servlet:    multipart:      max-file-size: 100MB      max-request-size: 100MBserver:  port: 8080  servlet:    # 应用的上下文路径，反向代理时会用到    context-path: /hm-mes\n\n4. 编译打包使用 Maven 将后端项目打包成 .war 文件。\n# HM MES 部署指南cd mes-backend# HM MES 部署指南mvn clean package -DskipTests\n成功后，你会在 mes-backend/target/ 目录下找到 hm-mes.war 文件。\n5. 部署到 Tomcat\n停止 Tomcat:\nWindows: 运行 &lt;Your-Tomcat-Path&gt;\\bin\\shutdown.bat\nUbuntu: sudo systemctl stop tomcat9\n\n\n部署 WAR 文件:\n将 hm-mes.war 文件复制到 Tomcat 的 webapps 目录下。\nWindows: &lt;Your-Tomcat-Path&gt;\\webapps\\\nUbuntu: /var/lib/tomcat9/webapps/\n\n\n启动 Tomcat:\nWindows: 运行 &lt;Your-Tomcat-Path&gt;\\bin\\startup.bat\nUbuntu: sudo systemctl start tomcat9\n\n\n\nTomcat 启动时会自动解压 .war 文件。\n6. 访问验证打开浏览器，访问 http://localhost:8080/hm-mes。如果能看到登录页面，说明后端部署成功。\n前端部署与反向代理为了获得更好的性能和更方便的管理，推荐使用 Nginx 来托管前端静态文件，并将 API 请求反向代理到 Tomcat。\n1. 部署前端文件将源码中的 mes-front 文件夹复制到你的 Web 服务器根目录，例如 /var/www/html/mes-front。\n2. 配置 Nginx创建一个新的 Nginx 站点配置：\nserver &#123;    listen 80;    server_name your_domain.com;    # 前端静态文件根目录    root /var/www/html/mes-front;    index index.html;    # 安全头设置    add_header X-Frame-Options &quot;SAMEORIGIN&quot; always;    add_header X-Content-Type-Options &quot;nosniff&quot; always;    add_header X-XSS-Protection &quot;1; mode=block&quot; always;    add_header Referrer-Policy &quot;strict-origin-when-cross-origin&quot; always;    # 静态资源缓存    location ~* \\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ &#123;        expires 1y;        add_header Cache-Control &quot;public, immutable&quot;;        access_log off;    &#125;    # SPA (单页应用) 路由支持    location / &#123;        try_files $uri $uri/ /index.html;    &#125;    # API 反向代理    # 将所有 /api/ 开头的请求转发到 Tomcat    location /api/ &#123;        # 注意：这里的 /hm-mes/ 必须与 application.yml 中的 context-path 一致        proxy_pass http://localhost:8080/hm-mes/;        # 设置超时时间        proxy_connect_timeout 60s;        proxy_send_timeout 60s;        proxy_read_timeout 60s;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        # 文件上传大小限制        client_max_body_size 100M;    &#125;&#125;\n重启 Nginx 后，你就可以通过域名直接访问前端页面，并且前端发出的 API 请求会被正确转发到后端。\n常见问题排查Q1: 数据库连接失败?A: 检查 application.yml 中的数据库地址、端口、用户名和密码是否正确。确认数据库服务正在运行，并且防火墙允许 3306 端口的连接。\nQ2: 部署后访问 404?A:\n\n检查 Tomcat 的 logs/catalina.out 日志，看应用是否在启动时报错。\n确认你的访问地址包含了正确的上下文路径，即 http://localhost:8080/hm-mes。\n如果使用了 Nginx，请检查 proxy_pass 路径是否正确。\n\nQ3: 文件上传失败?A: 检查 application.yml 中的 max-file-size 配置，以及部署目录是否有写入权限。\nQ4: MySQL 8.0 连接认证失败?A: MySQL 8.0 默认使用 caching_sha2_password 认证插件，Java 驱动可能不支持。需要将用户认证方式改为 mysql_native_password。\nQ5: Tomcat 内存溢出?A: 编辑 Tomcat 的 setenv.sh (Linux) 或 setenv.bat (Windows)，设置合适的 JVM 参数：\nexport CATALINA_OPTS=&quot;$CATALINA_OPTS -Xms2G -Xmx4G -XX:+UseG1GC&quot;\n\n生产环境部署优化1. JVM 参数优化在 Tomcat 启动脚本中添加以下 JVM 参数：\n# HM MES 部署指南-Xms4g -Xmx8g# HM MES 部署指南-XX:+UseG1GC-XX:MaxGCPauseMillis=200-XX:G1HeapRegionSize=16m# HM MES 部署指南-XX:+UseStringDeduplication-XX:+OptimizeStringConcat-Djava.awt.headless=true-Dfile.encoding=UTF-8-Duser.timezone=Asia/Shanghai\n\n2. 数据库连接池配置在 application.yml 中优化数据源配置：\nspring:  datasource:    hikari:      # 连接池大小      maximum-pool-size: 20      minimum-idle: 5      # 连接超时      connection-timeout: 20000      # 空闲连接超时      idle-timeout: 300000      # 连接最大生命周期      max-lifetime: 900000      # 连接测试      connection-test-query: SELECT 1\n\n3. 日志配置优化使用 Logback 配置文件 logback-spring.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;!-- 生产环境日志级别 --&gt;    &lt;springProfile name=&quot;prod&quot;&gt;        &lt;root level=&quot;INFO&quot;&gt;            &lt;appender-ref ref=&quot;FILE&quot;/&gt;        &lt;/root&gt;    &lt;/springProfile&gt;    &lt;!-- 日志文件配置 --&gt;    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;logs/hm-mes.log&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;logs/hm-mes.%d&#123;yyyy-MM-dd&#125;.%i.log.gz&lt;/fileNamePattern&gt;            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;            &lt;maxHistory&gt;30&lt;/maxHistory&gt;            &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;        &lt;/rollingPolicy&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;&lt;/configuration&gt;\n\n4. 安全配置清单\n 修改默认密码和密钥\n 启用 HTTPS（配置 SSL 证书）\n 配置防火墙规则\n 禁用不必要的服务端口\n 定期备份数据库\n 配置日志轮转\n 安装系统监控工具\n\n5. 防火墙配置# HM MES 部署指南sudo ufw allow 22/tcp    # SSHsudo ufw allow 80/tcp    # HTTPsudo ufw allow 443/tcp   # HTTPSsudo ufw allow 3306/tcp  # MySQL (仅内网)sudo ufw enable# HM MES 部署指南sudo firewall-cmd --permanent --add-service=httpsudo firewall-cmd --permanent --add-service=httpssudo firewall-cmd --reload\n\nDocker 部署方案1. Dockerfile创建 Dockerfile：\nFROM openjdk:11-jre-slim# HM MES 部署指南WORKDIR /app# HM MES 部署指南COPY target/hm-mes.war app.war# HM MES 部署指南RUN mkdir -p /app/logs# HM MES 部署指南EXPOSE 8080# HM MES 部署指南ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;app.war&quot;]\n\n2. Docker Compose创建 docker-compose.yml：\nversion: &#x27;3.8&#x27;services:  mysql:    image: mysql:8.0    environment:      MYSQL_ROOT_PASSWORD: root_password      MYSQL_DATABASE: hm_mes      MYSQL_USER: hm_user      MYSQL_PASSWORD: your_strong_password    ports:      - &quot;3306:3306&quot;    volumes:      - mysql_data:/var/lib/mysql      - ./doc/hm-mes.sql:/docker-entrypoint-initdb.d/init.sql    command: --default-authentication-plugin=mysql_native_password  mes-backend:    build: .    ports:      - &quot;8080:8080&quot;    depends_on:      - mysql    environment:      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/hm_mes?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true      SPRING_DATASOURCE_USERNAME: hm_user      SPRING_DATASOURCE_PASSWORD: your_strong_password    volumes:      - ./logs:/app/logs  nginx:    image: nginx:alpine    ports:      - &quot;80:80&quot;      - &quot;443:443&quot;    volumes:      - ./nginx.conf:/etc/nginx/conf.d/default.conf      - ./mes-front:/usr/share/nginx/html    depends_on:      - mes-backendvolumes:  mysql_data:\n\n3. Docker 部署命令# HM MES 部署指南docker-compose up -d# HM MES 部署指南docker-compose ps# HM MES 部署指南docker-compose logs -f mes-backend# HM MES 部署指南docker-compose down\n\n监控与维护1. 应用监控推荐\nPrometheus + Grafana: 系统和应用性能监控\nELK Stack: 日志收集和分析\nZabbix: 综合监控平台\n\n2. 备份策略# HM MES 部署指南#!/bin/bashBACKUP_DIR=&quot;/backup/mysql&quot;DATE=$(date +%Y%m%d_%H%M%S)mkdir -p $BACKUP_DIR# HM MES 部署指南mysqldump -u hm_user -p&#x27;your_strong_password&#x27; hm_mes | gzip &gt; $BACKUP_DIR/hm_mes_$DATE.sql.gz# HM MES 部署指南find $BACKUP_DIR -name &quot;*.sql.gz&quot; -mtime +7 -delete# HM MES 部署指南tar -czf $BACKUP_DIR/mes-front_$DATE.tar.gz /var/www/html/mes-front\n\n3. 性能测试建议使用 JMeter 或 LoadRunner 进行压力测试：\n\n并发用户数：100-500\n测试场景：登录、查询、数据录入\n监控指标：响应时间、吞吐量、CPU&#x2F;内存使用率\n\n总结本指南涵盖了 Hm-MES 系统从开发环境到生产环境的完整部署流程。在实际部署中，请根据：\n\n业务规模：调整硬件配置和 JVM 参数\n安全要求：实施相应的安全措施\n性能需求：优化数据库和缓存配置\n运维要求：建立完善的监控和备份机制\n\n如有问题，请联系技术支持团队。\n","categories":["云服务与DevOps","企业级应用"],"tags":["MES","制造执行系统","编译部署","Java","Spring Boot","Tomcat","Nginx"]},{"title":"QtInstallerFramework 安装包制作指南","url":"/posts/3097e686/","content":"QtInstallerFramework 安装包制作指南目录\n工具概述\n安装准备\n项目结构\n配置文件详解\n安装脚本详解\n生成安装包\n高级功能\n常见问题\n最佳实践\n\n工具概述QtInstallerFramework 是 Qt 官方提供的跨平台安装包制作工具，支持 Windows、macOS 和 Linux 平台。\n特点\n跨平台支持\n图形化安装向导\n强大的组件和依赖管理\n支持在线和离线安装模式\n可通过脚本（qs）高度自定义安装过程\n支持多语言\n\n安装准备1. 获取 QtInstallerFrameworkQtInstallerFramework 通常包含在 Qt 的在线安装器中，作为一个可选组件。也可以从 Qt 官网单独下载。\n它的默认安装路径通常在 Qt 的 Tools 目录下，例如：&lt;Qt安装目录&gt;\\Tools\\QtInstallerFramework\\4.8\\bin。\n2. 环境变量配置为了方便在任何路径下使用命令行工具，建议将 QtInstallerFramework 的 bin 目录添加到系统的 PATH 环境变量中。\nWindows 示例:\n# 将 &lt;Your-Qt-InstallerFramework-Path&gt; 替换为你的实际路径set PATH=%PATH%;&lt;Your-Qt-InstallerFramework-Path&gt;\\bin\n\n项目结构一个典型的安装包项目结构如下：\nYourAppInstaller/├── config/│   └── config.xml          # 1. 主配置文件└── packages/    └── com.yourcompany.yourapp/        ├── meta/        │   ├── package.xml         # 2. 包（组件）配置文件        │   └── installscript.qs     # 3. 安装脚本 (可选)        └── data/                    # 4. 要安装的实际文件            ├── YourApp.exe            ├── Qt6Core.dll            └── ...\n\n配置文件详解1. 主配置文件 (config&#x2F;config.xml)该文件定义了安装器的整体行为和外观。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Installer&gt;    &lt;!-- 应用名称 --&gt;    &lt;Name&gt;YourApp&lt;/Name&gt;    &lt;!-- 应用版本 --&gt;    &lt;Version&gt;1.0.0&lt;/Version&gt;    &lt;!-- 安装器标题 --&gt;    &lt;Title&gt;YourApp Installer&lt;/Title&gt;    &lt;!-- 发行商 --&gt;    &lt;Publisher&gt;YourCompany&lt;/Publisher&gt;    &lt;!-- 开始菜单目录 --&gt;    &lt;StartMenuDir&gt;YourApp&lt;/StartMenuDir&gt;    &lt;!-- 默认安装路径, @ApplicationsDir@ 是预定义变量 --&gt;    &lt;TargetDir&gt;@ApplicationsDir@/YourApp&lt;/TargetDir&gt;        &lt;!-- (可选) 安装程序图标 --&gt;    &lt;InstallerWindowIcon&gt;installer_icon.ico&lt;/InstallerWindowIcon&gt;    &lt;!-- (可选) 应用图标 --&gt;    &lt;InstallerApplicationIcon&gt;app_icon.ico&lt;/InstallerApplicationIcon&gt;    &lt;!-- (可选) Logo图片 --&gt;    &lt;Logo&gt;logo.png&lt;/Logo&gt;&lt;/Installer&gt;\n\n2. 包配置文件 (packages&#x2F;…&#x2F;meta&#x2F;package.xml)每个组件（包）都有一个 package.xml，用于描述该组件。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Package&gt;    &lt;!-- 显示名称 --&gt;    &lt;DisplayName&gt;Main Application&lt;/DisplayName&gt;    &lt;!-- 组件描述 --&gt;    &lt;Description&gt;The main application files.&lt;/Description&gt;    &lt;!-- 组件版本 --&gt;    &lt;Version&gt;1.0.0&lt;/Version&gt;    &lt;!-- 发布日期 --&gt;    &lt;ReleaseDate&gt;2024-01-01&lt;/ReleaseDate&gt;    &lt;!-- 默认选中 --&gt;    &lt;Default&gt;true&lt;/Default&gt;    &lt;!-- 关联的安装脚本 --&gt;    &lt;Script&gt;installscript.qs&lt;/Script&gt;&lt;/Package&gt;\n\n安装脚本详解 (meta&#x2F;installscript.qs)安装脚本使用类 QML 的语法（qs），允许你完全自定义安装和卸载过程。\n// installscript.qsfunction Component() &#123;    // 构造函数，可以在此获取安装器核心对象&#125;// 定义安装操作Component.prototype.createOperations = function() &#123;    // 必须先调用父类的同名方法    component.createOperations();    // 示例：在Windows上创建桌面快捷方式    if (systemInfo.kernelType === &quot;winnt&quot;) &#123;        component.addOperation(            &quot;CreateShortcut&quot;,                               // 操作类型            &quot;@TargetDir@/YourApp.exe&quot;,                      // 目标文件            &quot;@DesktopDir@/YourApp.lnk&quot;,                     // 快捷方式路径            &quot;workingDirectory=@TargetDir@&quot;,                 // 工作目录            &quot;iconPath=@TargetDir@/app_icon.ico&quot;,            // 快捷方式图标            &quot;iconIndex=0&quot;                                   // 图标索引        );    &#125;    // 示例：在Windows上创建开始菜单快捷方式    if (systemInfo.kernelType === &quot;winnt&quot;) &#123;        component.addOperation(            &quot;CreateShortcut&quot;,            &quot;@TargetDir@/YourApp.exe&quot;,            &quot;@StartMenuDir@/YourApp.lnk&quot;,            &quot;workingDirectory=@TargetDir@&quot;        );    &#125;&#125;\n\n生成安装包在项目根目录（例如 YourAppInstaller/）打开命令行，执行以下命令：\n1. 生成在线安装包在线安装包体积小，安装时从服务器下载组件数据。需要预先将组件上传到服务器。\n# binarycreator 是 QtInstallerFramework 的核心工具binarycreator --online-only -c config/config.xml -p packages YourAppInstaller_Online.exe\n\n2. 生成离线安装包离线安装包包含所有文件，体积较大，无需联网即可安装。\n# -f 是 --offline-only 的简写binarycreator -f -c config/config.xml -p packages YourAppInstaller_Offline.exe\n\n高级功能多语言支持在 config.xml 中添加语言包文件（.ts 文件编译后的 .qm 文件）。\n&lt;Installer&gt;    ...    &lt;Translations&gt;        &lt;Translation&gt;zh_CN.qm&lt;/Translation&gt;        &lt;Translation&gt;en_US.qm&lt;/Translation&gt;    &lt;/Translations&gt;&lt;/Installer&gt;\n\n静默&#x2F;无人值守安装使用命令行参数进行自动化安装。\n# --unattended 是关键参数YourAppInstaller.exe --unattended# 也可以结合脚本实现更复杂的自动安装# YourAppInstaller.exe --unattended --script your_script.qs# 指定安装目录YourAppInstaller.exe --unattended --target &quot;C:\\Path\\To\\Install&quot;\n\n常见问题Q1: 如何打包 VC++ 运行时库?A: 推荐在 installscript.qs 中添加一个操作来静默安装 VC++ 运行时（vc_redist.x64.exe）。首先将 vc_redist.x64.exe 放入 data 目录，然后添加操作：\ncomponent.addOperation(&quot;Execute&quot;,    &quot;@TargetDir@/vc_redist.x64.exe&quot;,    &quot;/quiet&quot;,    &quot;/norestart&quot;);\n\nQ2: 如何使用 windeployqt 自动收集 Qt 依赖?A: windeployqt 是一个非常方便的工具。\n# 1. 先在一个临时目录生成你的 Release 版本的 exe# 2. 在该目录运行 windeployqtwindeployqt YourApp.exe# 3. 将所有生成的文件和目录（platforms, styles, translations等）复制到你的组件的 data 目录下\n\nQ3: 快捷方式无法创建?A: 检查 installscript.qs 中的路径是否正确，特别是 @TargetDir@/YourApp.exe 是否指向了正确的可执行文件。确保 CreateShortcut 操作在 component.createOperations() 之后调用。\n最佳实践\n组件化: 将大型应用拆分为多个组件（packages），例如主程序、文档、快捷方式等。这让用户可以选择性安装，也便于维护。\n环境变量: 避免在脚本中硬编码路径，多使用预定义变量如 @TargetDir@, @DesktopDir@ 等。\n卸载逻辑: 在 installscript.qs 中为自定义的安装操作（如添加注册表、配置文件）编写对应的卸载逻辑。\n测试: 在干净的虚拟机中（特别是 Windows）测试你的安装、卸载和更新流程。\n\n","categories":["C++核心开发","Qt框架"],"tags":["QtInstallerFramework","安装包制作","部署工具","Qt"]},{"title":"Windows 服务配置指南","url":"/posts/7a1e3650/","content":"Windows 服务配置指南目录\nWindows 服务概述\n服务管理基础\n常见服务配置\n服务优化\n故障排除\n自动化管理\n安全配置\n\nWindows 服务概述Windows 服务是在后台运行的程序，不依赖于用户登录，提供系统级功能。\n服务特点\n后台运行: 无需用户交互\n自动启动: 可配置为系统启动时自动运行\n系统权限: 通常以系统账户运行\n可管理: 通过服务管理器进行控制\n\n服务类型\n内置服务: Windows 系统自带的服务\n第三方服务: 应用程序安装的服务\n自定义服务: 用户开发的 Windows 服务\n\n服务管理基础服务管理器界面打开服务管理器\n运行命令: services.msc\n控制面板: 控制面板 → 管理工具 → 服务\n任务管理器: 任务管理器 → 服务选项卡\nPowerShell: Get-Service\n\n服务管理器界面说明\n名称: 服务显示名称\n描述: 服务功能说明\n状态: 运行状态（运行中&#x2F;已停止）\n启动类型: 启动方式\n登录身份: 服务运行账户\n进程ID: 服务进程标识符\n\n命令行管理net 命令# Windows 服务配置指南net start# Windows 服务配置指南net start 服务名称# Windows 服务配置指南net stop 服务名称# Windows 服务配置指南net pause 服务名称# Windows 服务配置指南net continue 服务名称# Windows 服务配置指南net start | findstr &quot;服务名称&quot;\n\nsc 命令# Windows 服务配置指南sc query 服务名称# Windows 服务配置指南sc qc 服务名称# Windows 服务配置指南sc start 服务名称# Windows 服务配置指南sc stop 服务名称# Windows 服务配置指南sc pause 服务名称# Windows 服务配置指南sc continue 服务名称# Windows 服务配置指南sc delete 服务名称# Windows 服务配置指南sc create 服务名称 binPath= &quot;C:\\path\\to\\service.exe&quot; start= auto DisplayName= &quot;显示名称&quot;# Windows 服务配置指南sc config 服务名称 start= delayed-autosc config 服务名称 binPath= &quot;C:\\new\\path\\to\\service.exe&quot;sc config 服务名称 DisplayName= &quot;新显示名称&quot;\n\nPowerShell 命令# Windows 服务配置指南Get-Service# Windows 服务配置指南Get-Service -Name &quot;服务名称&quot;# Windows 服务配置指南Start-Service -Name &quot;服务名称&quot;# Windows 服务配置指南Stop-Service -Name &quot;服务名称&quot;# Windows 服务配置指南Restart-Service -Name &quot;服务名称&quot;# Windows 服务配置指南Suspend-Service -Name &quot;服务名称&quot;# Windows 服务配置指南Resume-Service -Name &quot;服务名称&quot;# Windows 服务配置指南Get-Service -Name &quot;服务名称&quot; | Select-Object Status, StartType# Windows 服务配置指南Set-Service -Name &quot;服务名称&quot; -StartupType AutomaticSet-Service -Name &quot;服务名称&quot; -StartupType AutomaticDelayedStartSet-Service -Name &quot;服务名称&quot; -StartupType ManualSet-Service -Name &quot;服务名称&quot; -StartupType Disabled\n\n常见服务配置MySQL 服务配置安装 MySQL 服务# Windows 服务配置指南cd D:\\Software\\MySQL\\bin# Windows 服务配置指南mysqld --initialize --console# Windows 服务配置指南mysqld --install MySQL --defaults-file=&quot;D:\\Software\\MySQL\\my.ini&quot;# Windows 服务配置指南net start MySQL# Windows 服务配置指南sc config MySQL start= auto\n\n服务管理脚本@echo offrem mysql_service_manager.batset MYSQL_HOME=D:\\Software\\MySQLset MYSQL_SERVICE=MySQLecho MySQL Service Managerecho ======================:menuecho 1. Start MySQL Serviceecho 2. Stop MySQL Serviceecho 3. Restart MySQL Serviceecho 4. Check Service Statusecho 5. View MySQL Logecho 6. Connect to MySQLecho 7. Exitset /p choice=&quot;Enter choice: &quot;if &quot;%choice%&quot;==&quot;1&quot; (    echo Starting MySQL service...    net start %MYSQL_SERVICE%) else if &quot;%choice%&quot;==&quot;2&quot; (    echo Stopping MySQL service...    net stop %MYSQL_SERVICE%) else if &quot;%choice%&quot;==&quot;3&quot; (    echo Restarting MySQL service...    net stop %MYSQL_SERVICE%    timeout /t 2 &gt;nul    net start %MYSQL_SERVICE%) else if &quot;%choice%&quot;==&quot;4&quot; (    echo Checking MySQL service status...    sc query %MYSQL_SERVICE%) else if &quot;%choice%&quot;==&quot;5&quot; (    echo Opening MySQL log...    type &quot;%MYSQL_HOME%\\data\\*.err&quot; | more) else if &quot;%choice%&quot;==&quot;6&quot; (    echo Connecting to MySQL...    &quot;%MYSQL_HOME%\\bin\\mysql.exe&quot; -u root -p) else if &quot;%choice%&quot;==&quot;7&quot; (    echo Exiting...    exit /b 0) else (    echo Invalid choice!)timeout /t 2 &gt;nulgoto menu\n\nRedis 服务配置安装 Redis 服务# Windows 服务配置指南cd D:\\Software\\Redis# Windows 服务配置指南redis-server --service-install redis.windows.conf --service-name Redis# Windows 服务配置指南redis-server --service-start --service-name Redis# Windows 服务配置指南sc config Redis start= auto\n\nIIS 服务配置启用 IIS 服务# Windows 服务配置指南dism /online /enable-feature /featurename:IIS-WebServerRole# Windows 服务配置指南net start w3svc# Windows 服务配置指南sc config w3svc start= auto\n\nIIS 服务管理脚本@echo offrem iis_service_manager.batecho IIS Service Managerecho ===================:menuecho 1. Start IIS Serviceecho 2. Stop IIS Serviceecho 3. Restart IIS Serviceecho 4. Check Service Statusecho 5. Reset IISecho 6. View IIS Logecho 7. Exitset /p choice=&quot;Enter choice: &quot;if &quot;%choice%&quot;==&quot;1&quot; (    echo Starting IIS service...    net start w3svc) else if &quot;%choice%&quot;==&quot;2&quot; (    echo Stopping IIS service...    net stop w3svc) else if &quot;%choice%&quot;==&quot;3&quot; (    echo Restarting IIS service...    net stop w3svc    timeout /t 2 &gt;nul    net start w3svc) else if &quot;%choice%&quot;==&quot;4&quot; (    echo Checking IIS service status...    sc query w3svc) else if &quot;%choice%&quot;==&quot;5&quot; (    echo Resetting IIS...    iisreset) else if &quot;%choice%&quot;==&quot;6&quot; (    echo Opening IIS log...    type &quot;C:\\inetpub\\logs\\LogFiles\\W3SVC1\\*.log&quot; | more) else if &quot;%choice%&quot;==&quot;7&quot; (    echo Exiting...    exit /b 0) else (    echo Invalid choice!)timeout /t 2 &gt;nulgoto menu\n\n服务优化启动类型优化启动类型说明\n自动 (Automatic): 系统启动时自动启动\n自动(延迟启动) (AutomaticDelayedStart): 系统启动后延迟启动\n手动 (Manual): 需要手动启动\n已禁用 (Disabled): 禁用服务\n触发启动 (Trigger Start): 通过事件触发启动\n\n优化建议# Windows 服务配置指南Set-Service -Name &quot;AdobeARMservice&quot; -StartupType AutomaticDelayedStartSet-Service -Name &quot;GoogleChromeElevationService&quot; -StartupType AutomaticDelayedStart# Windows 服务配置指南Set-Service -Name &quot;Fax&quot; -StartupType DisabledSet-Service -Name &quot;Spooler&quot; -StartupType Disabled  # 如果不需要打印Set-Service -Name &quot;RemoteRegistry&quot; -StartupType Disabled  # 安全考虑\n\n服务依赖关系查看服务依赖# Windows 服务配置指南sc enumdepend 服务名称# Windows 服务配置指南sc qdepend 服务名称# Windows 服务配置指南Get-Service -Name &quot;服务名称&quot; | Select-Object DependentServices, ServicesDependedOn\n\n批量服务管理# Windows 服务配置指南$service = Get-Service -Name &quot;主服务名称&quot;$service.ServicesDependedOn | ForEach-Object &#123;    if ($_.Status -eq &quot;Stopped&quot;) &#123;        Start-Service $_.Name    &#125;&#125;# Windows 服务配置指南$service = Get-Service -Name &quot;主服务名称&quot;$service.DependentServices | ForEach-Object &#123;    if ($_.Status -eq &quot;Running&quot;) &#123;        Stop-Service $_.Name -Force    &#125;&#125;\n\n性能监控服务监控脚本# Windows 服务配置指南$services = @(&quot;MySQL&quot;, &quot;Redis&quot;, &quot;w3svc&quot;)$logFile = &quot;C:\\logs\\service_monitor.log&quot;function Write-Log &#123;    param($message)    $timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;    Add-Content $logFile &quot;$timestamp - $message&quot;&#125;while ($true) &#123;    foreach ($serviceName in $services) &#123;        try &#123;            $service = Get-Service -Name $serviceName -ErrorAction Stop            if ($service.Status -ne &quot;Running&quot;) &#123;                Write-Log &quot;$serviceName is not running (Status: $($service.Status))&quot;                # 尝试启动服务                try &#123;                    Start-Service -Name $serviceName -ErrorAction Stop                    Write-Log &quot;Successfully started $serviceName&quot;                &#125; catch &#123;                    Write-Log &quot;Failed to start $serviceName: $_&quot;                &#125;            &#125;        &#125; catch &#123;            Write-Log &quot;Error checking $serviceName: $_&quot;        &#125;    &#125;    # 每5分钟检查一次    Start-Sleep -Seconds 300&#125;\n\n资源使用监控# Windows 服务配置指南Get-Process | Where-Object &#123;$_.ProcessName -in @(&quot;mysqld&quot;, &quot;redis-server&quot;, &quot;w3wp&quot;)&#125; |    Select-Object ProcessName, CPU, WorkingSet, PrivateMemorySize, StartTime |    Format-Table -AutoSize\n\n故障排除常见服务问题服务无法启动# Windows 服务配置指南sc query 服务名称# Windows 服务配置指南eventvwr.msc# Windows 服务配置指南sc enumdepend 服务名称# Windows 服务配置指南&quot;C:\\path\\to\\service.exe&quot; --test\n\n服务启动后自动停止# Windows 服务配置指南sc query 服务名称# Windows 服务配置指南wevtutil qe System /c:1 /rd:true /f:text | findstr &quot;服务名称&quot;# Windows 服务配置指南sc qc 服务名称# Windows 服务配置指南icacls &quot;C:\\path\\to\\service.exe&quot;\n\n服务响应超时# Windows 服务配置指南sc config 服务名称 start= delayed-auto# Windows 服务配置指南reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\服务名称&quot; /v &quot;Timeout&quot; /t REG_DWORD /d 180000 /f\n\n诊断工具服务诊断工具# Windows 服务配置指南function Diagnose-Service &#123;    param($serviceName)    Write-Host &quot;=== Service Diagnosis for $serviceName ===&quot; -ForegroundColor Green    # 检查服务是否存在    try &#123;        $service = Get-Service -Name $serviceName -ErrorAction Stop        Write-Host &quot;Service Found: $($service.DisplayName)&quot; -ForegroundColor Green    &#125; catch &#123;        Write-Host &quot;Service not found: $serviceName&quot; -ForegroundColor Red        return    &#125;    # 检查服务状态    Write-Host &quot;Status: $($service.Status)&quot; -ForegroundColor Cyan    Write-Host &quot;StartType: $($service.StartType)&quot; -ForegroundColor Cyan    # 检查服务进程    if ($service.Status -eq &quot;Running&quot;) &#123;        try &#123;            $process = Get-Process -Id $service.Id -ErrorAction Stop            Write-Host &quot;Process ID: $($process.Id)&quot; -ForegroundColor Cyan            Write-Host &quot;CPU Time: $($process.CPU)&quot; -ForegroundColor Cyan            Write-Host &quot;Memory: $([math]::Round($process.WorkingSet/1MB, 2)) MB&quot; -ForegroundColor Cyan        &#125; catch &#123;            Write-Host &quot;Process not found for service&quot; -ForegroundColor Yellow        &#125;    &#125;    # 检查服务依赖    Write-Host &quot;Dependencies:&quot; -ForegroundColor Cyan    $service.ServicesDependedOn | ForEach-Object &#123;        Write-Host &quot;  - $($_.Name) ($($_.Status))&quot; -ForegroundColor White    &#125;    # 检查依赖服务    Write-Host &quot;Dependent Services:&quot; -ForegroundColor Cyan    $service.DependentServices | ForEach-Object &#123;        Write-Host &quot;  - $($_.Name) ($($_.Status))&quot; -ForegroundColor White    &#125;    # 检查服务配置    Write-Host &quot;Service Configuration:&quot; -ForegroundColor Cyan    $config = sc.exe qc $serviceName    $config | Where-Object &#123;$_ -match &quot;START_TYPE|BINARY_PATH_NAME|DISPLAY_NAME&quot;&#125; | ForEach-Object &#123;        Write-Host &quot;  $_&quot; -ForegroundColor White    &#125;    # 检查事件日志    Write-Host &quot;Recent Events:&quot; -ForegroundColor Cyan    $events = Get-WinEvent -LogName System -MaxEvents 10 | Where-Object &#123;        $_.ProviderName -eq &quot;Service Control Manager&quot; -and $_.Message -match $serviceName    &#125;    if ($events) &#123;        $events | ForEach-Object &#123;            Write-Host &quot;  $($_.TimeCreated) - $($_.Message)&quot; -ForegroundColor White        &#125;    &#125; else &#123;        Write-Host &quot;  No recent events found&quot; -ForegroundColor Yellow    &#125;&#125;# Windows 服务配置指南Diagnose-Service &quot;MySQL&quot;Diagnose-Service &quot;w3svc&quot;\n\n服务恢复脚本# Windows 服务配置指南function Repair-Service &#123;    param($serviceName)    Write-Host &quot;Attempting to repair service: $serviceName&quot; -ForegroundColor Green    try &#123;        # 停止服务        Stop-Service -Name $serviceName -Force -ErrorAction Stop        Write-Host &quot;Service stopped successfully&quot; -ForegroundColor Green        # 等待2秒        Start-Sleep -Seconds 2        # 启动服务        Start-Service -Name $serviceName -ErrorAction Stop        Write-Host &quot;Service started successfully&quot; -ForegroundColor Green        # 验证服务状态        $service = Get-Service -Name $serviceName        if ($service.Status -eq &quot;Running&quot;) &#123;            Write-Host &quot;Service repair successful!&quot; -ForegroundColor Green        &#125; else &#123;            Write-Host &quot;Service repair failed. Status: $($service.Status)&quot; -ForegroundColor Red        &#125;    &#125; catch &#123;        Write-Host &quot;Error repairing service: $_&quot; -ForegroundColor Red    &#125;&#125;\n\n自动化管理批量服务管理批量启动&#x2F;停止服务# Windows 服务配置指南$servicesToStart = @(&quot;MySQL&quot;, &quot;Redis&quot;, &quot;w3svc&quot;)foreach ($service in $servicesToStart) &#123;    try &#123;        $svc = Get-Service -Name $service -ErrorAction Stop        if ($svc.Status -ne &quot;Running&quot;) &#123;            Start-Service -Name $service            Write-Host &quot;Started $service&quot; -ForegroundColor Green        &#125; else &#123;            Write-Host &quot;$service is already running&quot; -ForegroundColor Yellow        &#125;    &#125; catch &#123;        Write-Host &quot;Failed to start $service: $_&quot; -ForegroundColor Red    &#125;&#125;# Windows 服务配置指南$servicesToStop = @(&quot;MySQL&quot;, &quot;Redis&quot;, &quot;w3svc&quot;)foreach ($service in $servicesToStop) &#123;    try &#123;        $svc = Get-Service -Name $service -ErrorAction Stop        if ($svc.Status -eq &quot;Running&quot;) &#123;            Stop-Service -Name $service -Force            Write-Host &quot;Stopped $service&quot; -ForegroundColor Green        &#125; else &#123;            Write-Host &quot;$service is already stopped&quot; -ForegroundColor Yellow        &#125;    &#125; catch &#123;        Write-Host &quot;Failed to stop $service: $_&quot; -ForegroundColor Red    &#125;&#125;\n\n定时任务管理# Windows 服务配置指南$action = &#123;    $services = @(&quot;MySQL&quot;, &quot;Redis&quot;, &quot;w3svc&quot;)    foreach ($service in $services) &#123;        $svc = Get-Service -Name $service -ErrorAction SilentlyContinue        if ($svc -and $svc.Status -ne &quot;Running&quot;) &#123;            try &#123;                Start-Service -Name $service                Write-Host &quot;$(Get-Date): Started $service&quot;            &#125; catch &#123;                Write-Host &quot;$(Get-Date): Failed to start $service&quot;            &#125;        &#125;    &#125;&#125;$trigger = New-JobTrigger -Once -At (Get-Date).AddMinutes(1) -RepetitionInterval (New-TimeSpan -Minutes 5) -RepetitionIndefinitelyRegister-ScheduledJob -Name &quot;ServiceMonitor&quot; -ScriptBlock $action -Trigger $trigger -RunLevel Highest\n\n配置文件管理服务配置导出# Windows 服务配置指南function Export-ServiceConfig &#123;    param($outputFile = &quot;C:\\service_config.csv&quot;)    $services = Get-Service    $results = @()    foreach ($service in $services) &#123;        $config = sc.exe qc $service.Name        $binaryPath = ($config | Where-Object &#123;$_ -match &quot;BINARY_PATH_NAME&quot;&#125;) -replace &quot;BINARY_PATH_NAME\\s*:\\s*&quot;        $startType = ($config | Where-Object &#123;$_ -match &quot;START_TYPE&quot;&#125;) -replace &quot;START_TYPE\\s*:\\s*&quot;        $result = [PSCustomObject]@&#123;            ServiceName = $service.Name            DisplayName = $service.DisplayName            Status = $service.Status            StartType = $service.StartType            BinaryPath = $binaryPath            ConfigStartType = $startType            ProcessId = if ($service.Status -eq &quot;Running&quot;) &#123; $service.Id &#125; else &#123; $null &#125;            CanStop = $service.CanStop            CanPauseAndContinue = $service.CanPauseAndContinue        &#125;        $results += $result    &#125;    $results | Export-Csv -Path $outputFile -NoTypeInformation -Encoding UTF8    Write-Host &quot;Service configuration exported to $outputFile&quot; -ForegroundColor Green&#125;# Windows 服务配置指南Export-ServiceConfig\n\n服务配置导入# Windows 服务配置指南function Import-ServiceConfig &#123;    param($inputFile = &quot;C:\\service_config.csv&quot;)    if (-not (Test-Path $inputFile)) &#123;        Write-Host &quot;Configuration file not found: $inputFile&quot; -ForegroundColor Red        return    &#125;    $configs = Import-Csv -Path $inputFile    foreach ($config in $configs) &#123;        try &#123;            # 恢复启动类型            if ($config.StartType -ne $config.ConfigStartType) &#123;                Set-Service -Name $config.ServiceName -StartupType $config.StartType                Write-Host &quot;Restored startup type for $($config.ServiceName)&quot; -ForegroundColor Green            &#125;            # 如果服务应该运行但当前停止，启动它            if ($config.Status -eq &quot;Running&quot;) &#123;                $currentStatus = (Get-Service -Name $config.ServiceName).Status                if ($currentStatus -ne &quot;Running&quot;) &#123;                    Start-Service -Name $config.ServiceName                    Write-Host &quot;Started $($config.ServiceName)&quot; -ForegroundColor Green                &#125;            &#125;        &#125; catch &#123;            Write-Host &quot;Failed to restore $($config.ServiceName): $_&quot; -ForegroundColor Red        &#125;    &#125;&#125;\n\n安全配置服务账户管理服务账户类型\nLocal System: 完全系统权限\nLocal Service: 有限权限，网络访问受限\nNetwork Service: 网络访问权限\n指定用户账户: 自定义域或本地账户\n\n安全账户配置# Windows 服务配置指南$serviceName = &quot;MySQL&quot;$account = &quot;NT AUTHORITY\\NetworkService&quot;$password = ConvertTo-SecureString &quot;&quot; -AsPlainText -Force# Windows 服务配置指南sc.exe config $serviceName obj= $accountif ($password) &#123;    sc.exe config $serviceName password= $password&#125;# Windows 服务配置指南Restart-Service -Name $serviceName -Force\n\n最小权限原则# Windows 服务配置指南$serviceName = &quot;CustomService&quot;$accountName = &quot;svc_$serviceName&quot;# Windows 服务配置指南$password = ConvertTo-SecureString &quot;P@ssw0rd123!&quot; -AsPlainText -ForceNew-LocalUser -Name $accountName -Password $password -PasswordNeverExpires -AccountNeverExpires -Description &quot;Service account for $serviceName&quot;# Windows 服务配置指南# Windows 服务配置指南\n\n服务权限配置文件系统权限# Windows 服务配置指南$servicePath = &quot;C:\\Program Files\\MyService\\MyService.exe&quot;$account = &quot;NT AUTHORITY\\NetworkService&quot;# Windows 服务配置指南$acl = Get-Acl $servicePath$rule = New-Object System.Security.AccessControl.FileSystemAccessRule(    $account,    &quot;ReadAndExecute&quot;,    &quot;ContainerInherit,ObjectInherit&quot;,    &quot;None&quot;,    &quot;Allow&quot;)$acl.SetAccessRule($rule)Set-Acl $servicePath $acl\n\n注册表权限# Windows 服务配置指南$regPath = &quot;HKLM:\\SYSTEM\\CurrentControlSet\\Services\\$serviceName&quot;$account = &quot;NT AUTHORITY\\NetworkService&quot;$acl = Get-Acl $regPath$rule = New-Object System.Security.AccessControl.RegistryAccessRule(    $account,    &quot;ReadKey,WriteKey,Delete,EnumerateSubKeys&quot;,    &quot;ContainerInherit,ObjectInherit&quot;,    &quot;None&quot;,    &quot;Allow&quot;)$acl.SetAccessRule($rule)Set-Acl $regPath $acl\n\n安全审计服务访问审计# Windows 服务配置指南auditpol /set /subcategory:&quot;Service&quot; /success:enable /failure:enable# Windows 服务配置指南Get-WinEvent -LogName Security | Where-Object &#123;    $_.Id -eq 4674 -or $_.Id -eq 4697 -or $_.Id -eq 4698&#125; | Format-List TimeCreated, Id, Message\n\n服务监控脚本# Windows 服务配置指南$monitorServices = @(&quot;MySQL&quot;, &quot;Redis&quot;, &quot;w3svc&quot;)$logFile = &quot;C:\\logs\\service_security.log&quot;function Write-SecurityLog &#123;    param($message)    $timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;    Add-Content $logFile &quot;$timestamp - SECURITY - $message&quot;&#125;foreach ($serviceName in $monitorServices) &#123;    try &#123;        $service = Get-Service -Name $serviceName        # 检查服务账户        $config = sc.exe qc $serviceName        $account = ($config | Where-Object &#123;$_ -match &quot;SERVICE_START_NAME&quot;&#125;) -replace &quot;SERVICE_START_NAME\\s*:\\s*&quot;        # 检查文件权限        $binaryPath = ($config | Where-Object &#123;$_ -match &quot;BINARY_PATH_NAME&quot;&#125;) -replace &quot;BINARY_PATH_NAME\\s*:\\s*&quot;        if ($binaryPath -match &quot;^`&quot;(.+?)`&quot;&quot;) &#123;            $filePath = $matches[1]            if (Test-Path $filePath) &#123;                $acl = Get-Acl $filePath                Write-SecurityLog &quot;$serviceName - File permissions checked for $filePath&quot;            &#125;        &#125;        Write-SecurityLog &quot;$serviceName - Account: $account - Status: $($service.Status)&quot;    &#125; catch &#123;        Write-SecurityLog &quot;Error monitoring $serviceName : $_&quot;    &#125;&#125;\n\n记住：Windows 服务管理需要谨慎操作，特别是在生产环境中，建议先在测试环境验证所有更改！\n","categories":["系统运维管理","Windows服务管理"],"tags":["Windows","服务管理","系统配置","服务器"]},{"title":"Linux atop 监控工具使用指南","url":"/posts/cf6de084/","content":"Linux atop 监控工具使用指南目录\n概述\n第一步：安装 atop\n第二步：安装 netatop 网络监控模块 (可选)\n第三步：配置 atop 服务\n第四步：使用 atop\n第五步：分析历史日志\n附录：监控字段说明\n常见问题\n\n概述atop 是一个高级的、可交互的 Linux 系统性能监控工具。与 top、htop 等工具相比，atop 最强大的特性是它能够记录历史性能数据，并允许你像播放视频一样“回放”系统在过去某个时间点的状态，极大地便利了问题排查和性能分析。\n主要特性\n全面监控: 监控 CPU、内存、交换空间、磁盘 I&#x2F;O、网络以及各个进程的资源使用情况。\n历史记录: 默认以10分钟为间隔，将系统快照记录到日志文件中，并保留28天。\n进程级详情: 记录每个进程的资源使用、状态、退出码等详细信息。\n高亮显示: 对过载的系统资源使用不同颜色高亮显示，一目了然。\n\n第一步：安装 atopUbuntu&#x2F;Debian# Linux atop 监控工具使用指南sudo apt update# Linux atop 监控工具使用指南sudo apt install -y atop# Linux atop 监控工具使用指南atop --version\n\nCentOS&#x2F;RHEL# Linux atop 监控工具使用指南sudo yum install -y epel-release# Linux atop 监控工具使用指南sudo yum install -y atop# Linux atop 监控工具使用指南# Linux atop 监控工具使用指南\n\n第二步：安装 netatop 网络监控模块 (可选)默认情况下，atop 只能显示系统总的网络流量。要查看每个进程的网络活动，你需要安装 netatop 内核模块。\n1. 安装依赖# Linux atop 监控工具使用指南sudo apt install -y build-essential zlib1g-dev linux-headers-$(uname -r)# Linux atop 监控工具使用指南sudo yum groupinstall -y &quot;Development Tools&quot;sudo yum install -y zlib-devel kernel-devel\n\n2. 下载和编译# Linux atop 监控工具使用指南mkdir -p ~/build/netatop &amp;&amp; cd ~/build/netatop# Linux atop 监控工具使用指南# Linux atop 监控工具使用指南wget https://www.atoptool.nl/download/netatop-3.1.tar.gz --no-check-certificate# Linux atop 监控工具使用指南tar -zxvf netatop-3.1.tar.gzcd netatop-3.1# Linux atop 监控工具使用指南sudo make &amp;&amp; sudo make install\n\n3. 加载模块并设为自启# Linux atop 监控工具使用指南sudo modprobe netatop# Linux atop 监控工具使用指南lsmod | grep netatop# Linux atop 监控工具使用指南echo &quot;netatop&quot; | sudo tee /etc/modules-load.d/netatop.conf# Linux atop 监控工具使用指南sudo systemctl start netatopsudo systemctl enable netatop\n\n第三步：配置 atop 服务atop 安装后会作为一个后台服务运行，定期记录系统快照。我们可以优化其配置。\n1. 编辑配置文件\nUbuntu&#x2F;Debian: /etc/default/atop\nCentOS&#x2F;RHEL: /etc/sysconfig/atop\n\n# Linux atop 监控工具使用指南sudo nano /etc/default/atop\n\n2. 修改核心参数找到以下行并修改为你需要的值。推荐配置如下：\n# Linux atop 监控工具使用指南LOGPATH=&quot;/var/log/atop&quot;# Linux atop 监控工具使用指南LOGINTERVAL=60# Linux atop 监控工具使用指南LOGGENERATIONS=14\n\n3. 重启服务修改配置后，重启 atop 服务使其生效。\nsudo systemctl restart atop\n\n第四步：使用 atop直接在终端中运行 atop 即可进入交互式监控界面。\n交互界面常用快捷键\ng: 默认视图，显示通用信息。\nm: 按内存使用率对进程排序。\nd: 按磁盘活动对进程排序。\nn: 按网络活动对进程排序 (需要 netatop 模块)。\nc: 显示进程的完整命令行。\nu: 按用户聚合资源使用情况。\np: 恢复到按进程聚合的默认视图。\nh 或 ?: 显示帮助信息。\nq: 退出。\n\n第五步：分析历史日志这是 atop 最强大的功能。\n1. 读取日志文件# Linux atop 监控工具使用指南atop -r# Linux atop 监控工具使用指南# Linux atop 监控工具使用指南atop -r /var/log/atop/atop_20240921# Linux atop 监控工具使用指南atop -r /var/log/atop/atop_$(date -d &quot;yesterday&quot; +%Y%m%d)\n\n2. 在历史记录中导航进入历史记录视图后，使用以下快捷键：\n\nt: 向未来跳转一个时间间隔（你在配置文件中设置的 LOGINTERVAL）。\nT: 向过去跳转一个时间间隔。\nb: （Begin）跳转到指定的时间点，例如输入 14:30。\n\n通过这些命令，你可以精确地“回放”到系统出现问题的时间点，查看当时的 CPU、内存、磁盘和网络状况，以及是哪个进程导致的问题。\n附录：监控字段说明\nPRC (Process): 进程总体状态，包括 sys (内核态) 和 user (用户态) 的 CPU 时间占比，以及运行、休眠、僵尸进程的数量。\nCPU: 系统总的 CPU 使用情况。wait 占比过高通常表示磁盘 I&#x2F;O 瓶颈。\nCPL (CPU Load): CPU 负载情况，包括1、5、15分钟的平均负载，以及上下文切换 (csw) 和中断 (intr) 次数。\nMEM: 物理内存使用情况，包括总量 (tot)、空闲 (free)、缓存 (cache) 和缓冲 (buff)。\nSWP: 交换空间（虚拟内存）的使用情况。\nDSK: 磁盘活动。busy 百分比显示了磁盘的繁忙程度。\nNET: 网络活动。顶层显示传输层（TCP&#x2F;UDP）的包统计，底层显示各个网络接口的流量。\n\n常见问题Q1: atop 无法启动，或提示 command not found?A: 确认 atop 已正确安装 (which atop)。如果已安装但无法运行，检查 PATH 环境变量。\nQ2: 网络监控 (n 快捷键) 不显示任何信息?A: netatop 内核模块没有被正确加载。请运行 lsmod | grep netatop 检查，如果无输出，请尝试手动加载 sudo modprobe netatop 并启动服务 sudo systemctl start netatop。\nQ3: 日志文件过大，占用太多磁盘空间?A: 编辑 atop 的配置文件（见第三步），减小 LOGGENERATIONS 的值（例如改为 7 天），或者增大 LOGINTERVAL 的值（例如 120 秒）。\n","categories":["系统运维管理","监控与诊断"],"tags":["Ubuntu","atop","系统监控","性能分析","Linux","netatop"]},{"title":"FileZilla 内网穿透配置指南","url":"/posts/2acf74bd/","content":"🛠️ 详细配置步骤1. 安装与配置FileZilla Server\n下载与安装在您的内网服务器上，从FileZilla官网下载FileZilla Server并安装。\n\n注意: 本指南基于 FileZilla Server 经典版本 (0.9.x) 的界面描述。如果您使用的是 1.x 或更高版本，管理界面可能有所不同（通常为基于Web的仪表板），但核心配置概念（用户、被动模式端口）是通用的。\n\n安装过程中，如果弹出“连接到服务器”配置界面，通常使用默认设置（如主机名127.0.0.1，管理端口）即可，点击“连接”或“确定”。\n\n创建用户与设置密码安装完成后，在FileZilla Server管理界面中：\n\n点击 Edit -&gt; Users 进入用户设置。\n在 General（通用）页面，点击 Add 按钮创建新用户（例如 user1）。\n为该用户设置密码。\n\n\n设置共享文件夹创建用户后，系统通常会提示需设置至少一个共享文件夹。\n\n在 Shared folders 页面，点击 Add 按钮，选择您希望外网能访问下载文件的内网目录。\n根据需要，在 Files 和 Directories 下为用户设置目录的读取（可下载）、写入、删除等权限。至少需要开启读取权限，才能允许文件下载。\n\n\n\n2. 配置花生壳内网穿透\n安装花生壳并添加映射在内网服务器下载、安装并登录花生壳客户端。\n在花生壳客户端的 内网穿透 页面，点击 + 按钮添加映射。\n应用名称：可自定义，如”FTP-Control”。\n应用类型：选择 TCP。\n内网主机IP：填写运行FileZilla Server的内网服务器IP地址（通常是192.168.x.x形式的地址）。注意：不要使用localhost或127.0.0.1。\n内网端口：填写FTP服务的控制端口，默认为 21。\n点击保存，花生壳会生成一个FTP控制通道的外网访问地址（包含域名和端口）。\n\n\n\n3. 配置FTP被动模式与数据传输端口FTP协议使用21端口建立控制连接，使用被动模式下的其他端口进行数据传输。因此，必须单独映射数据传输端口。\n\n在花生壳中映射数据端口按照上述同样方法，在花生壳中为FTP被动模式端口再添加一条映射：\n\n应用名称：可自定义，如”FTP-Data”。\n应用类型：TCP。\n内网主机IP：与上一步相同。\n内网端口：可任意填写一个未占用的端口号，例如 12345。\n保存后，花生壳会生成第二个外网访问地址，请记下这个新地址的外网端口号（例如 10418），下一步需要用到。\n\n添加映射后，可能需要编辑这条映射，将 内网端口 修改为与花生壳生成的 外网端口一致（例如将内网端口从12345改为10418），以确保数据通道正常传输。\n\n在FileZilla Server中设置被动模式现在需要在FileZilla Server中告知它使用这个映射好的端口。\n\n打开FileZilla Server，点击 Edit -&gt; Settings，进入 Passive mode settings (被动模式设置)。\n勾选 Use custom port range (使用自定义端口范围)。\n在输入框中，填写花生壳为数据通道生成的外网端口号（例如上一步的 10418）。如果只使用单个端口，起始和结束端口填相同的即可。\n关键步骤：在 Use the following IP 下方，可能需要填写花生壳生成的外网访问域名（即FTP控制通道的域名）。这能确保FTP服务器将正确的地址告知外网客户端。\n\n\n\n4. 设置Windows防火墙如果内网服务器的Windows防火墙已开启，需要放行FileZilla Server相关端口。\n\n在 Windows Defender 防火墙 中，添加入站规则。\n允许之前用到的端口（如控制端口21和您在花生壳设置的数据端口10418）的TCP连接。\n\n5. 外网连接测试在另一台外网电脑上，使用任何FTP客户端（如FileZilla Client）进行测试。\n\n主机&#x2F;地址：填写花生壳为控制通道生成的外网访问地址（域名和端口，例如 xxxx.vicp.cc:21 处的端口）。\n用户名与密码：填写您在FileZilla Server中设置的账号（如 user1）和密码。\n传输模式：在FTP客户端的站点设置中，传输模式请选择“被动模式”。\n连接成功后，您应该能看到内网共享的文件并可进行下载。\n\n💡 关键配置提醒与排查\n核心原理：成功的关键在于理解FTP需要两个通道（控制+数据），并正确配置被动模式及对应的端口映射。\n域名与IP：在FileZilla Server的被动模式设置中，”Use the following IP”处建议填写花生壳生成的域名，而非IP地址。\n防火墙：确保内网服务器的防火墙不会阻挡连接。\n花生壳版本：免费版花生壳通常支持添加2条映射，刚好满足FTP控制与数据通道的需求。如果数据端口不理想，可以删除映射后重新添加。\n\n","categories":["系统运维管理","Windows服务管理"],"tags":["Windows"]},{"title":"IO 事件分类概念","url":"/posts/ecdf807f/","content":"IO 事件分类概念\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: io, events, networking, system-programming, poll, epoll\n\n📑 目录\n1. 概述\n2. I&#x2F;O 事件类型\n2.1 网络I&#x2F;O事件\n2.2 文件I&#x2F;O事件\n2.3 设备I&#x2F;O事件\n2.4 定时器事件\n2.5 信号事件\n\n\n3. 网络编程中的I&#x2F;O事件\n4. 事件处理最佳实践\n\n\n1. 📖 概述在计算机系统中，I&#x2F;O（输入&#x2F;输出）事件是系统通知程序某个 I&#x2F;O 操作状态变化的机制。正确理解和分类这些事件对于高效的网络编程至关重要。\n\n2. 🔧 I&#x2F;O 事件类型2.1 🌐 网络I&#x2F;O事件网络编程中最常见的 I&#x2F;O 事件类型：\ngraph TD    A[网络I/O事件] --&gt; B[可读事件]    A --&gt; C[可写事件]    A --&gt; D[错误事件]    A --&gt; E[挂起事件]    B --&gt; B1[数据到达]    B --&gt; B2[新连接请求]    B --&gt; B3[对端关闭]    C --&gt; C1[缓冲区有空间]    C --&gt; C2[连接建立完成]    D --&gt; D1[连接异常]    D --&gt; D2[协议错误]    E --&gt; E1[对端主动关闭]    E --&gt; E2[连接断开]\n\n可读事件（Read Event）\n定义: 数据到达，可以读取\n场景:\n接收到网络数据\n新的连接请求（监听套接字）\n对端关闭连接（读取返回0）\n\n\n\n可写事件（Write Event）\n定义: 缓冲区有空间，可以写入数据\n场景:\n发送缓冲区有空间\n非阻塞连接建立完成\n\n\n\n错误事件（Error Event）\n定义: 连接出现错误\n场景:\n网络连接异常\n协议错误\n资源不足\n\n\n\n挂起事件（Hangup Event）\n定义: 连接被对端关闭\n场景:\n对端主动关闭连接\n连接断开\n\n\n\n2.2 📁 文件I&#x2F;O事件graph LR    A[文件I/O事件] --&gt; B[读写事件]    A --&gt; C[状态变化]    B --&gt; B1[文件可读]    B --&gt; B2[文件可写]    C --&gt; C1[文件修改]    C --&gt; C2[文件删除]    C --&gt; C3[权限变化]\n\n读写事件\n文件可读: 文件描述符可以进行读操作\n文件可写: 文件描述符可以进行写操作\n\n状态变化事件\n文件修改: 文件内容被修改\n文件删除: 文件被删除\n权限变化: 文件权限或所有者改变\n\n2.3 🔌 设备I&#x2F;O事件graph TD    A[设备I/O事件] --&gt; B[终端事件]    A --&gt; C[串口事件]    A --&gt; D[硬件设备事件]    B --&gt; B1[键盘输入]    B --&gt; B2[鼠标事件]    C --&gt; C1[串口数据到达]    C --&gt; C2[串口可发送]    D --&gt; D1[USB设备插拔]    D --&gt; D2[硬件状态变化]\n\n2.4 ⏰ 定时器事件graph LR    A[定时器事件] --&gt; B[超时事件]    B --&gt; B1[单次定时器]    B --&gt; B2[周期性定时器]    B --&gt; B3[相对定时器]    B --&gt; B4[绝对定时器]\n\n2.5 📢 信号事件graph TD    A[信号事件] --&gt; B[系统信号]    A --&gt; C[用户自定义信号]    B --&gt; B1[SIGTERM]    B --&gt; B2[SIGINT]    B --&gt; B3[SIGKILL]    B --&gt; B4[SIGUSR1]    B --&gt; B5[SIGUSR2]\n\n\n3. 🌐 网络编程中的I&#x2F;O事件3.1 📋 事件类型详解1. 可读事件（POLLIN&#x2F;POLLPRI）// 使用 poll 监听可读事件struct pollfd fds[1];fds[0].fd = sockfd;fds[0].events = POLLIN;  // 监听可读事件int ret = poll(fds, 1, timeout);if (fds[0].revents &amp; POLLIN) &#123;    // 处理可读事件    handle_read_event(sockfd);&#125;\n\n表示的情况:\n\n✅ 有新数据到达，可以读取\n✅ 新的连接请求到达（对于监听套接字）\n✅ 对端关闭连接（读取时会返回0）\n\n2. 可写事件（POLLOUT）// 监听可写事件struct pollfd fds[1];fds[0].fd = sockfd;fds[0].events = POLLOUT;  // 监听可写事件int ret = poll(fds, 1, timeout);if (fds[0].revents &amp; POLLOUT) &#123;    // 处理可写事件    handle_write_event(sockfd);&#125;\n\n表示的情况:\n\n✅ 发送缓冲区有空间\n✅ 连接建立完成（对于非阻塞连接）\n\n3. 错误事件（POLLERR）// 检查错误事件if (fds[0].revents &amp; POLLERR) &#123;    // 处理错误事件    handle_error_event(sockfd);&#125;\n\n表示的情况:\n\n❌ 连接异常\n❌ 协议错误\n❌ 网络不可达\n\n4. 挂起事件（POLLHUP）// 检查挂起事件if (fds[0].revents &amp; POLLHUP) &#123;    // 处理连接关闭    handle_hangup_event(sockfd);&#125;\n\n表示的情况:\n\n⚠️ 对端主动关闭连接\n⚠️ 连接断开\n\n5. 无效事件（POLLNVAL）// 检查无效事件if (fds[0].revents &amp; POLLNVAL) &#123;    // 处理无效文件描述符    handle_invalid_event(sockfd);&#125;\n\n表示的情况:\n\n❌ 文件描述符未打开或已关闭\n\n3.2 🔄 事件处理流程sequenceDiagram    participant App as 应用程序    participant Kernel as 内核    participant Network as 网络    App-&gt;&gt;Kernel: poll/epoll_wait    Kernel-&gt;&gt;Network: 监听事件    Network-&gt;&gt;Kernel: 事件发生    Kernel-&gt;&gt;App: 返回就绪事件    App-&gt;&gt;App: 处理事件    App-&gt;&gt;Kernel: 继续监听\n\n\n4. 💡 事件处理最佳实践4.1 🎯 事件处理策略// 事件处理的最佳实践示例void handle_events(struct pollfd *fds, int nfds) &#123;    for (int i = 0; i &lt; nfds; i++) &#123;        int fd = fds[i].fd;        short revents = fds[i].revents;        if (revents == 0) continue;  // 无事件        // 优先处理错误和挂起事件        if (revents &amp; POLLNVAL) &#123;            close(fd);            continue;        &#125;        if (revents &amp; POLLERR) &#123;            handle_socket_error(fd);            continue;        &#125;        if (revents &amp; POLLHUP) &#123;            handle_socket_hangup(fd);            continue;        &#125;        // 处理可读事件        if (revents &amp; POLLIN) &#123;            handle_read_event(fd);        &#125;        // 处理可写事件        if (revents &amp; POLLOUT) &#123;            handle_write_event(fd);        &#125;        // 处理紧急数据        if (revents &amp; POLLPRI) &#123;            handle_urgent_data(fd);        &#125;    &#125;&#125;\n\n4.2 ⚠️ 注意事项\n事件优先级: 错误事件 &gt; 挂起事件 &gt; 读写事件\n边缘触发: 使用 ET 模式时要确保处理完所有数据\n资源管理: 及时关闭无效的文件描述符\n性能优化: 避免不必要的事件监听\n\n4.3 🔧 常见问题解决\n\n\n问题\n原因\n解决方案\n\n\n\nCPU占用过高\n忙等待或事件处理不当\n使用阻塞I&#x2F;O或优化事件循环\n\n\n事件丢失\n边缘触发模式处理不完整\n使用水平触发或确保数据读完\n\n\n连接泄漏\n错误事件处理不当\n及时清理和关闭连接\n\n\n\n📊 总结✅ 核心要点\nI&#x2F;O事件分类: 网络、文件、设备、定时器、信号\n网络事件处理: 可读、可写、错误、挂起、无效\n最佳实践: 事件优先级、资源管理、性能优化\n\n🎯 实际应用\nWeb服务器: 处理HTTP请求和响应\n代理服务器: 转发客户端和服务器数据\n聊天应用: 实时消息传输\n文件监控: 监控文件系统变化\n\n📚 扩展学习\nLinux I&#x2F;O 多路复用\nepoll 编程指南\n高性能网络编程\n\n\n\n💡 提示: 在实际开发中，建议使用成熟的网络库（如 libevent、libuv）来处理复杂的事件管理，这些库已经处理了大部分边界情况和优化。\n\n","categories":["系统级编程"],"tags":["技术文档","指南"]},{"title":"Drogon Windows 构建指南","url":"/posts/58c0a1f/","content":"Drogon Windows 构建指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: drogon, cpp, windows, source-build, cmake, conan\n\n📑 目录\n1. 概述\n2. 环境准备\n3. 源码下载\n4. 依赖安装\n5. 编译安装\n6. 环境配置\n7. 创建新项目\n8. 常见问题\n\n\n1. 📖 概述Drogon 是一个现代化的 C++ Web 框架。本指南介绍如何在 Windows 系统上从源码编译安装 Drogon。\n🎯 安装目标\n✅ 从源码编译 Drogon 框架\n✅ 配置开发环境\n✅ 创建第一个 Drogon 项目\n✅ 验证安装成功\n\n\n2. 🔧 环境准备2.1 必需工具\nVisual Studio 2019+ - C++ 编译器\nGit - 源码管理\nCMake 3.15+ - 构建系统\nConan - C++ 包管理器\n\n2.2 安装 Conan# Drogon Windows 构建指南pip install conan# Drogon Windows 构建指南choco install conan\n\n\n3. 📥 源码下载# Drogon Windows 构建指南cd %WORK_PATH%# Drogon Windows 构建指南git clone https://github.com/drogonframework/drogoncd drogon# Drogon Windows 构建指南git submodule update --init\n\n\n4. 📦 依赖安装# Drogon Windows 构建指南mkdir buildcd build# Drogon Windows 构建指南conan profile detect --force# Drogon Windows 构建指南conan install .. \\    -s compiler=&quot;msvc&quot; \\    -s compiler.version=194 \\    -s compiler.cppstd=17 \\    -s build_type=Debug \\    --output-folder . \\    --build=missing\n\n4.1 自定义依赖编辑 conanfile.txt 可以添加或修改依赖：\n[requires]# Drogon Windows 构建指南[generators]CMakeDepsCMakeToolchain[options]shared=False\n\n\n5. 🔨 编译安装# Drogon Windows 构建指南cmake .. \\    -DCMAKE_BUILD_TYPE=Debug \\    -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; \\    -DCMAKE_POLICY_DEFAULT_CMP0091=NEW \\    -DCMAKE_INSTALL_PREFIX=&quot;D:\\ThirdParty\\drogon&quot;# Drogon Windows 构建指南cmake --build . --parallel --target install\n\n5.1 ⚠️ 重要说明\nConan 和 CMake 的 build type 必须保持一致\nRelease 构建时将 Debug 改为 Release\n可根据需要修改安装路径\n\n\n6. 🔗 环境配置6.1 安装结果编译完成后，以下文件将被安装到指定目录：\n\n\n\n文件类型\n安装路径\n说明\n\n\n\n头文件\nD:\\ThirdParty\\drogon\\include\\drogon\nDrogon 主要头文件\n\n\n库文件\nD:\\ThirdParty\\drogon\\bin\ndrogon.dll\n\n\n命令工具\nD:\\ThirdParty\\drogon\\bin\ndrogon_ctl.exe\n\n\nTrantor头文件\nD:\\ThirdParty\\drogon\\include\\trantor\n依赖库头文件\n\n\nTrantor库文件\nD:\\ThirdParty\\drogon\\bin\ntrantor.dll\n\n\n6.2 环境变量添加以下路径到系统 PATH 环境变量：\nD:\\ThirdParty\\drogon\\binD:\\ThirdParty\\drogon\\lib\\cmake\\DrogonD:\\ThirdParty\\drogon\\lib\\cmake\\Trantor\n\n\n7. 🚀 创建新项目7.1 使用命令行工具# Drogon Windows 构建指南drogon_ctl create project your_project_name# Drogon Windows 构建指南copy drogon\\conanfile.txt your_project_name\\# Drogon Windows 构建指南cd your_project_name# Drogon Windows 构建指南mkdir buildcd buildconan profile detect --forceconan install .. \\    -s compiler=&quot;msvc&quot; \\    -s compiler.version=194 \\    -s compiler.cppstd=17 \\    -s build_type=Debug \\    --output-folder . \\    --build=missingcmake .. \\    -DCMAKE_BUILD_TYPE=Debug \\    -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; \\    -DCMAKE_POLICY_DEFAULT_CMP0091=NEWcmake --build . --parallel\n\n7.2 项目结构your_project_name/├── build/├── config.json├── CMakeLists.txt├── conanfile.txt├── main.cc├── plugins/├── run.bat└── tests/\n\n\n8. 🔧 常见问题8.1 编译错误\nVS 版本不匹配: 确认 compiler.version 与安装的 Visual Studio 版本一致\nC++ 标准问题: 确保 compiler.cppstd 设置正确\n依赖缺失: 使用 --build=missing 强制构建缺失的依赖\n\n8.2 链接错误\nDLL 找不到: 检查 PATH 环境变量设置\n库文件路径: 确认 CMAKE_PREFIX_PATH 设置正确\n\n8.3 运行时错误\n配置文件: 检查 config.json 配置是否正确\n端口占用: 确认配置的端口未被占用\n\n\n📚 相关资源\nDrogon 官方文档\nConan 包管理器\nCMake 官方文档\n\n\n\n💡 提示:\n\n首次编译可能需要较长时间\n建议使用 Release 模式进行生产构建\n定期更新 Drogon 源码以获得最新功能\n\n\n","categories":["框架库"],"tags":["技术文档","指南"]},{"title":"GDB 调试工具完整使用指南","url":"/posts/b33ae3e9/","content":"GDB (GNU Debugger) 调试指南目录\n编译调试版本\n启动 GDB\n断点\n执行控制\n查看数据\n高级技巧\n常见问题\n\n编译调试版本为了让 GDB 能够获取足够的信息，你必须在编译时加入 -g 参数。为了获得最佳调试体验，建议关闭优化 (-O0) 并开启所有警告。\n# 使用 -g 参数生成调试信息g++ -g -o my_app my_app.cpp# 推荐的调试编译选项g++ -g -O0 -Wall -Wextra -o my_app my_app.cpp# CMake 构建系统的调试模式cmake -DCMAKE_BUILD_TYPE=Debug .make# 禁用某些优化但保留调试信息g++ -g -O1 -fno-omit-frame-pointer -o my_app my_app.cpp\n\n启动 GDB# 1. 调试可执行文件gdb ./my_app# 2. 附加到正在运行的进程 (需要进程ID)gdb -p &lt;pid&gt;# 3. 调试程序崩溃产生的核心转储文件 (core dump)gdb ./my_app core.&lt;pid&gt;# 4. 使用参数启动程序gdb --args ./my_app arg1 arg2# 5. 在 GDB 中设置程序的参数(gdb) set args arg1 arg2\n\n断点 (Breakpoints)设置断点# 在函数入口设置断点break function_nameb main# 在指定文件的指定行号设置断点break file.cpp:42b 42# 设置条件断点 (当 a &gt; 10 时触发)break 42 if a &gt; 10b file.cpp:50 if count == 0# 设置临时断点 (命中后自动删除)tbreak function_name# 在内存地址设置断点break *0x400500\n\n管理断点# 查看所有断点info breakpointsinfo b# 禁用断点 (num 为断点编号)disable &lt;num&gt;# 启用断点enable &lt;num&gt;# 删除断点delete &lt;num&gt;d &lt;num&gt;# 清除所有断点deleteclear# 清除指定行的断点clear 42clear function_name\n\n执行控制# 运行程序 (可跟参数)run [args]r# 继续执行直到下一个断点continuec# 单步执行，会进入函数内部steps# 单步执行，不会进入函数内部nextn# 执行到当前函数返回finish# 执行到当前循环结束until# 继续执行直到当前函数返回（与 finish 类似）return [expression]# 重新开始执行程序restart# 退出 GDBquitq\n\n查看数据查看代码与调用栈# 显示当前位置附近的源代码listl# 显示指定函数或行的源代码list function_namelist file.cpp:42# 查看当前函数的调用栈帧信息info frame# 查看完整的函数调用栈backtracebt# 限制显示的栈帧数量backtrace 10bt 10# 查看 N 个栈帧的详细信息backtrace fullbt full\n\n查看变量与内存# 打印变量/表达式的值print variablep i * 2# 以特定格式打印 (x:十六进制, d:十进制, t:二进制, c:字符)p/x variable# 查看变量类型ptype variable# 查看当前栈帧的局部变量info locals# 查看当前函数的参数info args# 检查内存地址 (x: examine)# 格式: x/[N][F][U] address# N: 显示数量, F: 格式, U: 单位大小 (b:字节, h:半字, w:字, g:双字)x/16xw 0x7fffffffe3c0  # 从地址开始，以16进制格式显示16个字(word)# 更多 examine 格式示例x/10xb 0x7fffffffe3c0      # 显示10个字节，16进制x/20i 0x400500              # 显示20条指令，汇编格式x/4xg &amp;main                 # 以16进制显示4个8字节组(&amp;main地址)# 查看数组内容p *array@len                 # 显示数组array的前len个元素p *(int(*)[10])ptr           # 将ptr转换为int[10]指针并查看# 查看寄存器值info registersinfo r# 设置变量值set variable = 100set i = i + 1\n\n高级技巧文本用户界面 (TUI) 模式TUI 模式可以在一个窗口内同时显示源代码、汇编和 GDB 命令，非常方便。\n# 启动时进入 TUI 模式gdb -tui ./my_app# 在 GDB 内部切换 TUI 模式# 按下 Ctrl + x, 然后再按 a\nTUI 模式下常用快捷键：\n\nCtrl + x, 2: 切换焦点到下一个窗口\n上/下箭头: 滚动当前窗口内容\n\n观察点 (Watchpoints)当一个变量被读取或写入时，程序会暂停。\n# 变量被写入时暂停watch my_var# 变量被读取时暂停rwatch my_var# 变量被读取或写入时暂停awatch my_var\n\n多线程调试# 查看所有线程info threads# 切换到指定线程 (num 为线程编号)thread &lt;num&gt;# 对所有线程执行同一个命令thread apply all bt  # 查看所有线程的调用栈thread apply all backtrace full  # 详细信息# 应用命令到指定线程thread apply 3-5 bt  # 对线程3到5执行bt# 查看线程锁定信息info lock\n\n异常处理# 捕获 C++ 异常catch throwcatch catch# 捕获信号catch signal SIGSEGVcatch signal SIGINT# 忽略信号handle SIGUSR1 nostop noprint pass# 查看信号处理设置info signals\n\n宏调试# 展开宏macro expand MACRO_NAME# 显示宏定义info macro MACRO_NAME# 查看所有宏定义info macros\n\n其他高级功能# 查看共享库信息info sharedlibrary# 加载符号symbol-file /path/to/library.so# 设置打印数组的最大元素数set print elements 100# 设置打印字符串的最大长度set print null-stopset print elements 0  # 无限制# 自动显示表达式的值display variabledisplay *ptr# 查看所有显示的表达式info display# 取消显示undisplay &lt;num&gt;\n\n常见问题Q1: 如何调试段错误 (Segmentation Fault)?A: 首先，开启 core dump 生成。\n# 允许生成无限大的 core dump 文件ulimit -c unlimited\n然后正常运行你的程序，当它崩溃时，会在当前目录生成一个 core 文件。最后使用 GDB 加载它进行分析。\n# 进入 GDB 后，立即使用 backtrace 查看崩溃时的调用栈(gdb) bt\n\nQ2: 如何使用 Valgrind 进行内存泄漏检测?A: Valgrind 是一个独立的工具，应在 Shell 中使用，而不是在 GDB 内部。它会运行你的程序并监控内存使用。\n# --leak-check=full 提供最详细的泄漏报告valgrind --leak-check=full ./my_app\n\nQ3: 如何调试多进程程序 (fork)?A: 默认情况下，GDB 会继续调试父进程，而子进程会正常运行。你可以修改这个行为。\n# 设置 GDB 在 fork 后调试子进程set follow-fork-mode child# (可选) 设置 GDB 同时调试父子进程，需要 GDB 7.0+set detach-on-fork off\n\nQ4: 如何调试动态链接库中的问题?A: 使用以下方法：\n# 加载共享库的调试符号(gdb) symbol-file /usr/lib/debug/libfoo.so# 设置断点到共享库函数(gdb) break shared_function# 查看动态链接信息(gdb) info sharedlibrary\n\nQ5: GDB 显示 “No symbol table is loaded” 怎么办?A: 这是因为编译时没有包含调试信息。\n\n确保使用 -g 参数编译：\ng++ -g program.cpp -o program\n\n对于已编译的程序，检查是否有调试信息：\n\n\nfile program  # 查看是否包含调试信息objdump -h program | grep .debug  # 查看调试段\n\n\n重新编译程序包含调试信息。\n\nQ6: 如何查看 STL 容器的内容?A: 使用 Pretty Printers（需要 GDB 7.0+ 和 Python 支持）：\n# 启用 pretty printing(gdb) set print pretty on# 查看 vector(gdb) p my_vector# 查看 map(gdb) p my_map# 查看 string(gdb) p my_string\n\nQ7: 如何在 GDB 中执行 shell 命令?A: 使用 shell 命令：\n(gdb) shell ls -la(gdb) shell ps aux | grep my_program(gdb) shell cat /proc/$(pidof my_program)/status\n\n\n","categories":["开发工具与流程","调试工具"],"tags":["C++","GDB","调试","开发工具"]},{"title":"Drogon 编译指南","url":"/posts/b47a5d97/","content":"Drogon 编译指南目录\n概述\n系统要求\n环境准备\n下载源码\n依赖管理\n编译安装\n配置环境变量\n验证安装\n项目配置\n常见问题\n最佳实践\n\n概述Drogon 是一个基于 C++17&#x2F;20 的高性能 HTTP 应用框架，类似于 Python 的 Django 和 Flask。本指南详细介绍如何在 Windows 系统下从源码编译安装 Drogon 框架。\n框架特性\n高性能: 基于 non-blocking I&#x2F;O 和事件驱动\n异步支持: 完整的异步编程模型\nORM支持: 内置对象关系映射\n插件系统: 灵活的插件扩展机制\nRESTful API: 天然支持 RESTful 风格\nWebSocket: 内置 WebSocket 支持\n跨平台: 支持 Windows、Linux、macOS\n\n编译方式\n源码编译: 完全控制编译选项和依赖\n包管理器: 使用 vcpkg 或 Conan 管理依赖\n预编译包: 使用官方预编译的二进制包\n\n系统要求1. 硬件要求\nCPU: x64 架构，推荐 4 核心以上\n内存: 最少 8GB，推荐 16GB+\n磁盘空间: 最少 10GB，推荐 20GB+\n\n2. 软件要求\n操作系统: Windows 10&#x2F;11 (64位)\nVisual Studio: 2019 或 2022\nCMake: 3.15+\nPython: 3.7+ (用于 Conan 包管理器)\nGit: 最新版本\n\n3. 开发工具\nVisual Studio: 完整的 C++ 开发环境\nCMake: 跨平台构建工具\nConan: C++ 包管理器\nGit: 版本控制工具\n\n环境准备1. 安装 Visual Studio1.1 下载安装访问 https://visualstudio.microsoft.com/downloads/ 下载 Visual Studio 2022\n1.2 工作负载选择安装时选择以下工作负载：\n\n使用 C++ 的桌面开发\nMSVC v143 编译器工具集\nWindows 10&#x2F;11 SDK\nC++ CMake 工具\n\n\n\n1.3 验证安装# Drogon 编译指南# Drogon 编译指南cl# Drogon 编译指南# Drogon 编译指南link# Drogon 编译指南\n\n2. 安装 CMake2.1 下载安装访问 https://cmake.org/download/ 下载 CMake\n2.2 安装配置\n选择 “Add CMake to the system PATH”\n完成安装\n\n2.3 验证安装cmake --version# Drogon 编译指南\n\n3. 安装 Python 和 pip3.1 下载安装 Python访问 https://python.org/downloads/ 下载 Python 3.9+\n3.2 配置 pip 源（国内加速）# Drogon 编译指南pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple# Drogon 编译指南pip config list\n\n4. 安装 Conan4.1 安装 Conan# Drogon 编译指南pip install conan# Drogon 编译指南conan --version# Drogon 编译指南\n\n4.2 配置 Conan# Drogon 编译指南conan profile detect --force# Drogon 编译指南conan profile show default\n\n5. 安装 Git5.1 下载安装访问 https://git-scm.com/download/win 下载 Git\n5.2 验证安装git --version# Drogon 编译指南\n\n下载源码1. 设置工作目录1.1 创建工作目录# Drogon 编译指南mkdir D:\\drogoncd D:\\drogon# Drogon 编译指南set WORK_PATH=D:\\drogoncd %WORK_PATH%\n\n1.2 克隆 Drogon 源码# Drogon 编译指南git clone https://github.com/drogonframework/drogoncd drogon# Drogon 编译指南git branch -agit tag -l# Drogon 编译指南git checkout v1.8.4\n\n2. 更新子模块2.1 初始化子模块# Drogon 编译指南git submodule update --init --recursive# Drogon 编译指南git clone --recursive https://github.com/drogonframework/drogon\n\n2.2 验证子模块# Drogon 编译指南git submodule status# Drogon 编译指南\n\n依赖管理1. Conan 依赖管理1.1 创建构建目录# Drogon 编译指南mkdir buildcd build\n\n1.2 安装依赖库# Drogon 编译指南conan profile detect --force# Drogon 编译指南conan install .. ^  -s compiler=&quot;msvc&quot; ^  -s compiler.version=193 ^  -s compiler.cppstd=17 ^  -s build_type=Debug ^  --output-folder=. ^  --build=missing# Drogon 编译指南conan install .. ^  -s compiler=&quot;msvc&quot; ^  -s compiler.version=193 ^  -s compiler.cppstd=17 ^  -s build_type=Release ^  --output-folder=. ^  --build=missing\n\n1.3 Conan 配置说明\ncompiler&#x3D;”msvc”: 使用 Microsoft Visual C++ 编译器\ncompiler.version&#x3D;193: VS2022 编译器版本（193对应VS2022）\ncompiler.cppstd&#x3D;17: C++17 标准\nbuild_type&#x3D;Debug&#x2F;Release: 构建类型\n–build&#x3D;missing: 自动构建缺失的依赖\n–output-folder&#x3D;.: 输出到当前目录\n\n1.4 编辑 conanfile.txt# Drogon 编译指南[requires]# Drogon 编译指南# Drogon 编译指南# Drogon 编译指南[generators]cmakecmake_find_package[options]# Drogon 编译指南# Drogon 编译指南\n\n2. vcpkg 依赖管理（可选）2.1 安装 vcpkg# Drogon 编译指南git clone https://github.com/microsoft/vcpkg.gitcd vcpkg.\\bootstrap-vcpkg.bat# Drogon 编译指南.\\vcpkg install drogon:x64-windows\n\n2.2 配置 CMake 使用 vcpkgcmake .. -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake\n\n编译安装1. 基础编译1.1 仅编译（不安装）# Drogon 编译指南cmake .. ^  -DCMAKE_BUILD_TYPE=Debug ^  -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; ^  -DCMAKE_POLICY_DEFAULT_CMP0091=NEW# Drogon 编译指南cmake --build . --parallel\n\n1.2 编译参数说明\nCMAKE_BUILD_TYPE: Debug&#x2F;Release&#x2F;RelWithDebInfo&#x2F;MinSizeRel\nCMAKE_TOOLCHAIN_FILE: Conan 生成的工具链文件\nCMAKE_POLICY_DEFAULT_CMP0091&#x3D;NEW: 处理 MSVC 运行时库策略\n\n2. 完整编译并安装2.1 设置安装路径# Drogon 编译指南set INSTALL_PREFIX=D:\\Development\\drogon# Drogon 编译指南cmake .. ^  -DCMAKE_BUILD_TYPE=Debug ^  -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; ^  -DCMAKE_POLICY_DEFAULT_CMP0091=NEW ^  -DCMAKE_INSTALL_PREFIX=&quot;%INSTALL_PREFIX%&quot;\n\n2.2 编译并安装# Drogon 编译指南cmake --build . --parallel --target install# Drogon 编译指南cmake --build . --config Debug --target install\n\n3. 多版本编译3.1 Debug 和 Release 版本# Drogon 编译指南mkdir build-debug build-release# Drogon 编译指南cd build-debugconan install .. -s build_type=Debug --output-folder=. --build=missingcmake .. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; -DCMAKE_INSTALL_PREFIX=&quot;D:/Development/drogon/debug&quot;cmake --build . --parallel --target install# Drogon 编译指南cd ../build-releaseconan install .. -s build_type=Release --output-folder=. --build=missingcmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; -DCMAKE_INSTALL_PREFIX=&quot;D:/Development/drogon/release&quot;cmake --build . --parallel --target install\n\n3.2 静态库和动态库# Drogon 编译指南cmake .. -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX=&quot;D:/Development/drogon/static&quot;# Drogon 编译指南cmake .. -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=&quot;D:/Development/drogon/shared&quot;\n\n安装结果1. 安装的文件结构1.1 默认安装结构D:\\Development\\drogon\\├── include\\                 # 头文件│   ├── drogon\\              # Drogon 主框架头文件│   └── trantor\\             # Trantor 网络库头文件├── bin\\                     # 可执行文件和动态库│   ├── drogon.dll           # Drogon 主库│   ├── trantor.dll          # Trantor 网络库│   └── drogon_ctl.exe       # 命令行工具├── lib\\                     # 静态库│   ├── drogon.lib           # Drogon 静态库│   └── trantor.lib          # Trantor 静态库└── lib\\cmake\\               # CMake 配置文件    ├── Drogon\\              # Drogon CMake 配置    └── Trantor\\             # Trantor CMake 配置\n\n1.2 关键文件说明\ndrogon.dll: Drogon 主库动态链接库\ntrantor.dll: Trantor 网络库动态链接库\ndrogon_ctl.exe: Drogon 命令行工具\ndrogon.lib: Drogon 静态链接库\ntrantor.lib: Trantor 静态链接库\n\n2. 环境变量配置2.1 添加到 PATH# Drogon 编译指南set PATH=%PATH%;D:\\Development\\drogon\\bin# Drogon 编译指南setx PATH &quot;%PATH%;D:\\Development\\drogon\\bin&quot;setx DROGON_ROOT &quot;D:\\Development\\drogon&quot;\n\n2.2 添加 CMake 路径# Drogon 编译指南setx CMAKE_PREFIX_PATH &quot;%CMAKE_PREFIX_PATH%;D:\\Development\\drogon\\lib\\cmake&quot;\n\n2.3 系统环境变量设置\n按 Win + R，输入 sysdm.cpl\n选择”高级”选项卡\n点击”环境变量”\n在”系统变量”中添加：\nDROGON_ROOT: D:\\Development\\drogon\nPATH: 添加 %DROGON_ROOT%\\bin\n\n\n\n验证安装1. 基本验证1.1 检查安装文件# Drogon 编译指南dir D:\\Development\\drogon\\include\\drogon# Drogon 编译指南dir D:\\Development\\drogon\\bin\\*.dlldir D:\\Development\\drogon\\lib\\*.lib# Drogon 编译指南dir D:\\Development\\drogon\\bin\\drogon_ctl.exe\n\n1.2 测试命令行工具# Drogon 编译指南drogon_ctl --versiondrogon_ctl --help# Drogon 编译指南drogon_ctl create project test_projectcd test_project\n\n2. 编译测试项目2.1 创建测试项目# Drogon 编译指南drogon_ctl create project hello_drogoncd hello_drogon# Drogon 编译指南mkdir buildcd buildcmake .. -DCMAKE_PREFIX_PATH=D:\\Development\\drogoncmake --build . --config Debug\n\n2.2 运行测试项目# Drogon 编译指南Debug\\hello_drogon.exe# Drogon 编译指南# Drogon 编译指南# Drogon 编译指南\n\n2.3 测试 HTTP 请求# Drogon 编译指南curl http://localhost:8080# Drogon 编译指南# Drogon 编译指南\n\n项目配置1. CMake 项目配置1.1 基本项目配置cmake_minimum_required(VERSION 3.15)project(MyDrogonApp)# Drogon 编译指南set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)# Drogon 编译指南find_package(Drogon REQUIRED)# Drogon 编译指南add_executable(my_app main.cc)# Drogon 编译指南target_link_libraries(my_app Drogon::Drogon)\n\n1.2 完整项目配置cmake_minimum_required(VERSION 3.15)project(MyDrogonApp)# Drogon 编译指南set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)# Drogon 编译指南set(DROGON_ROOT &quot;D:/Development/drogon&quot;)set(CMAKE_PREFIX_PATH $&#123;CMAKE_PREFIX_PATH&#125; $&#123;DROGON_ROOT&#125;)# Drogon 编译指南find_package(Drogon REQUIRED)# Drogon 编译指南add_executable(my_app    src/main.cc    src/controllers/HomeController.cc    src/models/User.cc)# Drogon 编译指南target_include_directories(my_app PRIVATE    $&#123;DROGON_ROOT&#125;/include)# Drogon 编译指南target_link_libraries(my_app Drogon::Drogon)# Drogon 编译指南if(WIN32)    add_custom_command(TARGET my_app POST_BUILD        COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different        $&#123;DROGON_ROOT&#125;/bin/drogon.dll        $&#123;DROGON_ROOT&#125;/bin/trantor.dll        $&lt;TARGET_FILE_DIR:my_app&gt;    )endif()\n\n2. Visual Studio 项目配置2.1 项目属性设置\n右键项目 → 属性\n配置属性 → C&#x2F;C++ → 常规\n附加包含目录: D:\\Development\\drogon\\include\n\n\n配置属性 → 链接器 → 常规\n附加库目录: D:\\Development\\drogon\\lib\n\n\n配置属性 → 链接器 → 输入\n附加依赖项: drogon.lib;trantor.lib;\n\n\n\n2.2 环境变量设置# Drogon 编译指南set DROGON_ROOT=D:\\Development\\drogonset PATH=%PATH%;%DROGON_ROOT%\\bin\n\n3. 代码示例3.1 简单的 HTTP 服务器// main.cc#include &lt;drogon/drogon.h&gt;using namespace drogon;int main() &#123;    app().setLogPath(&quot;./&quot;)        .setLogLevel(trantor::Logger::kWarn)        .addListener(&quot;0.0.0.0&quot;, 8080)        .setThreadNum(16);    // 添加路由    app().registerHandler(        &quot;/&quot;,        [](const HttpRequestPtr &amp;req,           std::function&lt;void(const HttpResponsePtr &amp;)&gt; &amp;&amp;callback) &#123;            auto resp = HttpResponse::newHttpResponse();            resp-&gt;setBody(&quot;Hello, Drogon!&quot;);            resp-&gt;setContentTypeCode(CT_TEXT_HTML);            callback(resp);        &#125;,        &#123;Get&#125;    );    LOG_INFO &lt;&lt; &quot;Server running on port 8080&quot;;    app().run();    return 0;&#125;\n\n3.2 控制器示例// controllers/HomeController.h#pragma once#include &lt;drogon/HttpController.h&gt;using namespace drogon;namespace api &#123;class HomeController : public HttpController&lt;HomeController&gt; &#123;public:    METHOD_LIST_BEGIN    METHOD_ADD(HomeController::index, &quot;/&quot;, Get);    METHOD_ADD(HomeController::hello, &quot;/hello&quot;, Get);    METHOD_LIST_END    void index(const HttpRequestPtr &amp;req,               std::function&lt;void(const HttpResponsePtr &amp;)&gt; &amp;&amp;callback);    void hello(const HttpRequestPtr &amp;req,               std::function&lt;void(const HttpResponsePtr &amp;)&gt; &amp;&amp;callback,               const std::string &amp;name);&#125;;&#125;\n\n// controllers/HomeController.cc#include &quot;HomeController.h&quot;#include &lt;drogon/HttpResponse.h&gt;using namespace drogon;using namespace api;void HomeController::index(const HttpRequestPtr &amp;req,                          std::function&lt;void(const HttpResponsePtr &amp;)&gt; &amp;&amp;callback) &#123;    auto resp = HttpResponse::newHttpResponse();    resp-&gt;setBody(&quot;&lt;h1&gt;Welcome to Drogon!&lt;/h1&gt;&quot;);    resp-&gt;setContentTypeCode(CT_TEXT_HTML);    callback(resp);&#125;void HomeController::hello(const HttpRequestPtr &amp;req,                           std::function&lt;void(const HttpResponsePtr &amp;)&gt; &amp;&amp;callback,                           const std::string &amp;name) &#123;    Json::Value ret;    ret[&quot;message&quot;] = &quot;Hello, &quot; + name + &quot;!&quot;;    auto resp = HttpResponse::newHttpJsonResponse(ret);    callback(resp);&#125;\n\n常见问题Q1: 编译器版本不匹配问题: 提示 “MSVC version not supported” 或编译器版本错误\n解决方案:\n# Drogon 编译指南cl# Drogon 编译指南# Drogon 编译指南conan profile update settings.compiler.version=192 default  # VS2019conan profile update settings.compiler.version=193 default  # VS2022\n\nQ2: CMake 配置错误问题: CMake 找不到 Conan 生成的工具链文件\n解决方案:\n# Drogon 编译指南dir conan_toolchain.cmake# Drogon 编译指南conan install .. --output-folder=. --build=missing# Drogon 编译指南cmake .. -DCMAKE_TOOLCHAIN_FILE=&quot;%CD%\\conan_toolchain.cmake&quot;\n\nQ3: 依赖库缺失问题: 编译时提示找不到某些库文件\n解决方案:\n# Drogon 编译指南conan install .. --build=missing# Drogon 编译指南# Drogon 编译指南[requires]openssl/1.1.1qzlib/1.2.11\n\nQ4: 链接错误问题: 链接时提示 “unresolved external symbol”\n解决方案:\n# Drogon 编译指南cmake .. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot;# Drogon 编译指南rm -rf *conan install .. --output-folder=. --build=missingcmake .. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot;cmake --build . --config Debug --target install\n\nQ5: 运行时错误问题: 程序运行时提示 “找不到 drogon.dll”\n解决方案:\n# Drogon 编译指南echo %PATH%# Drogon 编译指南copy D:\\Development\\drogon\\bin\\*.dll .\\# Drogon 编译指南set PATH=%PATH%;D:\\Development\\drogon\\bin\n\nQ6: Python 和 pip 问题问题: pip 安装 Conan 失败或速度慢\n解决方案:\n# Drogon 编译指南python -m pip install --upgrade pip# Drogon 编译指南pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple# Drogon 编译指南pip config list\n\n最佳实践1. 开发环境配置1.1 自动化脚本@echo offREM install_drogon.batsetlocalset WORK_DIR=D:\\Development\\drogonset BUILD_TYPE=Debugecho Installing Drogon...echo 1. Creating directories...mkdir &quot;%WORK_DIR%&quot; 2&gt;nulcd &quot;%WORK_DIR%&quot;echo 2. Cloning source code...if not exist &quot;drogon&quot; (    git clone https://github.com/drogonframework/drogon    cd drogon    git submodule update --init --recursive) else (    cd drogon)echo 3. Installing dependencies...mkdir build 2&gt;nulcd buildconan profile detect --forceconan install .. -s build_type=%BUILD_TYPE% --output-folder=. --build=missingecho 4. Building and installing...cmake .. -DCMAKE_BUILD_TYPE=%BUILD_TYPE% -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; -DCMAKE_INSTALL_PREFIX=&quot;%WORK_DIR%&quot;cmake --build . --parallel --target installecho 5. Setting environment variables...setx DROGON_ROOT &quot;%WORK_DIR%&quot;setx PATH &quot;%PATH%;%WORK_DIR%\\bin&quot;echo Installation completed successfully!endlocal\n\n1.2 开发环境检查@echo offREM check_env.batecho Checking Drogon development environment...echo 1. Checking Visual Studio...cl &gt;nul 2&gt;&amp;1if %errorlevel% equ 0 (    echo Visual Studio: OK) else (    echo Visual Studio: NOT FOUND    echo Please run this script from Visual Studio Developer Command Prompt    exit /b 1)echo 2. Checking CMake...cmake --version &gt;nul 2&gt;&amp;1if %errorlevel% equ 0 (    echo CMake: OK) else (    echo CMake: NOT FOUND    exit /b 1)echo 3. Checking Conan...conan --version &gt;nul 2&gt;&amp;1if %errorlevel% equ 0 (    echo Conan: OK) else (    echo Conan: NOT FOUND    echo Run: pip install conan    exit /b 1)echo 4. Checking Drogon installation...if exist &quot;%DROGON_ROOT%\\bin\\drogon_ctl.exe&quot; (    echo Drogon: OK    drogon_ctl --version) else (    echo Drogon: NOT FOUND    echo Please run install_drogon.bat first    exit /b 1)echo All checks passed!\n\n2. 项目管理2.1 版本管理# Drogon 编译指南git clone https://github.com/drogonframework/drogoncd drogongit checkout v1.8.4  # 切换到稳定版本git submodule update --init --recursive\n\n2.2 多项目配置# Drogon 编译指南set(DROGON_ROOT &quot;D:/Work/Development/Projects/ThirdParty/drogon&quot;)set(CMAKE_PREFIX_PATH $&#123;CMAKE_PREFIX_PATH&#125; $&#123;DROGON_ROOT&#125;)find_package(Drogon REQUIRED)message(STATUS &quot;Found Drogon: $&#123;Drogon_VERSION&#125;&quot;)\n\n3. 性能优化3.1 编译优化# Drogon 编译指南conan install .. -s build_type=Release --output-folder=. --build=missingcmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot;cmake --build . --config Release --target install# Drogon 编译指南cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=&quot;conan_toolchain.cmake&quot; -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=ON\n\n3.2 运行时优化// 在应用启动时配置app().setThreadNum(std::thread::hardware_concurrency())  // 使用所有CPU核心     .setIoLoopNum(4)                                   // 设置I/O循环数量     .setUseGzip(true)                                 // 启用Gzip压缩     .setMaxConnectionNum(10000)                      // 最大连接数     .setIdleConnectionTimeout(60);                   // 空闲连接超时\n\n记住：Drogon 是一个功能强大的 C++ Web 框架，正确的编译安装是开始开发的基础。建议在开发环境中充分测试后再部署到生产环境！\n","categories":["C++核心开发","系统库与框架"],"tags":["C++","Windows","Drogon","Web框架","编译安装"]},{"title":"Qt 性能优化指南","url":"/posts/eebf2140/","content":"Qt 性能优化指南概述Qt应用性能优化是提升用户体验的关键因素。本文介绍多种Qt性能优化技术和最佳实践。\n内存管理优化智能指针使用// 使用QSharedPointer进行共享资源管理#include &lt;QSharedPointer&gt;class ResourceManager &#123;public:    static QSharedPointer&lt;ResourceManager&gt; instance() &#123;        static QSharedPointer&lt;ResourceManager&gt; ptr(new ResourceManager());        return ptr;    &#125;private:    ResourceManager() = default;&#125;;// 使用QWeakPointer避免循环引用class Controller : public QObject &#123;    Q_OBJECTpublic:    void setView(QSharedPointer&lt;View&gt; view) &#123;        m_view = view;        m_weakView = view.toWeakRef();    &#125;private:    QSharedPointer&lt;View&gt; m_view;    QWeakPointer&lt;View&gt; m_weakView;&#125;;\n\n对象池模式class ObjectPool &#123;public:    template&lt;typename T, typename... Args&gt;    std::unique_ptr&lt;T&gt; acquire(Args&amp;&amp;... args) &#123;        if (m_pool.empty()) &#123;            return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);        &#125;        auto obj = std::move(m_pool.back());        m_pool.pop_back();        return std::unique_ptr&lt;T&gt;(static_cast&lt;T*&gt;(obj.release()));    &#125;    template&lt;typename T&gt;    void release(std::unique_ptr&lt;T&gt; obj) &#123;        if (obj) &#123;            obj-&gt;reset(); // 重置对象状态            m_pool.emplace_back(std::move(obj));        &#125;    &#125;private:    std::vector&lt;std::unique_ptr&lt;void&gt;&gt; m_pool;&#125;;\n\n渲染性能优化绘制优化class OptimizedWidget : public QWidget &#123;public:    void paintEvent(QPaintEvent* event) override &#123;        QPainter painter(this);        // 使用抗锯齿        painter.setRenderHint(QPainter::Antialiasing);        // 只绘制需要更新的区域        QRect updateRect = event-&gt;rect();        // 使用缓存        if (m_cache.isNull() || m_cache.size() != size()) &#123;            updateCache();        &#125;        painter.drawPixmap(updateRect, m_cache, updateRect);    &#125;private:    void updateCache() &#123;        m_cache = QPixmap(size());        m_cache.fill(Qt::transparent);        QPainter painter(&amp;m_cache);        painter.setRenderHint(QPainter::Antialiasing);        // 执行复杂的绘制操作        drawComplexContent(&amp;painter);    &#125;    QPixmap m_cache;&#125;;\n\nOpenGL加速class OpenGLWidget : public QOpenGLWidget &#123;protected:    void initializeGL() override &#123;        initializeOpenGLFunctions();        // 启用深度测试        glEnable(GL_DEPTH_TEST);        // 创建着色器程序        m_shaderProgram.addShaderFromSourceCode(            QOpenGLShader::Vertex,            R&quot;(#version 330 core               layout(location = 0) in vec3 position;               uniform mat4 mvpMatrix;               void main() &#123;                   gl_Position = mvpMatrix * vec4(position, 1.0);               &#125;)&quot;        );        m_shaderProgram.link();    &#125;    void paintGL() override &#123;        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        m_shaderProgram.bind();        // 绘制OpenGL内容    &#125;private:    QOpenGLShaderProgram m_shaderProgram;&#125;;\n\n多线程优化后台处理class BackgroundProcessor : public QObject &#123;    Q_OBJECTpublic:    explicit BackgroundProcessor(QObject* parent = nullptr)        : QObject(parent) &#123;        // 创建工作线程        m_workerThread = new QThread(this);        m_worker = new Worker();        m_worker-&gt;moveToThread(m_workerThread);        connect(this, &amp;BackgroundProcessor::processData,                m_worker, &amp;Worker::process);        connect(m_worker, &amp;Worker::finished,                this, &amp;BackgroundProcessor::onFinished);        m_workerThread-&gt;start();    &#125;    void processDataAsync(const QByteArray&amp; data) &#123;        emit processData(data);    &#125;signals:    void processData(const QByteArray&amp; data);private slots:    void onFinished(const QByteArray&amp; result) &#123;        // 处理完成，更新UI        emit resultReady(result);    &#125;signals:    void resultReady(const QByteArray&amp; result);private:    QThread* m_workerThread;    Worker* m_worker;&#125;;\n\n线程池class ThreadPoolManager &#123;public:    ThreadPoolManager(int threadCount = QThread::idealThreadCount()) &#123;        m_threadPool.setMaxThreadCount(threadCount);    &#125;    template&lt;typename Func, typename... Args&gt;    auto run(Func&amp;&amp; func, Args&amp;&amp;... args)        -&gt; std::future&lt;decltype(func(args...))&gt; &#123;        using ReturnType = decltype(func(args...));        auto task = std::make_shared&lt;std::packaged_task&lt;ReturnType()&gt;&gt;(            std::bind(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...)        );        std::future&lt;ReturnType&gt; result = task-&gt;get_future();        m_threadPool.start([task]() &#123;            (*task)();        &#125;);        return result;    &#125;private:    QThreadPool m_threadPool;&#125;;\n\n数据结构优化高效的数据模型class OptimizedModel : public QAbstractItemModel &#123;public:    QVariant data(const QModelIndex&amp; index, int role) const override &#123;        if (!index.isValid() || role != Qt::DisplayRole) &#123;            return QVariant();        &#125;        // 使用行号直接访问，避免复杂的查找        int row = index.row();        if (row &gt;= 0 &amp;&amp; row &lt; m_data.size()) &#123;            return m_data[row];        &#125;        return QVariant();    &#125;    // 批量更新优化    void updateData(const QList&lt;QString&gt;&amp; newData) &#123;        beginResetModel();        m_data = newData;        endResetModel();    &#125;private:    QList&lt;QString&gt; m_data; // 使用QList而非QMap，提高访问速度&#125;;\n\n缓存策略class DataCache &#123;public:    template&lt;typename Key, typename Value&gt;    class LRUCache &#123;    public:        LRUCache(size_t capacity) : m_capacity(capacity) &#123;&#125;        Value get(const Key&amp; key) &#123;            auto it = m_cache.find(key);            if (it != m_cache.end()) &#123;                // 移动到前面                m_usage.splice(m_usage.begin(), m_usage, it-&gt;second.second);                return it-&gt;second.first;            &#125;            return Value();        &#125;        void put(const Key&amp; key, const Value&amp; value) &#123;            auto it = m_cache.find(key);            if (it != m_cache.end()) &#123;                // 更新现有项                it-&gt;second.first = value;                m_usage.splice(m_usage.begin(), m_usage, it-&gt;second.second);            &#125; else &#123;                // 添加新项                if (m_cache.size() &gt;= m_capacity) &#123;                    // 移除最久未使用的项                    auto last = m_usage.back();                    m_cache.erase(last);                    m_usage.pop_back();                &#125;                m_usage.push_front(key);                m_cache[key] = &#123;value, m_usage.begin()&#125;;            &#125;        &#125;    private:        size_t m_capacity;        std::unordered_map&lt;Key, std::pair&lt;Value, std::list&lt;Key&gt;::iterator&gt;&gt; m_cache;        std::list&lt;Key&gt; m_usage;    &#125;;&#125;;\n\n网络优化异步网络请求class NetworkManager : public QObject &#123;    Q_OBJECTpublic:    NetworkManager(QObject* parent = nullptr) : QObject(parent) &#123;        m_manager.setRedirectPolicy(QNetworkRequest::NoLessSafeRedirectPolicy);    &#125;    QFuture&lt;QByteArray&gt; getAsync(const QString&amp; url) &#123;        auto promise = std::make_shared&lt;QPromise&lt;QByteArray&gt;&gt;();        auto future = promise-&gt;future();        QNetworkRequest request(QUrl(url));        request.setAttribute(QNetworkRequest::CacheLoadControlAttribute,                           QNetworkRequest::PreferCache);        QNetworkReply* reply = m_manager.get(request);        connect(reply, &amp;QNetworkReply::finished, [=]() &#123;            if (reply-&gt;error() == QNetworkReply::NoError) &#123;                promise-&gt;addResult(reply-&gt;readAll());            &#125; else &#123;                promise-&gt;setException(std::make_exception_ptr(                    std::runtime_error(reply-&gt;errorString().toStdString())));            &#125;            reply-&gt;deleteLater();        &#125;);        return future;    &#125;private:    QNetworkAccessManager m_manager;&#125;;\n\n连接池class ConnectionPool &#123;public:    std::shared_ptr&lt;QNetworkAccessManager&gt; getConnection() &#123;        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);        if (!m_connections.empty()) &#123;            auto connection = m_connections.back();            m_connections.pop_back();            return connection;        &#125;        return std::make_shared&lt;QNetworkAccessManager&gt;();    &#125;    void returnConnection(std::shared_ptr&lt;QNetworkAccessManager&gt; connection) &#123;        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);        m_connections.push_back(connection);    &#125;private:    std::vector&lt;std::shared_ptr&lt;QNetworkAccessManager&gt;&gt; m_connections;    std::mutex m_mutex;&#125;;\n\n性能监控性能分析器class PerformanceProfiler &#123;public:    struct ProfileData &#123;        QString name;        qint64 elapsedTime;        qint64 memoryUsage;    &#125;;    static PerformanceProfiler&amp; instance() &#123;        static PerformanceProfiler profiler;        return profiler;    &#125;    void startProfile(const QString&amp; name) &#123;        m_startTimes[name] = QDateTime::currentMSecsSinceEpoch();        m_memoryUsages[name] = getCurrentMemoryUsage();    &#125;    ProfileData endProfile(const QString&amp; name) &#123;        auto startIt = m_startTimes.find(name);        if (startIt != m_startTimes.end()) &#123;            qint64 elapsedTime = QDateTime::currentMSecsSinceEpoch() - startIt-&gt;second;            qint64 memoryUsage = getCurrentMemoryUsage() - m_memoryUsages[name];            m_startTimes.erase(startIt);            m_memoryUsages.erase(name);            return &#123;name, elapsedTime, memoryUsage&#125;;        &#125;        return &#123;name, 0, 0&#125;;    &#125;private:    qint64 getCurrentMemoryUsage() &#123;        // 实现获取当前内存使用量的逻辑        return 0;    &#125;    QHash&lt;QString, qint64&gt; m_startTimes;    QHash&lt;QString, qint64&gt; m_memoryUsages;&#125;;// RAII性能计时器class ScopedTimer &#123;public:    explicit ScopedTimer(const QString&amp; name) : m_name(name) &#123;        PerformanceProfiler::instance().startProfile(m_name);    &#125;    ~ScopedTimer() &#123;        auto data = PerformanceProfiler::instance().endProfile(m_name);        qDebug() &lt;&lt; &quot;Profile:&quot; &lt;&lt; data.name                 &lt;&lt; &quot;Time:&quot; &lt;&lt; data.elapsedTime &lt;&lt; &quot;ms&quot;                 &lt;&lt; &quot;Memory:&quot; &lt;&lt; data.memoryUsage &lt;&lt; &quot;bytes&quot;;    &#125;private:    QString m_name;&#125;;\n\n最佳实践总结1. 内存管理\n使用智能指针避免内存泄漏\n实现对象池减少内存分配\n及时释放不需要的资源\n\n2. 渲染优化\n使用缓存减少重复绘制\n启用OpenGL加速\n只更新必要的区域\n\n3. 多线程\n将耗时操作移到后台线程\n使用线程池管理线程\n避免在UI线程执行重操作\n\n4. 数据结构\n选择合适的数据结构\n使用缓存策略\n批量操作而非逐个处理\n\n5. 网络优化\n使用异步网络请求\n实现连接池\n合理使用缓存\n\n通过这些优化技术，可以显著提升Qt应用的性能和用户体验。\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt"]},{"title":"Qt 框架概述","url":"/posts/9b28b992/","content":"Qt 框架概述📚 知识库概述本知识库提供了Qt框架的完整学习资源，涵盖了从基础入门到高级应用的全方位技术指南。所有文档都遵循统一的标准，包含完整的代码示例和最佳实践。\n🗂️ 文档分类结构🚀 核心特性 (Core-Features)\nQt Model-View 架构指南\nModel-View-Delegate 模式详解\n自定义 Model 和 Delegate\n使用 ProxyModel 实现排序和过滤\n\n\nQt 多线程编程指南\nQThread 的正确使用模式 (Worker-Object)\n线程同步与 QtConcurrent 并发框架\n\n\nQt 国际化 (i18n) 指南\n使用 tr、lupdate、lrelease 和 QTranslator 的标准工作流程\n动态语言切换与 QLocale 本地化\n\n\nQt 单元测试指南\nQt Test 框架、数据驱动测试与 GUI 测试\n模拟对象 (Mocking) 与持续集成\n\n\n\n🎨 GUI编程 (GUI)\nQPainter 完整指南\n2D图形绘制、文本渲染、图像处理\n渐变、变换与高级特效\n自定义控件开发实例\n\n\nQSS 样式表完整指南\nQSS 语法、选择器、盒子模型与伪状态\n子控件样式化\n主题化与最佳实践\n\n\n\n🌐 网络编程 (Networking)\nQt 网络编程指南\n使用 QNetworkAccessManager (HTTP), QTcpSocket, QUdpSocket, QWebSocket\n包含清晰、独立的客户端与服务端示例\n\n\nQt libcurl 集成指南 (Windows)\n使用 vcpkg 管理和集成 libcurl\n在 Qt 项目中封装和使用 libcurl\n\n\n\n🎵 多媒体 (Multimedia)\nQCamera 摄像头图像采集指南\n使用 QCamera 和 QVideoWidget 实现摄像头预览\n使用 QCameraImageCapture 实现拍照功能\n\n\nQMediaPlayer 音乐播放器教程\n使用 QMediaPlayer 和 QMediaPlaylist 构建一个功能性的音乐播放器\n实现播放、暂停、进度控制和播放列表功能\n\n\nQAudioInput 音频录制教程\n使用 QAudioInput 实现音频录制\nWAV 文件格式处理\n\n\n\n🗄️ 数据处理 (Data)\nQt SQL 数据库指南\n使用 QSqlDatabase、QSqlQuery 和 QSqlTableModel\n预处理查询与事务\n\n\nQt SQLite 加密指南 (SQLCipher)\n编译 Qt 驱动以支持 SQLCipher\n加密数据库的创建和使用\n\n\n\n🎯 学习路径建议初学者路径\nGUI: 从 QPainter 完整指南 和 QSS 样式表完整指南 开始，掌握界面绘制与美化。\n核心特性: 学习 Qt 多线程编程指南 以处理耗时任务，避免界面卡顿。\n数据处理: 阅读 Qt SQL 数据库指南 学习本地数据存储。\n\n中级开发者路径\n网络编程: 学习 Qt 网络编程指南 以实现客户端&#x2F;服务器通信。\n核心特性: 深入 Qt Model-View 架构指南 以构建复杂的数据驱动界面。\n多媒体: 尝试 QMediaPlayer 音乐播放器教程 来构建多媒体应用。\n\n高级开发者路径\n数据处理: 学习 Qt SQLite 加密指南 (SQLCipher) 了解高级数据安全技术。\n核心特性: 掌握 Qt 单元测试指南 和 Qt 国际化 (i18n) 指南 以开发生产级的、全球化的应用。\n网络编程: 了解如何集成第三方网络库，如 Qt libcurl 集成指南 (Windows)。\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","学习路径"]},{"title":"Boost Linux 编译指南","url":"/posts/20b20a6b/","content":"Boost Linux 编译指南目录\n方式一：使用包管理器安装\n方式二：从源码编译 (推荐)\n编译后配置\n测试验证\n编译选项详解\n项目集成 (Makefile &amp; CMake)\n常见问题\n\n方式一：使用包管理器安装这是最简单的方式，但版本可能不是最新的。\n# Boost Linux 编译指南# Boost Linux 编译指南sudo apt-cache search libboost# Boost Linux 编译指南# Boost Linux 编译指南sudo apt install libboost-all-dev# Boost Linux 编译指南dpkg -s libboost-dev | grep Version\n\n方式二：从源码编译 (推荐)这种方式可以让你完全控制 Boost 的版本、编译选项和安装路径。\n1. 安装依赖# Boost Linux 编译指南sudo apt updatesudo apt install -y build-essential g++ python3-dev autotools-dev libicu-dev libbz2-dev libopenmpi-dev\n\n2. 下载源码\n提示: 本文以 1.85.0 版本为例。建议访问 Boost 官网 获取最新版本号，并替换下面的命令。\n\n选项 A: 使用 wget 下载# Boost Linux 编译指南wget https://boostorg.jfrog.io/artifactory/main/release/1.85.0/source/boost_1_85_0.tar.bz2# Boost Linux 编译指南tar --bzip2 -xf boost_1_85_0.tar.bz2cd boost_1_85_0/\n\n选项 B: 使用 Git 克隆# Boost Linux 编译指南git clone --branch boost-1.85.0 https://github.com/boostorg/boost.git boost-1.85.0cd boost-1.85.0# Boost Linux 编译指南git submodule update --init --recursive\n\n3. 生成编译工具此步骤会生成 b2 编译引擎。\n# Boost Linux 编译指南./bootstrap.sh --prefix=/usr/local/boost\n\n4. 编译与安装# Boost Linux 编译指南./b2 --show-libraries# Boost Linux 编译指南# Boost Linux 编译指南# Boost Linux 编译指南# Boost Linux 编译指南sudo ./b2 install -j$(nproc) --with-thread --with-system --with-serialization --with-filesystem --with-date_time# Boost Linux 编译指南# Boost Linux 编译指南\n\n编译后配置配置动态链接器为了让系统能在运行时找到刚刚安装的 Boost 库文件。\n# Boost Linux 编译指南sudo nano /etc/ld.so.conf.d/boost.conf# Boost Linux 编译指南/usr/local/boost/lib# Boost Linux 编译指南sudo ldconfig# Boost Linux 编译指南ldconfig -p | grep boost\n\n测试验证1. 编写测试代码test_boost.cpp:\n#include &lt;iostream&gt;#include &lt;boost/version.hpp&gt;#include &lt;boost/thread.hpp&gt;void hello_boost() &#123;    std::cout &lt;&lt; &quot;Hello from Boost thread!&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Using Boost Version: &quot; &lt;&lt; BOOST_LIB_VERSION &lt;&lt; std::endl;        boost::thread my_thread(&amp;hello_boost);    my_thread.join();        return 0;&#125;\n\n2. 编译并运行# Boost Linux 编译指南# Boost Linux 编译指南g++ test_boost.cpp -I/usr/local/boost/include -L/usr/local/boost/lib -o test_boost -lboost_thread -lpthread# Boost Linux 编译指南./test_boost\n如果成功输出版本号和 “Hello from Boost thread!”，则说明编译安装成功。\n编译选项详解在执行 ./b2 命令时，可以附加许多参数来控制编译行为。\n\n--with-&lt;library&gt; &#x2F; --without-&lt;library&gt;: 指定编译或不编译某个库。\nvariant=debug|release: 编译调试版还是发布版。\nlink=static|shared: 编译静态库 (.a) 还是动态库 (.so)。\nruntime-link=static|shared: 链接到静态 C++ 运行时库还是动态的。\naddress-model=32|64: 编译 32 位或 64 位。\n\n示例：编译 64 位静态发布版\nsudo ./b2 install -j$(nproc) variant=release link=static address-model=64\n\n项目集成 (Makefile &amp; CMake)Makefile 示例CXX = g++CXXFLAGS = -std=c++17 -Wall -O2# Boost Linux 编译指南BOOST_ROOT = /usr/local/boostBOOST_INCLUDE = $(BOOST_ROOT)/includeBOOST_LIB_PATH = $(BOOST_ROOT)/lib# Boost Linux 编译指南BOOST_LIBS = -lboost_system -lboost_threadTARGET = my_appSOURCES = main.cpp$(TARGET): $(SOURCES)\t$(CXX) $(CXXFLAGS) -I$(BOOST_INCLUDE) -L$(BOOST_LIB_PATH) -o $@ $^ $(BOOST_LIBS) -lpthreadclean:\trm -f $(TARGET)\n\nCMakeLists.txt 示例cmake_minimum_required(VERSION 3.15)project(MyBoostProject CXX)set(CMAKE_CXX_STANDARD 17)# Boost Linux 编译指南# Boost Linux 编译指南# Boost Linux 编译指南find_package(Boost 1.85.0 REQUIRED COMPONENTS system thread filesystem)if(Boost_FOUND)    message(STATUS &quot;Found Boost: $&#123;Boost_INCLUDE_DIRS&#125;&quot;)    include_directories($&#123;Boost_INCLUDE_DIRS&#125;)    add_executable(my_app main.cpp)    # 链接 Boost 库    target_link_libraries(my_app PRIVATE Boost::system Boost::thread Boost::filesystem)endif()\n\n常见问题Q1: 编译失败，提示缺少 Python.h?A: 需要安装 Python 开发包。sudo apt install python3-dev。\nQ2: 编译时提示找不到库，如 cannot find -lboost_thread?A: 确保 -L/usr/local/boost/lib 路径正确，并且该目录下确实存在对应的库文件（如 libboost_thread.so 或 libboost_thread.a）。\nQ3: 运行时提示 error while loading shared libraries?A: 这是因为动态链接器找不到库。请返回 编译后配置 章节，正确设置 ldconfig。临时的解决方法是 export LD_LIBRARY_PATH=/usr/local/boost/lib:$LD_LIBRARY_PATH。\n","categories":["C++核心开发","C++基础与进阶"],"tags":["C++","Linux","Boost","库编译","系统库"]},{"title":"Git 常用命令大全：从入门到精通的版本控制实战指南","url":"/posts/bae20393/","content":"Git 常用命令指南目录\n仓库管理\n代码提交\n分支管理\n远程操作\n文件&#x2F;目录操作\n历史查看\n撤销与修改\n标签管理\n储藏工作\n子模块管理\n\n仓库管理克隆仓库# 克隆包含子模块的仓库git clone --recurse-submodules [url] [directory]\n\n初始化本地仓库# 在当前目录初始化一个新仓库git init\n\n代码提交查看更改状态# 查看工作区和暂存区的更改状态git status# 查看简洁的状态信息git status -s# 查看文件的具体更改内容git diff\n\n暂存更改# 添加所有更改到暂存区git add .# 添加特定文件到暂存区git add &lt;file&gt;# 交互式暂存文件的部分更改git add -p &lt;file&gt;\n\n提交更改# 提交到本地仓库git commit -m &quot;Your commit message&quot;# 提交并暂存所有已跟踪文件的更改git commit -am &quot;Your commit message&quot;# 查看即将提交的更改（预览）git commit --dry-run\n\n分支管理查看分支# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地和远程分支git branch -a\n\n创建与切换分支# 创建新分支git branch [branch-name]# 切换到指定分支git checkout [branch-name]# 或者使用更现代的 switch 命令git switch [branch-name]# 创建并立即切换到新分支git checkout -b [new-branch-name]# 或者使用更现代的 switch 命令git switch -c [new-branch-name]\n\n合并与删除分支# 将指定分支合并到当前分支git merge [branch-name]# 删除本地分支（需先切换到其他分支）git branch -d [branch-name]\n\n远程操作关联远程仓库# 添加远程仓库并命名为 origin# 注意：新仓库的默认分支可能为 main 而不是 mastergit remote add origin https://github.com/用户名/仓库名.git# 推送本地提交到远程仓库，并建立上游跟踪关系git push -u origin main\n\n拉取远程代码# 从远程拉取最新代码并与本地分支合并git pull [remote] [branch]# 从远程拉取最新代码并尝试将本地修改变基到其之上git pull --rebase [remote] [branch]\n\n推送到远程仓库# 推送当前分支的提交git push [remote] [branch]# 推送所有本地标签git push [remote] --tags# 删除远程分支git push [remote] --delete [branch]# 强制推送（高风险操作）# 警告：这会覆盖远程历史记录，可能导致团队成员丢失提交。请仅在确知后果时使用。git push [remote] [branch] --force\n\n文件&#x2F;目录操作重命名或移动文件&#x2F;目录# git mv 命令会同时更新 Git 的跟踪记录git mv &lt;old-path&gt; &lt;new-path&gt;\n\n历史查看查看提交历史# 查看详细历史记录git log# 以单行、图形化方式显示历史记录git log --oneline --graph --decorate# 查看特定文件的修改历史git log --follow &lt;file&gt;\n\n撤销与修改修改最后一次提交# 如果还未推送到远程，可以使用此命令来修改最后一次的提交信息或内容git commit --amend\n\n撤销本地更改# 撤销工作区中对某个文件的更改（恢复到暂存区版本）git restore &lt;file&gt;# 将文件从暂存区移回工作区（不改变文件内容）git restore --staged &lt;file&gt;# 撤销工作区中所有文件的更改git restore .# 恢复文件到指定提交git restore --source=&lt;commit&gt; &lt;file&gt;\n\n修改历史提交# 交互式变基，可以修改、合并或删除最近的N次提交（高风险操作）# 警告：不要在已经推送到公共仓库的分支上执行此操作。git rebase -i HEAD~3\n\n标签管理创建标签# 创建轻量标签git tag &lt;tag-name&gt;# 创建带注释的标签git tag -a &lt;tag-name&gt; -m &quot;Tag message&quot;# 为特定提交创建标签git tag &lt;tag-name&gt; &lt;commit-hash&gt;\n\n查看标签# 列出所有标签git tag# 查看标签详细信息git show &lt;tag-name&gt;# 搜索特定模式的标签git tag -l &quot;v*&quot;\n\n推送标签# 推送单个标签到远程git push origin &lt;tag-name&gt;# 推送所有标签到远程git push origin --tags# 推送标签并设置跟踪git push --follow-tags\n\n删除标签# 删除本地标签git tag -d &lt;tag-name&gt;# 删除远程标签git push origin --delete &lt;tag-name&gt;\n\n储藏工作储藏当前工作# 储藏当前工作区的更改git stash# 储藏并添加消息git stash save &quot;Your stash message&quot;# 储藏包括未跟踪的文件git stash -u\n\n查看和应用储藏# 查看储藏列表git stash list# 应用最新的储藏git stash apply# 应用并删除最新的储藏git stash pop# 应用特定储藏git stash apply stash@&#123;0&#125;\n\n子模块管理添加子模块# 添加子模块到仓库git submodule add &lt;repository-url&gt; [path]# 克隆包含子模块的仓库git clone --recurse-submodules &lt;repository-url&gt;\n\n更新子模块# 初始化并更新所有子模块git submodule update --init --recursive# 拉取子模块的最新更改git submodule update --remote# 进入子模块目录并拉取最新更改cd &lt;submodule-path&gt; &amp;&amp; git pull origin main\n","categories":["开发工具与流程","版本控制"],"tags":["开发工具","Git","版本控制"]},{"title":"Boost Windows 编译指南","url":"/posts/190baecd/","content":"Boost Windows 编译指南目录\n概述\n环境准备\n获取与准备源码\n核心编译步骤\n验证编译结果\n项目集成\n常见问题与解答\n自动化脚本示例\n\n概述本指南详细介绍如何在 Windows 平台上，使用 Visual Studio 和 b2.exe 构建工具，完整地静态编译 Boost C++ 库。\n静态编译的优势\n易于分发: 应用程序不依赖外部的 Boost DLL 文件，所有代码都在可执行文件内部。\n版本控制: 避免最终用户的机器上出现 DLL 版本冲突。\n性能: 可能有轻微的启动性能优势，因为减少了动态加载。\n\n环境准备1. 软件要求\n操作系统: Windows 10&#x2F;11 (x64)\nIDE: Visual Studio 2019 (MSVC v14.2) 或 2022 (MSVC v14.3)\n组件: 确保 VS 安装程序已勾选 “使用 C++ 的桌面开发”，并包含最新的 Windows SDK。\n(可选) Python: 如果需要编译 Boost.Python，请安装 Python 3.8+。\n\n2. 开发者命令提示符编译 Boost 必须在 Visual Studio 提供的开发者命令提示符环境中进行，因为它预设了所有必要的环境变量（编译器路径、SDK 路径等）。\n启动方式:\n\n从“开始”菜单找到 Visual Studio 2022 -&gt; x64 Native Tools Command Prompt for VS 2022。\n或者，在普通的 cmd 中手动执行 vcvars 脚本（路径可能因你的安装而异）：call &quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat&quot;\n\n获取与准备源码\n提示: 本文以 1.85.0 版本为例。建议访问 Boost 官网 获取最新版本号。\n\n1. 下载并解压# Boost Windows 编译指南md C:\\dev\\libscd C:\\dev\\libs# Boost Windows 编译指南powershell -Command &quot;Invoke-WebRequest -Uri &#x27;https://boostorg.jfrog.io/artifactory/main/release/1.85.0/source/boost_1_85_0.7z&#x27; -OutFile &#x27;boost_1_85_0.7z&#x27;&quot;# Boost Windows 编译指南7z x boost_1_85_0.7zcd boost_1_85_0\n\n2. 生成构建工具运行 bootstrap.bat 脚本来生成 b2.exe 构建工具。\n# Boost Windows 编译指南bootstrap.bat\n执行完毕后，当前目录会生成 b2.exe 和 bjam.exe。\n核心编译步骤1. 理解核心编译参数\ntoolset=msvc-14.3: 指定使用 VS 2022 的编译器。\naddress-model=64: 编译 64 位版本。\nlink=static: [核心] 生成静态链接库 (.lib)。\nruntime-link=static: [核心] 静态链接 C&#x2F;C++ 运行时库。这对应 VS 项目属性中的 /MT (Release) 或 /MTd (Debug)。\nvariant=release: 编译发布版本。也可以是 debug 或 debug,release。\nthreading=multi: 编译多线程版本（现代应用标配）。\n--stagedir=&lt;path&gt;: 指定编译产物（.lib 文件）的输出目录。\n-j&lt;N&gt;: 并行编译任务数，例如 -j%NUMBER_OF_PROCESSORS%。\n\n2. 执行编译命令以下是一个推荐的、用于生成 64 位静态 Release 库的完整命令：\n# Boost Windows 编译指南# Boost Windows 编译指南b2.exe -j%NUMBER_OF_PROCESSORS% ^    toolset=msvc-14.3 ^    address-model=64 ^    link=static ^    runtime-link=static ^    variant=release ^    threading=multi ^    --stagedir=&quot;bin\\win-x64-static-release&quot; ^    --without-python\n编译过程会持续一段时间。编译完成后，所有生成的 .lib 文件都会在 bin\\win-x64-static-release\\lib 目录中。\n验证编译结果1. 检查库文件使用 dumpbin.exe 工具（VS 自带）可以查看 .lib 文件的信息。\n# Boost Windows 编译指南dumpbin /headers &quot;bin\\win-x64-static-release\\lib\\libboost_system-vc143-mt-s-x64-1_85.lib&quot; | findstr machine# Boost Windows 编译指南\n\n2. 编译测试程序test_boost.cpp:\n#define BOOST_ALL_NO_LIB // 禁用 Boost 的自动链接功能#include &lt;iostream&gt;#include &lt;boost/version.hpp&gt;#include &lt;boost/system/error_code.hpp&gt;int main() &#123;    std::cout &lt;&lt; &quot;Using Boost Version: &quot; &lt;&lt; BOOST_LIB_VERSION &lt;&lt; std::endl;    boost::system::error_code ec;    if (!ec) &#123;        std::cout &lt;&lt; &quot;Boost.System is working correctly!&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n编译命令:\ncl.exe /EHsc /MT /I&lt;Your-Boost-Source-Path&gt; test_boost.cpp /link /LIBPATH:&quot;&lt;Your-Boost-Source-Path&gt;\\bin\\win-x64-static-release\\lib&quot;\n\n/MT: 必须与 runtime-link=static 对应。如果是 variant=debug，则用 /MTd。\n/I: 指定 Boost 头文件根目录。\n/link /LIBPATH: 指定 .lib 文件所在的目录。\nBOOST_ALL_NO_LIB: 推荐在项目中定义此宏，手动管理链接的库，避免自动链接带来的问题。\n\n项目集成Visual Studio 项目属性对于一个现有的 VS 项目，你需要配置以下两个核心属性：\n\nC&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录:\n添加 Boost 的根目录，例如 C:\\dev\\libs\\boost_1_85_0。\n\n\n链接器 -&gt; 常规 -&gt; 附加库目录:\n添加你编译好的 .lib 文件所在目录，例如 C:\\dev\\libs\\boost_1_85_0\\bin\\win-x64-static-release\\lib。\n\n\n\n重要: 确保项目的 C&#x2F;C++ -&gt; 代码生成 -&gt; 运行时库 设置与你编译 Boost 时使用的 runtime-link 选项一致！\n\nruntime-link=static, variant=release -&gt; 多线程 (&#x2F;MT)\nruntime-link=static, variant=debug -&gt; 多线程调试 (&#x2F;MTd)\nruntime-link=shared, variant=release -&gt; 多线程 DLL (&#x2F;MD)\nruntime-link=shared, variant=debug -&gt; 多线程调试 DLL (&#x2F;MDd)\n\nCMakeLists.txt 示例cmake_minimum_required(VERSION 3.15)project(MyBoostApp)set(CMAKE_CXX_STANDARD 17)# Boost Windows 编译指南set(BOOST_ROOT &quot;C:/dev/libs/boost_1_85_0&quot;)# Boost Windows 编译指南set(Boost_USE_STATIC_LIBS ON)# Boost Windows 编译指南find_package(Boost 1.85.0 REQUIRED COMPONENTS system filesystem thread)if(Boost_FOUND)    add_executable(my_app main.cpp)        # 4. 链接库    target_link_libraries(my_app PRIVATE Boost::system Boost::filesystem Boost::thread)        # 5. 添加 include 目录    target_include_directories(my_app PRIVATE $&#123;Boost_INCLUDE_DIRS&#125;)endif()\n\n常见问题与解答Q1: 编译失败，提示找不到编译器 cl.exe 或 link.exe?A: 你没有在正确的“开发者命令提示符”环境中运行 b2.exe。请返回 环境准备 章节，确保命令行环境设置正确。\nQ2: 链接时出现 LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;?A: 这是最常见的问题。你的项目使用的“运行时库”设置与你编译的 Boost 库不匹配。请仔细检查并统一 VS 项目的 /MT, /MD 等设置。\nQ3: 如何理解 Boost 库文件的命名?A: libboost_system-vc143-mt-s-x64-1_85.lib\n\nlibboost_system: 库名\nvc143: 编译器版本 (VS 2022)\nmt: 多线程\ns: 静态链接 C&#x2F;C++ 运行时\nx64: 64位\n1_85: Boost 版本\n\n自动化脚本示例build_boost.bat:\n@echo offsetlocalREM --- 配置 ---set BOOST_SRC_PATH=C:\\dev\\libs\\boost_1_85_0set VS_VARS_BAT=&quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat&quot;set TOOLSET=msvc-14.3set ADDRESS_MODEL=64set STAGE_DIR=%BOOST_SRC_PATH%\\bin\\win-x64-static-releaseREM --- 执行 ---echo Setting up VS environment...call %VS_VARS_BAT%echo Changing to Boost source directory...cd /d %BOOST_SRC_PATH%echo Starting Boost build...b2.exe -j%NUMBER_OF_PROCESSORS% ^    toolset=%TOOLSET% ^    address-model=%ADDRESS_MODEL% ^    link=static ^    runtime-link=static ^    variant=release ^    --stagedir=&quot;%STAGE_DIR%&quot; ^    --without-pythonif %ERRORLEVEL% EQU 0 (    echo.    echo Boost build successful! Libraries are in: %STAGE_DIR%\\lib) else (    echo.    echo Boost build failed!)endlocal\n","categories":["C++核心开发","C++基础与进阶"],"tags":["C++","开发环境","Windows","Boost","静态编译","b2"]},{"title":"Boost b2 参数参考","url":"/posts/18f0987e/","content":"Boost b2 参数参考目录\n概述\n核心参数\n库选择参数\n构建属性参数\n路径与输出参数\n平台与架构参数\n实用编译示例\n脚本与最佳实践\n\n概述b2（其前身为 bjam）是 Boost C++ 库的官方构建引擎。它是一个功能强大的命令行工具，允许开发者通过丰富的参数精确控制编译过程。\n基本语法# Boost b2 参数参考./b2 [options] [properties] [target]\n\n获取帮助# Boost b2 参数参考./b2 --help# Boost b2 参数参考./b2 --show-libraries\n\n核心参数这些参数控制构建的基本行为。\n\nstage: 只编译库文件（例如 .a, .so, .lib, .dll），并将它们放置在 stagedir 指定的目录（默认为 stage/lib）。这是最常用的目标。\ninstall: 除了编译库文件，还会将 Boost 的头文件复制到 prefix 指定的目录。\n-j&lt;N&gt;: 设置并行编译的任务数，&lt;N&gt; 通常设为 CPU 的核心数以最大化编译速度。例如 -j8 或 -j$(nproc)。\n--clean: 清除上次的构建产物。\n\n库选择参数\n--with-&lt;library&gt;: 白名单模式。仅编译指定的库。可以多次使用。\n--without-&lt;library&gt;: 黑名单模式。编译所有库，除了指定的这些。\n\n# Boost b2 参数参考./b2 --with-thread --with-filesystem# Boost b2 参数参考./b2 --without-python --without-wave\n\n构建属性参数这些属性通过 property=value 的形式指定，可以组合使用。\ntoolset=&lt;compiler&gt;指定使用的编译器。\n\ngcc: GNU C++ Compiler\nclang: Clang C++ Compiler\nmsvc-14.3: Visual Studio 2022\nmsvc-14.2: Visual Studio 2019\nmsvc-14.1: Visual Studio 2017\n\nvariant=debug|release构建变体。\n\ndebug: 包含调试信息，不优化。\nrelease: 开启优化，不含调试信息。\n\nlink=static|shared链接方式。\n\nstatic: 生成静态库（.a, .lib）。\nshared: 生成动态库&#x2F;共享库（.so, .dll）。\n\nruntime-link=static|sharedC&#x2F;C++ 运行时的链接方式。\n\nstatic: 静态链接 C&#x2F;C++ 运行时库（例如，在 Windows 上使用 /MT 或 /MTd）。\nshared: 动态链接 C&#x2F;C++ 运行时库（例如，在 Windows 上使用 /MD 或 /MDd）。\n\nthreading=single|multi线程支持。\n\nsingle: 编译为单线程版本（不推荐，已很少使用）。\nmulti: 编译为多线程版本（现代应用的标准）。\n\n路径与输出参数\n--stagedir=&lt;path&gt;: 与 stage 目标配合使用，指定库文件的输出目录。\n--prefix=&lt;path&gt;: 与 install 目标配合使用，指定头文件和库文件的安装根目录。\n--build-dir=&lt;path&gt;: 指定存放所有中间文件的目录（例如 bin.v2）。对于隔离不同构建环境的产物非常有用。\n\n平台与架构参数address-model=32|64指定编译为 32 位还是 64 位应用。\narchitecture=x86|arm|...指定目标 CPU 架构。通常 b2 会自动检测，但在交叉编译时需要手动指定。\ncxxflags=&quot;...&quot; 和 linkflags=&quot;...&quot;传递自定义标志给编译器或链接器。\n./b2 cxxflags=&quot;-std=c++17&quot; linkflags=&quot;-s&quot;\n\n实用编译示例示例 1: Linux GCC编译用于 GCC 的 64 位多线程、动态链接、发布版 thread 和 filesystem 库。\n./b2 -j8 toolset=gcc address-model=64 threading=multi link=shared variant=release --with-thread --with-filesystem stage\n\n示例 2: Windows VS2022编译用于 Visual Studio 2022 的 32 位、静态链接、调试版、且静态链接运行时的所有库（除了 python）。\n./b2.exe -j8 toolset=msvc-14.3 address-model=32 link=static runtime-link=static variant=debug --without-python stage\n\n示例 3: 为特定目录输出将不同版本的库输出到不同目录，方便管理。\n# Boost b2 参数参考./b2.exe -j8 toolset=msvc-14.2 address-model=64 link=static variant=release --stagedir=&quot;lib/win-x64-msvc14.2-static-release&quot;# Boost b2 参数参考./b2.exe -j8 toolset=msvc-14.2 address-model=64 link=shared variant=debug --stagedir=&quot;lib/win-x64-msvc14.2-shared-debug&quot;\n\n脚本与最佳实践1. 使用构建脚本创建一个脚本来编译所有你需要的版本，可以确保一致性。\nbuild_boost_linux.sh:\n#!/bin/bashset -e # 如果任何命令失败则立即退出# Boost b2 参数参考./b2 -j$(nproc) toolset=gcc address-model=64 link=static variant=release \\    --stagedir=&quot;linux-x64-static-release&quot; \\    --without-python# Boost b2 参数参考./b2 -j$(nproc) toolset=gcc address-model=64 link=shared variant=debug \\    --stagedir=&quot;linux-x64-shared-debug&quot; \\    --without-pythonecho &quot;Boost build complete!&quot;\n\n2. 最佳实践\n使用 -j: 永远不要忘记使用 -j 参数，它能极大地缩短编译时间。\n隔离构建目录: 使用 --build-dir 为不同的构建版本（如 debug&#x2F;release）指定不同的中间目录，避免冲突和不必要的重编。\n精确选择库: 使用 --with-&lt;library&gt; 只编译你项目需要的库，可以节省大量时间和磁盘空间。\n清理: 在切换差异巨大的编译选项（如编译器版本）之前，可以运行 ./b2 --clean 来清理旧的构建产物。\n\n","categories":["C++核心开发","C++基础与进阶"],"tags":["Boost","b2","bjam","构建工具","编译参数"]},{"title":"Antigravity 登录认证完整解决方案（非TUN方法）","url":"/posts/56a10ecb/","content":"\n系统架构：Windows 10&#x2F;11 + Clash Proxy + Proxifier + Microsoft Edge\n协议支持：SOCKS5 代理 + OAuth 2.0 认证\n适用场景：国内网络环境 + 第三方服务认证\n文档版本：v2.0.0\n最后更新：2025-12-17\n\n\n📋 目录\n概述\n环境准备\n配置步骤\n故障排除\n核心验证测试\n\n\n📖 概述1.1 解决方案背景Antigravity 是一款基于云原生的开发平台，采用 OAuth 2.0 标准进行用户认证。由于国内网络环境的网络限制，直接访问 Google 认证服务存在技术壁垒，需要通过专业的代理架构实现认证链路的打通。\n1.2 核心要求\nGoogle 账号归属地必须为美国 - Antigravity 认证的硬性要求\n代理节点必须为美国地区 - 确保与账号归属地匹配\n企业网络环境兼容 - 适应企业防火墙和网络安全策略\n\n1.3 技术架构┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐│  Antigravity.exe │───▶│  Proxifier      │───▶│  Clash Proxy    ││  (OAuth Client) │    │  (Process Rule) │    │ (SOCKS5:7890)   │└─────────────────┘    └─────────────────┘    └─────────────────┘                                                    │                                               ┌─────────────┐                                               │  US Proxy    │                                               │  (Google API)│                                               └─────────────┘                                                    │                                               ┌─────────────┐                                               │ Google OAuth  │                                               │  (US Region)   │                                               └─────────────┘\n\n\n🔧 环境准备2.1 Google 账号要求\n\n\n要求项\n状态\n说明\n\n\n\n账号归属地\n⚠️ 必须为美国\nAntigravity 认证的硬性要求\n\n\n账号状态\n✅ 正常\n无封禁、限制或安全警告\n\n\n双重认证\n✅ 推荐\n建议开启 2FA 提高安全性\n\n\n浏览器登录\n✅ 已完成\nEdge 浏览器已登录目标账号\n\n\n⚠️ 重要提醒：\n\n非美国账号会被直接拒绝认证\n归属地不匹配会导致认证失败\n频繁切换地区会被标记为异常\n\n2.2 代理服务要求\n\n\n要求项\n规格\n说明\n\n\n\n地理位置\n⚠️ 必须为美国本土\n确保与账号归属地匹配\n\n\nIP 类型\n✅ 住宅级 IP\n避免数据中心 IP 被识别\n\n\n服务类型\n✅ 专业付费服务\n免费节点通常不可靠\n\n\n协议支持\n✅ SOCKS5\n与 Clash 兼容\n\n\n推荐节点选择：\n\n首选节点：洛杉矶、纽约、西雅图、芝加哥\n备选节点：旧金山、达拉斯、迈阿密\n避免使用：香港、日本、新加坡等亚洲节点\n\n2.3 软件环境要求\n\n\n软件\n版本要求\n用途\n\n\n\nClash\nv1.18.0+\nSOCKS5 代理服务\n\n\nProxifier\nv4.0+\n进程级代理管理\n\n\nEdge 浏览器\nv118.0+\nOAuth 认证浏览器\n\n\nAntigravity\nLatest\n目标应用程序\n\n\n\n⚙️ 配置步骤3.1 Clash 代理配置3.1.1 节点选择确保 Clash 客户端连接到美国地区节点，避免使用香港、日本等亚洲节点。\n3.1.2 规则配置更新 Clash 配置文件，添加 Antigravity 相关规则：\n# Google Auth &amp; Antigravity 必须走代理rules:  - &#x27;DOMAIN-SUFFIX,googleapis.com,🔰 节点选择&#x27;  - &#x27;DOMAIN-SUFFIX,sandbox.googleapis.com,🔰 节点选择&#x27;  - &#x27;DOMAIN,oauth2.googleapis.com,🔰 节点选择&#x27;  - &#x27;DOMAIN,accounts.google.com,🔰 节点选择&#x27;  - &#x27;DOMAIN,daily-cloudcode-pa.sandbox.googleapis.com,🔰 节点选择&#x27;  - &#x27;PROCESS-NAME,Antigravity.exe,🔰 节点选择&#x27;\n\n3.2 Proxifier 配置3.2.1 添加代理服务器\n打开 Proxifier → Profile → Proxy Servers… → Add\n配置参数：\nAddress: 127.0.0.1\nPort: 7890\nProtocol: SOCKS5\nAuthentication: NO\n\n\n点击 Check 验证连接，确认显示 “Socks5 server is available”\n\n3.2.2 创建代理规则规则1：Edge 浏览器直连（最高优先级）\n\nRule name: Edge Direct\nApplications: msedge.exe\nAction: Direct\nPriority: Highest\n\n规则2：Clash 进程直连（避免代理循环）\n\nRule name: Clash Processes Direct\nApplications: clash_*.exe\nAction: Direct\nPriority: High\n\n规则3：Antigravity 应用走代理\n\nRule name: Antigravity via Clash\nApplications: Antigravity.exe, language_server_windows_x64.exe\nAction: 127.0.0.1:7890\nPriority: Normal\n\n3.2.3 规则优先级确认确保规则按以下顺序排列：\n\nEdge Direct (最高优先级)\nClash Processes Direct (高优先级)\nAntigravity via Clash (普通优先级)\n\n3.3 系统环境配置3.3.1 清理环境变量必须清空以下系统环境变量：\n# Windows 命令行set HTTP_PROXY=&quot;&quot;set HTTPS_PROXY=&quot;&quot;set NO_PROXY=&quot;&quot;\n\n或者在系统属性中永久删除这些变量。\n3.3.2 防火墙配置确保防火墙允许以下连接：\n\nClash.exe (TCP:7890 入站)\nProxifier.exe (TCP 动态端口 出站)\nmsedge.exe (TCP&#x2F;UDP:80&#x2F;443 出站)\nAntigravity.exe (TCP&#x2F;UDP 动态端口 出站)\n\n\n🔧 故障排除4.1 认证流程问题问题：Edge 浏览器无法打开 Google 登录页面\n\n\n\n症状\n可能原因\n解决方案\n\n\n\nEdge 无响应\nProxifier 规则冲突\n检查规则顺序，Edge Direct 置顶\n\n\n页面加载失败\n环境变量污染\n清空 HTTP_PROXY&#x2F;HTTPS_PROXY\n\n\n连接超时\n网络防火墙限制\n检查防火墙配置\n\n\n问题：Google 登录成功但无法跳转回 Antigravity\n\n\n\n检查点\n验证方法\n解决方案\n\n\n\nOAuth 流程\nClash Connections 日志\n检查 Clash 规则配置\n\n\n应用代理\nProxifier 实时日志\n重新配置应用规则\n\n\n代理循环\nProxifier 连接日志\n添加 Clash 直连规则\n\n\n4.2 网络连接问题问题：代理节点连接不稳定\n# 基础连接测试curl --proxy socks5://127.0.0.1:7890 https://www.google.com# IP 地理位置检测curl --proxy socks5://127.0.0.1:7890 &quot;https://httpbin.org/ip&quot;# 连接稳定性测试ping -n 10 8.8.8.8\n\n节点质量标准：\n\n\n\n指标\n优秀\n可接受\n需更换\n\n\n\n延迟\n&lt; 100ms\n100-200ms\n&gt; 200ms\n\n\n稳定性\n99.9%+\n99%+\n&lt; 99%\n\n\n成功率\n100%\n99%+\n&lt; 99%\n\n\n4.3 账号相关问题Google 账号安全检查清单：\n\n 登录地点是否为美国地区\n 登录设备是否为已知设备\n 是否启用了两步验证\n 应用权限是否正确授权\n\n如果账号归属地检测失败，根本原因通常是：\n\n账号创建地：非美国地区创建（困难解决）\n常用登录地：长期非美国登录（中等解决）\n登录行为：频繁切换地区（简单解决）\n\n\n🧪 核心验证测试5.1 基础环境验证\n\n\n组件\n检查命令\n预期结果\n\n\n\nClash\n&#96;tasklist\nfindstr Clash&#96;\n\n\n端口监听\n&#96;netstat -an\nfindstr :7890&#96;\n\n\n代理连接\ncurl -x socks5://127.0.0.1:7890 https://www.google.com\nHTTP 200\n\n\nProxifier\n任务管理器检查\n进程运行\n\n\n环境变量\necho %HTTP_PROXY%\n空值\n\n\n5.2 OAuth 认证测试完整认证流程测试步骤：\n\n启动 Antigravity 客户端\n\n确认程序正常启动\n检查 Proxifier 日志显示代理连接\n\n\n触发 Google 登录\n\n点击 OAuth 登录按钮\n确认 Edge 浏览器自动打开\n\n\n浏览器验证\n\nEdge 应直连打开 Google 登录页\n地址栏 URL: accounts.google.com\n页面加载正常，无代理错误\n\n\n账号认证\n\n输入美国归属地 Google 账号凭据\n完成两步验证（如已启用）\n授权 Antigravity 应用访问权限\n\n\n回跳验证\n\n自动跳转回 Antigravity 应用\n应用显示登录成功状态\nClash 日志显示 OAuth API 代理请求\n\n\n\n5.3 关键验证点\n\n\n检查节点\n验证方法\n成功状态\n\n\n\nClash 状态\n控制面板\n绿色连接\n\n\n端口监听\nnetstat -an\n:7890 处于 LISTEN\n\n\n代理规则\nProxifier 规则列表\nEdge 规则置顶\n\n\n浏览器访问\n直接访问 Google\n正常加载\n\n\nIP 检测\n在线 IP 检测\n美国地址\n\n\nOAuth 请求\nClash Connections\n显示 googleapis.com\n\n\n\n📋 核心检查清单6.1 部署前检查Google 账号验证：\n\n 账号归属地为美国地区\n 账号状态正常，无安全警告\n 已启用两步验证\n 浏览器已登录目标账号\n\n代理服务验证：\n\n 代理节点位于美国地区\n 节点支持 Google 全套服务\n 节点连接稳定性 &gt; 99%\n IP 地址未被 Google 标记\n\n软件环境验证：\n\n Clash v1.18.0+ 正常运行\n Proxifier v4.0+ 已安装\n Microsoft Edge v118.0+ 已安装\n 系统环境变量已清空\n\n6.2 功能验证基础功能测试：\n\n Clash 控制面板显示连接正常\n 端口 7890 处于监听状态\n Google 服务访问正常\n IP 地址显示为美国地区\n\nOAuth 流程测试：\n\n Antigravity 启动正常\n 点击登录按钮触发 Edge 打开\n Edge 直连访问 Google 登录页\n Google 账号登录成功\n 自动跳转回 Antigravity 应用\n 应用显示登录成功状态\n\n\n📝 总结7.1 关键成功因素成功的两大前提：\n\nGoogle 账号归属地必须为美国：这是 Antigravity 认证的硬性要求\n代理节点必须为美国地区且支持 Google 全套服务：确保认证流量的地理合规性\n\n技术实施要点：\n\nProxifier 规则优先级配置是关键，Edge 浏览器必须直连\nClash 规则需要精确匹配 Google OAuth 相关域名\n系统环境变量必须清空，避免代理冲突\nClash 相关进程必须直连，避免代理循环\n\n7.2 快速故障排除指南认证失败的常见原因：\n\nGoogle 账号归属地不是美国 → 更换美国账号或重新注册\n代理节点不在美国地区 → 切换到美国节点\nEdge 浏览器被代理 → 检查 Proxifier 规则优先级\n系统环境变量冲突 → 清空 HTTP_PROXY&#x2F;HTTPS_PROXY\n代理循环 → 添加 clash_*.exe 直连规则\n\n验证成功的标志：\n\n✅ Edge OAuth 页面成功打开（直连）\n✅ 登录后成功回跳到 Antigravity\n✅ Clash Connections 能看到 oauth2.googleapis.com 走代理\n\n通过遵循本文档的核心配置步骤和验证方法，可以建立一个稳定、可靠的 Antigravity 认证环境。\n","categories":["开发工具","IDE编辑器"],"tags":["Antigravity","代理配置","OAuth认证","Clash","Proxifier","网络配置","企业环境"]},{"title":"Claude MCP 配置指南","url":"/posts/361d35d7/","content":"Claude MCP 配置指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: claude-code, mcp, model-context-protocol, productivity, automation\n\n📑 目录\n1. MCP 概述\n2. 必装 MCP 服务器\n3. 推荐组合\n4. 配置步骤\n5. Top 15 MCP 服务器\n6. 故障排除\n\n\n1. 📖 MCP 概述MCP (Model Context Protocol) 是 Claude Code 的扩展协议，允许 AI 助手直接控制各种工具和服务。\n🎯 MCP 优势\n✅ 扩展能力 - 大幅扩展 Claude 的功能范围\n✅ 自动化 - 实现复杂的自动化工作流\n✅ 集成性 - 连接各种第三方服务和工具\n✅ 实时性 - 获取最新的 API 文档和代码示例\n\n\n2. ⭐ 必装 MCP 服务器2.1 🌐 Playwright MCP - 浏览器自动化功能: 让 Claude 直接控制浏览器进行测试、截图、数据爬取\n# Claude MCP 配置指南claude mcp add playwright -s user -- npx @playwright/mcp@latest# Claude MCP 配置指南claude mcp list\n\n适用场景:\n\n🔄 自动化测试\n📸 网页截图\n🕷️ 网页数据爬取\n🎯 UI 交互测试\n\n2.2 📚 Context7 MCP - 文档实时查询功能: 获取各种编程库的最新文档和代码示例\n# Claude MCP 配置指南claude mcp add context7 -- npx -y @upstash/context7-mcp# Claude MCP 配置指南claude mcp add context7 -s user -- npx -y @upstash/context7-mcp\n\n适用场景:\n\n🔍 API 集成开发\n📖 编程学习\n💡 代码示例查找\n🆕 新技术探索\n\n2.3 🖥️ Filesystem MCP - 文件系统操作功能: 读写和管理本地文件、文件夹，批量操作\n# Claude MCP 配置指南npm install -g @modelcontextprotocol/server-filesystem\n\n适用场景:\n\n📁 代码分析\n📄 文档生成\n💾 自动备份\n🔄 批量文件处理\n\n2.4 🔧 Git MCP - 版本控制功能: 执行 Git 命令，管理版本控制\n# Claude MCP 配置指南npm install -g @modelcontextprotocol/server-github\n\n适用场景:\n\n📊 版本管理\n🚀 自动化部署\n👥 团队协作\n🔍 代码审查\n\n2.5 🗃️ Database MCP - 数据库连接功能: 连接和管理多种数据库\n# Claude MCP 配置指南npm install -g @modelcontextprotocol/server-postgres\n\n适用场景:\n\n🗄️ 数据库管理\n📊 数据分析\n🔍 SQL 查询\n💿 数据迁移\n\n\n3. 🎯 推荐组合3.1 📱 按角色分类graph TD    A[开发者角色] --&gt; B[前端开发者]    A --&gt; C[后端开发者]    A --&gt; D[数据分析师]    A --&gt; E[全栈开发者]    B --&gt; B1[Filesystem + Git + Figma]    C --&gt; C1[Git + Prisma + FastAPI]    D --&gt; D1[Context7 + Python + Database]    E --&gt; E1[Filesystem + Git + Pipedream]\n\n3.2 📦 5个必装组合基于2025年使用统计，以下 MCP 服务器覆盖90%的日常需求：\n\n@modelcontextprotocol&#x2F;server-filesystem - 文件系统访问\n@modelcontextprotocol&#x2F;server-github - GitHub 集成\n@modelcontextprotocol&#x2F;server-postgres - 数据库连接\n@modelcontextprotocol&#x2F;server-slack - 团队协作\n@modelcontextprotocol&#x2F;server-kubernetes - 容器管理\n\n\n4. ⚙️ 配置步骤4.1 🔍 步骤1: 安装 MCP 服务器# Claude MCP 配置指南npm install -g @modelcontextprotocol/server-browserkit \\  @modelcontextprotocol/server-ollama \\  @modelcontextprotocol/server-filesystem \\  @modelcontextprotocol/server-github \\  @modelcontextprotocol/server-postgres\n\n4.2 📝 步骤2: 配置 Claude Code CLIClaude Code CLI 的配置文件位于：\n\nmacOS &#x2F; Linux: ~/.config/claude/claude_desktop_config.json\nWindows: %USERPROFILE%\\.claude.json\n\n4.3 📄 步骤3: 配置示例&#123;  &quot;mcpServers&quot;: &#123;    &quot;browserkit&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [        &quot;-y&quot;,        &quot;@modelcontextprotocol/server-browserkit&quot;      ]    &#125;,    &quot;ollama&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [        &quot;-y&quot;,        &quot;@modelcontextprotocol/server-ollama&quot;      ]    &#125;,    &quot;filesystem&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [        &quot;-y&quot;,        &quot;@modelcontextprotocol/server-filesystem&quot;,        &quot;/path/to/allowed/directory&quot;      ]    &#125;,    &quot;github&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [        &quot;-y&quot;,        &quot;@modelcontextprotocol/server-github&quot;      ]    &#125;  &#125;&#125;\n\n4.4 🔧 步骤4: 特殊配置Xmind 生成器 MCP&#123;  &quot;mcpServers&quot;: &#123;    &quot;xmind&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [&quot;xmind-generator-mcp&quot;],      &quot;env&quot;: &#123;        &quot;outputPath&quot;: &quot;E:/xmind_generator_mcp_path&quot;,        &quot;autoOpenFile&quot;: &quot;false&quot;      &#125;    &#125;  &#125;&#125;\n\nOffice Word MCP# Claude MCP 配置指南claude mcp add office-word -s user -- uvx --from office-word-mcp-server word_mcp_server\n\n\n5. 📊 Top 15 MCP 服务器\n\n\n排名\n名称\nStar数\n核心功能\n最佳场景\n\n\n\n1\nFilesystem MCP\n64,053 ⭐\n读写&#x2F;管理本地文件、文件夹\n代码分析、文档生成、自动备份\n\n\n2\nGit MCP\n64,053 ⭐\n执行git命令，查看历史和差异\n版本管理、自动化部署、团队协作\n\n\n3\nPrisma MCP\n43,499 ⭐\n管理Prisma数据库模式\nWeb开发、数据库设计\n\n\n4\nContext7 MCP\n25,610 ⭐\n获取最新库文档和代码示例\nAPI集成、编程学习\n\n\n5\nGitHub MCP\n20,923 ⭐\n管理仓库、PR和Issues\n开源项目管理、CI&#x2F;CD\n\n\n6\nTask Master\n20,520 ⭐\n智能任务分解和优先级管理\n项目管理、敏捷开发\n\n\n7\nRepomix\n18,511 ⭐\n压缩代码库为AI友好格式\n大型代码审查、架构分析\n\n\n8\nBlenderMCP\n12,829 ⭐\n控制Blender进行3D建模\n游戏开发、3D设计\n\n\n9\nmcp-run-python\n11,603 ⭐\n安全运行Python代码\n算法验证、数据分析\n\n\n10\nPipedream\n10,139 ⭐\n连接2500+应用和API\n业务流程自动化、数据同步\n\n\n11\nFigma MCP\n9,891 ⭐\n读取Figma设计，生成前端代码\nUI&#x2F;UX开发、设计转代码\n\n\n12\n数据库MCP工具箱\n9,229 ⭐\n支持多数据库查询和优化\n数据库管理、数据分析\n\n\n13\nSerena\n8,743 ⭐\n大型代码库符号化分析\n代码重构、bug修复\n\n\n14\nFastAPI-MCP\n7,857 ⭐\n零配置集成FastAPI\nAPI开发、微服务\n\n\n15\nFonoster MCP\n6,740 ⭐\n管理电话系统\n客服系统、电话营销\n\n\n\n6. 🔧 故障排除6.1 ❌ 常见问题问题1: MCP 服务器无法启动# Claude MCP 配置指南claude mcp list# Claude MCP 配置指南claude mcp remove &lt;server-name&gt;claude mcp add &lt;server-name&gt; &lt;command&gt;\n\n问题2: 配置文件格式错误// 验证 JSON 格式&#123;  &quot;mcpServers&quot;: &#123;    &quot;server-name&quot;: &#123;      &quot;command&quot;: &quot;command-string&quot;,      &quot;args&quot;: [&quot;arg1&quot;, &quot;arg2&quot;]    &#125;  &#125;&#125;\n\n问题3: 权限问题# Claude MCP 配置指南ls -la ~/.claude.json# Claude MCP 配置指南chmod 600 ~/.claude.json\n\n6.2 🛠️ 调试技巧\n查看日志: 检查 Claude Code 的日志输出\n测试连接: 使用简单的命令测试 MCP 服务器\n逐步配置: 一次只添加一个 MCP 服务器\n版本检查: 确保所有依赖版本兼容\n\n6.3 📞 获取帮助\n官方文档: Claude Code MCP Documentation\n社区支持: GitHub Issues 和 Discussions\n示例配置: 官方示例仓库\n\n\n📚 扩展资源🔗 相关链接\nMCP 官方文档\nClaude Code 指南\nMCP 服务器列表\n\n🎯 学习路径\n基础配置 - 从简单的 Filesystem MCP 开始\n功能扩展 - 逐步添加专业领域 MCP\n自定义开发 - 学习开发自定义 MCP 服务器\n最佳实践 - 掌握高级配置和优化技巧\n\n\n📈 使用建议💡 效率提升技巧\n按需安装 - 只安装当前项目需要的 MCP\n定期更新 - 保持 MCP 服务器为最新版本\n性能优化 - 监控 MCP 服务器资源使用情况\n安全考虑 - 限制文件系统访问范围\n\n🔄 工作流优化graph LR    A[项目分析] --&gt; B[选择合适MCP]    B --&gt; C[配置测试]    C --&gt; D[集成工作流]    D --&gt; E[持续优化]    style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#e8f5e8    style D fill:#fff3e0    style E fill:#fce4ec\n\n\n\n💡 提示: MCP 配置是一个迭代过程，建议从基础功能开始，逐步扩展到复杂的自动化工作流。定期检查更新以获得最新功能和安全修复。\n\n","categories":["开发工具"],"tags":["技术文档","指南"]},{"title":"gRPC Linux 编译指南","url":"/posts/2a876257/","content":"gRPC Linux 编译指南目录\n概述\n环境准备\n获取源码\n编译与安装\n配置环境\n验证安装\n常见问题\n\n概述本指南详细介绍如何在 Linux 系统（以 Ubuntu&#x2F;Debian 为例）下，通过 CMake 从源码编译和安装 gRPC 及其核心依赖 Protobuf。\n此方法遵循 gRPC 官方推荐的流程，通过 Git 子模块来构建其依赖，确保版本兼容性，过程最简单、最可靠。\n系统要求\n操作系统: Ubuntu 20.04+ &#x2F; Debian 10+\n编译器: GCC 9+ 或 Clang 9+\nCMake: 3.13+\n内存: 建议 8GB+\n磁盘空间: 建议 15GB+ 可用空间\n\n环境准备# gRPC Linux 编译指南sudo apt update# gRPC Linux 编译指南sudo apt install -y \\    build-essential \\    autoconf \\    libtool \\    pkg-config \\    cmake \\    git \\    zlib1g-dev\n\n获取源码\n提示: 本文以 gRPC v1.64.0 为例。你可以从 gRPC 的 GitHub Releases 页面选择一个你需要的稳定版本标签。\n\n# gRPC Linux 编译指南mkdir -p ~/dev/grpc-build &amp;&amp; cd ~/dev/grpc-build# gRPC Linux 编译指南# gRPC Linux 编译指南# gRPC Linux 编译指南# gRPC Linux 编译指南git clone --recurse-submodules --depth 1 --shallow-submodules -b v1.64.0 https://github.com/grpc/grpc.git# gRPC Linux 编译指南# gRPC Linux 编译指南# gRPC Linux 编译指南\n国内用户如果访问 GitHub 速度慢，可以搜索 gRPC 的 Gitee 镜像，并相应地修改 .gitmodules 文件中的子模块 URL。\n编译与安装整个编译过程在 gRPC 源码目录内完成。\n# gRPC Linux 编译指南cd grpc# gRPC Linux 编译指南mkdir -p cmake/buildcd cmake/build# gRPC Linux 编译指南# gRPC Linux 编译指南# gRPC Linux 编译指南# gRPC Linux 编译指南cmake -DCMAKE_BUILD_TYPE=Release \\      -DgRPC_INSTALL=ON \\      -DCMAKE_INSTALL_PREFIX=/usr/local/grpc \\      ../..# gRPC Linux 编译指南# gRPC Linux 编译指南make -j$(nproc)# gRPC Linux 编译指南sudo make install\n\n配置环境1. 配置动态链接器为了让系统能在运行时找到刚刚安装的 gRPC 和 Protobuf 库文件。\n# gRPC Linux 编译指南sudo tee /etc/ld.so.conf.d/grpc.conf &gt; /dev/null &lt;&lt;EOF/usr/local/grpc/libEOF# gRPC Linux 编译指南sudo ldconfig# gRPC Linux 编译指南ldconfig -p | grep grpcldconfig -p | grep protobuf\n\n2. 配置 PATH 环境变量为了能直接使用 protoc 和 grpc_cpp_plugin 等命令行工具。\n# gRPC Linux 编译指南echo &#x27;export PATH=&quot;/usr/local/grpc/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrc# gRPC Linux 编译指南source ~/.bashrc\n\n验证安装# gRPC Linux 编译指南protoc --version# gRPC Linux 编译指南# gRPC Linux 编译指南which grpc_cpp_plugin# gRPC Linux 编译指南# gRPC Linux 编译指南cd ~/dev/grpc-build/grpc/examples/cpp/helloworldmkdir -p cmake/build &amp;&amp; cd cmake/build# gRPC Linux 编译指南cmake -DCMAKE_PREFIX_PATH=/usr/local/grpc ../..make -j$(nproc)# gRPC Linux 编译指南./greeter_server &amp;# gRPC Linux 编译指南./greeter_client# gRPC Linux 编译指南\n如果客户端成功输出了 “Hello world”，则说明你的 gRPC 环境已成功编译并可以正常工作。\n常见问题Q1: Git 克隆或子模块更新非常慢或失败?A: 这是国内常见的网络问题。你可以尝试为 Git 配置代理，或者查找并使用 Gitee 上的镜像。如果使用镜像，你可能需要手动修改 .gitmodules 文件中各个子模块的 url，然后再次运行 git submodule sync 和 git submodule update --init。\nQ2: 编译过程中提示内存不足 (Killed) ?A: gRPC 编译需要大量内存。如果你的机器内存小于 8GB，可能会发生这种情况。\n\n减少并行任务数: 尝试 make -j2 或 make -j1。\n增加交换空间 (Swap):sudo fallocate -l 4G /swapfilesudo chmod 600 /swapfilesudo mkswap /swapfilesudo swapon /swapfile# 编译完成后可以禁用并删除# sudo swapoff /swapfile &amp;&amp; sudo rm /swapfile\n\nQ3: sudo make install 后，protoc --version 仍然显示旧版本?A: 这通常是因为你的 PATH 环境变量中，系统自带的旧版本 protoc (如 /usr/bin/protoc) 位于你新安装的 /usr/local/grpc/bin 之前。\n\n运行 which protoc 确认你正在使用的是哪个 protoc。\n确保 /usr/local/grpc/bin 在 PATH 的最前面。\n或者，卸载系统自带的 protobuf-compiler (sudo apt remove protobuf-compiler)\n\n\n\n","categories":["C++核心开发","网络编程与RPC"],"tags":["C++","Linux","gRPC","Protobuf","编译","源码编译"]},{"title":"gRPC C++ 开发指南","url":"/posts/4f30aaf4/","content":"gRPC C++ 开发指南目录\ngRPC 概述\n环境配置\n第一步：定义服务 (.proto)\n第二步：生成代码 (protoc)\n第三步：实现服务端\n第四步：实现客户端\n第五步：编译与运行\n高级主题\n常见问题\n\ngRPC 概述gRPC 是一个由 Google 开发的、基于 HTTP&#x2F;2 的高性能、开源、通用的 RPC (远程过程调用) 框架。\n核心特性\n高性能: 基于 HTTP&#x2F;2，支持双向流、头部压缩、多路复用。\nIDL (接口定义语言): 使用 Protocol Buffers (Protobuf) 来定义服务接口和消息结构，具有强类型约束。\n跨语言: 支持 C++, Java, Python, Go, C#, Node.js, Ruby, PHP 等多种语言。\n四种服务类型:\n简单 RPC (Unary RPC)\n服务端流式 RPC (Server streaming RPC)\n客户端流式 RPC (Client streaming RPC)\n双向流式 RPC (Bidirectional streaming RPC)\n\n\n\n环境配置选项 A: 使用包管理器 (快速入门)这是最简单的方式，但 gRPC 和 Protobuf 的版本可能较旧。\n# gRPC C++ 开发指南sudo apt updatesudo apt install -y libgrpc++-dev protobuf-compiler libprotobuf-dev pkg-config\n\n选项 B: 从源码编译 (推荐)这是获取最新版本、完全控制编译选项的推荐方式。请参考我们知识库中的这篇独立指南：\n\ngRPC &amp; Protobuf 源码编译指南 (Linux)\n\n第一步：定义服务 (.proto)使用 Protocol Buffers 语法创建一个 .proto 文件来定义你的服务。\nchatter.proto:\nsyntax = &quot;proto3&quot;;package chatter;// 定义聊天服务service Chatter &#123;  // 简单 RPC: 发送一条消息  rpc SendMessage(MessageRequest) returns (MessageReply);  // 服务端流: 订阅消息  rpc SubscribeMessages(SubscriptionRequest) returns (stream MessageReply);&#125;// 发送消息的请求体message MessageRequest &#123;  string user_name = 1;  string content = 2;&#125;// 订阅消息的请求体message SubscriptionRequest &#123;  string user_name = 1;&#125;// 通用回复体message MessageReply &#123;  string server_id = 1;  string confirmation_message = 2;&#125;\n\n第二步：生成代码 (protoc)使用 protoc 编译器和 gRPC C++ 插件从 .proto 文件生成 C++ 代码。\n1. 命令详解protoc -I=&lt;proto_path&gt; --cpp_out=&lt;out_dir&gt; --grpc_out=&lt;out_dir&gt; --plugin=protoc-gen-grpc=&lt;plugin_path&gt; &lt;your_proto_file&gt;\n\n-I=&lt;proto_path&gt;: 指定 .proto 文件的搜索目录，可以有多个 -I 参数。\n--cpp_out=&lt;out_dir&gt;: 指定生成的 C++ 消息类 (.pb.h, .pb.cc) 的输出目录。\n--grpc_out=&lt;out_dir&gt;: 指定生成的 C++ 服务类 (.grpc.pb.h, .grpc.pb.cc) 的输出目录。\n--plugin=protoc-gen-grpc=&lt;plugin_path&gt;: 指定 grpc_cpp_plugin 可执行文件的路径。\n\n2. 执行生成# gRPC C++ 开发指南GRPC_CPP_PLUGIN_PATH=$(which grpc_cpp_plugin)# gRPC C++ 开发指南protoc -I. --cpp_out=. --grpc_out=. --plugin=protoc-gen-grpc=$GRPC_CPP_PLUGIN_PATH chatter.proto\n这将生成四个文件：chatter.pb.h, chatter.pb.cc, chatter.grpc.pb.h, chatter.grpc.pb.cc。\n3. 自动化脚本 (推荐)在项目中，强烈建议使用脚本来自动化代码生成，以保证一致性。\ngenerate_grpc.sh:\n#!/bin/bashset -e# gRPC C++ 开发指南PROTO_SRC_DIR=&quot;./protos&quot;GENERATED_DIR=&quot;./generated&quot;GRPC_CPP_PLUGIN_PATH=$(which grpc_cpp_plugin)# gRPC C++ 开发指南if [ ! -x &quot;$GRPC_CPP_PLUGIN_PATH&quot; ]; then    echo &quot;Error: grpc_cpp_plugin not found or not executable.&quot;    exit 1fi# gRPC C++ 开发指南echo &quot;Cleaning old generated files...&quot;rm -rf &quot;$GENERATED_DIR&quot;mkdir -p &quot;$GENERATED_DIR&quot;echo &quot;Generating gRPC C++ code from all .proto files in $PROTO_SRC_DIR...&quot;protoc -I &quot;$PROTO_SRC_DIR&quot; \\       --cpp_out=&quot;$GENERATED_DIR&quot; \\       --grpc_out=&quot;$GENERATED_DIR&quot; \\       --plugin=protoc-gen-grpc=&quot;$GRPC_CPP_PLUGIN_PATH&quot; \\       $(find &quot;$PROTO_SRC_DIR&quot; -name &quot;*.proto&quot;)echo &quot;Code generation complete. Files are in $GENERATED_DIR&quot;\n\n第三步：实现服务端(此部分及后续部分与之前版本相同，为简洁省略… 如果需要我可以完整展示)…\n第四步：实现客户端…\n第五步：编译与运行…\n高级主题1. 异步 APIgRPC C++ 提供了一套功能强大的异步 API，这里展示更现代的回调式 (Callback) API。\nasync_client.cpp:\n// ... (includes and using declarations as before)void AsyncClient() &#123;    auto channel = grpc::CreateChannel(&quot;localhost:50051&quot;, grpc::InsecureChannelCredentials());    auto stub = Chatter::NewStub(channel);    MessageRequest request;    request.set_user_name(&quot;AsyncAlice&quot;);    request.set_content(&quot;Hello from async C++!&quot;);    // 1. 创建回调函数    auto on_reply = [](Status status, MessageReply reply) &#123;        if (status.ok()) &#123;            std::cout &lt;&lt; &quot;Async RPC successful. Server says: &quot; &lt;&lt; reply.confirmation_message() &lt;&lt; std::endl;        &#125; else &#123;            std::cout &lt;&lt; &quot;Async RPC failed: &quot; &lt;&lt; status.error_code() &lt;&lt; &quot;: &quot; &lt;&lt; status.error_message() &lt;&lt; std::endl;        &#125;    &#125;;    // 2. 发起异步调用    stub-&gt;async()-&gt;SendMessage(new ClientContext(), &amp;request, new MessageReply(), on_reply);    std::cout &lt;&lt; &quot;Async call initiated. Waiting for reply...&quot; &lt;&lt; std::endl;    // 在实际应用中，你需要一个机制来等待回调完成，例如条件变量或在事件循环中运行。    std::this_thread::sleep_for(std::chrono::seconds(1));&#125;\n\n2. 拦截器 (Interceptor)\n注意: 这是一个实验性 API，未来可能会有变动。\n\n拦截器允许你在 RPC 调用的生命周期中注入自定义逻辑（如日志、认证、监控）。\n#include &lt;grpcpp/experimental/server_interceptor.h&gt;class LoggingInterceptor : public grpc::experimental::Interceptor &#123;public:    void Intercept(grpc::experimental::InterceptorBatchMethods* methods) override &#123;        if (methods-&gt;QueryInterceptionHookPoint(            grpc::experimental::InterceptionHookPoints::PRE_SEND_INITIAL_METADATA)) &#123;            std::cout &lt;&lt; &quot;LOG: Server processing new request.&quot; &lt;&lt; std::endl;        &#125;        // 必须调用 Proceed() 来将控制权交还给 gRPC 框架        methods-&gt;Proceed();    &#125;&#125;;// 在 ServerBuilder 中使用// std::vector&lt;std::unique_ptr&lt;grpc::experimental::ServerInterceptorFactoryInterface&gt;&gt; creators;// creators.push_back(std::make_unique&lt;YourInterceptorFactory&gt;());// builder.experimental().SetInterceptorCreators(std::move(creators));\n\n常见问题Q1: protoc: command not found?A: protoc 不在你的 PATH 中。\n\n如果使用 apt 安装，请确保 protobuf-compiler 已安装。\n如果从源码编译，请确保安装路径的 bin 目录（如 /usr/local/grpc/bin）已添加到 PATH。\n\nQ2: protoc-gen-grpc: program not found or is not executable?A: protoc 找不到 gRPC C++ 插件。\n\n确保 grpc_cpp_plugin 存在于 PATH 中，或者在 --plugin 参数中提供其完整路径。\n检查文件是否有执行权限 (chmod +x &lt;path_to_plugin&gt;)。\n\nQ3: 编译生成的代码时，提示找不到 gRPC 或 Protobuf 头文件?A: 你的编译器找不到所需的头文件。\n\npkg-config (推荐): 确保你的编译命令包含了 $(pkg-config --cflags grpc++ protobuf)。\nCMake: 检查 find_package(gRPC) 和 find_package(Protobuf) 是否成功。如果 gRPC 安装在非标准路径，你可能需要设置 CMAKE_PREFIX_PATH。\n手动编译: 使用 -I/path/to/includes 手动添加正确的包含路径。\n\nQ4: 链接时出现 undefined reference to 错误?A: 链接器找不到 gRPC 或 Protobuf 的库文件。\n\npkg-config (推荐): 确保你的链接命令包含了 $(pkg-config --libs grpc++ protobuf)。\nCMake: 确保 target_link_libraries 指令正确链接了 gRPC::grpc++ 和 protobuf::libprotobuf。\n手动编译: 使用 -L/path/to/libs -lgrpc++ -lprotobuf 手动添加库路径和库。\n\n","categories":["C++核心开发","网络编程与RPC"],"tags":["C++","gRPC","Protobuf","RPC","网络编程","protoc"]},{"title":"Jsoncpp Linux 使用指南","url":"/posts/7ef87112/","content":"Jsoncpp Linux 使用指南目录\n方式一：使用包管理器安装\n方式二：从源码编译 (推荐)\nAPI 核心用法\n编译与运行\n项目集成 (Makefile &amp; CMake)\n常见问题\n\n方式一：使用包管理器安装这是最快的方式，但库版本可能较旧。\n# Jsoncpp Linux 使用指南# Jsoncpp Linux 使用指南sudo apt updatesudo apt install -y libjsoncpp-dev pkg-config# Jsoncpp Linux 使用指南pkg-config --modversion jsoncpp\n\n方式二：从源码编译 (推荐)获取最新版本和完整控制权的推荐方式。\n# Jsoncpp Linux 使用指南sudo apt install -y git cmake build-essential# Jsoncpp Linux 使用指南git clone https://github.com/open-source-parsers/jsoncpp.gitcd jsoncpp# Jsoncpp Linux 使用指南mkdir build &amp;&amp; cd buildcmake ..make -j$(nproc)# Jsoncpp Linux 使用指南sudo make install# Jsoncpp Linux 使用指南sudo ldconfig\n\nAPI 核心用法以下示例展示了 JsonCpp 的核心功能：构建、序列化、解析和读取。\nmain.cpp:\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;json/json.h&gt; // &quot;Umbrella&quot; header for all featuresint main() &#123;    // 1. 构建一个 JSON 对象    Json::Value root;    root[&quot;name&quot;] = &quot;John Doe&quot;;    root[&quot;age&quot;] = 30;    root[&quot;isStudent&quot;] = false;    Json::Value languages;    languages.append(&quot;C++&quot;);    languages.append(&quot;Python&quot;);    root[&quot;languages&quot;] = languages;    // 2. 序列化 (将 JSON 对象转为字符串)        // 2.1 美化输出 (带缩进，适合阅读)    Json::StreamWriterBuilder styledBuilder;    styledBuilder[&quot;indentation&quot;] = &quot;   &quot;; // 3 spaces indentation    const std::string styledOutput = Json::writeString(styledBuilder, root);    std::cout &lt;&lt; &quot;--- Styled JSON ---&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; styledOutput &lt;&lt; std::endl;    // 2.2 紧凑输出 (无格式，适合传输)    Json::StreamWriterBuilder compactBuilder;    compactBuilder[&quot;indentation&quot;] = &quot;&quot;; // No indentation    const std::string compactOutput = Json::writeString(compactBuilder, root);    std::cout &lt;&lt; &quot;\\n--- Compact JSON ---&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; compactOutput &lt;&lt; std::endl;    // 3. 解析 (将字符串转为 JSON 对象)    std::string jsonString = R&quot;(&#123;\\&quot;company\\&quot;: \\&quot;ACME Corp\\&quot;, \\&quot;employees\\&quot;: 100&#125;)&quot; ;    Json::Value parsedRoot;    Json::CharReaderBuilder readerBuilder;    std::string errs;    std::unique_ptr&lt;Json::CharReader&gt; const reader(readerBuilder.newCharReader());    bool parsingSuccessful = reader-&gt;parse(        jsonString.c_str(),        jsonString.c_str() + jsonString.length(),        &amp;parsedRoot,        &amp;errs    );    if (!parsingSuccessful) &#123;        std::cerr &lt;&lt; &quot;Failed to parse JSON: &quot; &lt;&lt; errs &lt;&lt; std::endl;        return 1;    &#125;    // 4. 从解析后的对象中读取数据    std::cout &lt;&lt; &quot;\\n--- Parsed Data ---&quot; &lt;&lt; std::endl;    std::string company = parsedRoot[&quot;company&quot;].asString();    int employees = parsedRoot[&quot;employees&quot;].asInt();    std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Employees: &quot; &lt;&lt; employees &lt;&lt; std::endl;    return 0;&#125;\n\n编译与运行使用 pkg-config (推荐)pkg-config 会自动提供编译器所需的头文件和库文件路径，无需手动指定。\n# Jsoncpp Linux 使用指南g++ main.cpp -o main $(pkg-config --cflags --libs jsoncpp)# Jsoncpp Linux 使用指南./main\n\n项目集成 (Makefile &amp; CMake)Makefile 示例CXX = g++CXXFLAGS = -std=c++14 -Wall -Wall# Jsoncpp Linux 使用指南JSONCPP_FLAGS = $(shell pkg-config --cflags --libs jsoncpp)TARGET = my_appSOURCES = main.cpp.PHONY: all cleanall: $(TARGET)$(TARGET): $(SOURCES)\t$(CXX) $(CXXFLAGS) -o $@ $^ $(JSONCPP_FLAGS)clean:\trm -f $(TARGET)\n\nCMakeLists.txt 示例cmake_minimum_required (VERSION 3.10)project (JsonCppExample)set (CMAKE_CXX_STANDARD 14)# Jsoncpp Linux 使用指南find_package (PkgConfig REQUIRED)# Jsoncpp Linux 使用指南pkg_check_modules (JSONCPP REQUIRED jsoncpp)add_executable (my_app main.cpp)# Jsoncpp Linux 使用指南target_link_libraries (my_app PRIVATE $&#123;JSONCPP_LIBRARIES&#125;)# Jsoncpp Linux 使用指南target_include_directories (my_app PRIVATE $&#123;JSONCPP_INCLUDE_DIRS&#125;)\n\n常见问题Q1: 编译时提示 json/json.h: No such file or directory?A: 这意味着编译器找不到头文件。\n\n确认 libjsoncpp-dev 已安装。\n如果你从源码安装到了非标准路径，请确保在使用 g++ 时通过 -I/path/to/your/include 指定了正确的头文件路径。\n最佳实践是使用 pkg-config，它能避免这类问题。\n\nQ2: 链接时提示 undefined reference to Json::...?A: 这是链接器找不到库文件。\n\n确认编译命令中包含了 -ljsoncpp 或者 $(pkg-config --libs jsoncpp)。\n如果从源码安装，确认库文件 (libjsoncpp.so 或 .a) 存在于链接器可以找到的路径中 (如 /usr/local/lib)。\n\nQ3: 运行时提示 error while loading shared libraries: libjsoncpp.so.X?A: 程序找到了头文件并成功编译，但在运行时找不到动态库。\n\n如果你从源码安装，请确保在 sudo make install 后运行了 sudo ldconfig。\n如果安装在自定义路径，请将该路径添加到 /etc/ld.so.conf.d/ 并再次运行 sudo ldconfig。\n\n","categories":["C++核心开发","系统库与框架"],"tags":["C++","Linux","JsonCpp","JSON","库开发"]},{"title":"Gemini CLI 和 Claude Code 中配置 GitHub MCP 服务器详解","url":"/posts/mcp-github-config/","content":"Gemini CLI 和 Claude Code 中配置 GitHub MCP 服务器详解\n文档创建时间: 2025-12-18最后更新: 2025-12-18标签: github, mcp, gemini-cli, claude-code, http, stdio, ai-tools\n\n📑 目录\n1. MCP传输方式对比\n2. Gemini CLI 的 MCP 配置\n3. Claude Code 的 MCP 配置\n4. 实现差异详解\n5. 最佳实践建议\n6. 故障排除\n7. 性能优化\n8. 总结\n\n\n1. 📖 MCP传输方式对比MCP传输方式对比HTTP vs stdio 传输方式\n\n\n特性\nHTTP传输\nstdio传输\n\n\n\n实现复杂度\n相对简单\n较简单\n\n\n调试便利性\n容易调试（可用curl等工具）\n调试较困难\n\n\n跨平台性\n优秀\n需考虑换行符问题\n\n\n安全考虑\n需要处理认证\n通过stdin&#x2F;stdout通信\n\n\n性能\n有网络开销\n直接进程通信\n\n\n扩展性\n易于集群部署\n单进程限制\n\n\n一、Gemini CLI 的 MCP 配置1.1 HTTP方式配置HTTP方式适合已经实现了REST API的MCP服务器：\n&#123;  &quot;selectedAuthType&quot;: &quot;vertex-ai&quot;,  &quot;theme&quot;: &quot;GitHub&quot;,  &quot;mcpServers&quot;: &#123;    &quot;github-http&quot;: &#123;      &quot;type&quot;: &quot;http&quot;,      &quot;url&quot;: &quot;http://localhost:8080/mcp&quot;,      &quot;headers&quot;: &#123;        &quot;Authorization&quot;: &quot;Bearer $&#123;GITHUB_TOKEN&#125;&quot;,        &quot;Content-Type&quot;: &quot;application/json&quot;      &#125;    &#125;  &#125;&#125;\n\n1.2 stdio方式配置stdio方式适合直接命令行启动的MCP服务器：\n&#123;  &quot;selectedAuthType&quot;: &quot;vertex-ai&quot;,  &quot;theme&quot;: &quot;GitHub&quot;,  &quot;mcpServers&quot;: &#123;    &quot;github-stdio&quot;: &#123;      &quot;type&quot;: &quot;stdio&quot;,      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-github&quot;],      &quot;env&quot;: &#123;        &quot;GITHUB_PERSONAL_ACCESS_TOKEN&quot;: &quot;$&#123;GITHUB_PERSONAL_ACCESS_TOKEN&#125;&quot;      &#125;    &#125;  &#125;&#125;\n\n1.3 混合配置示例同时支持两种传输方式：\n&#123;  &quot;selectedAuthType&quot;: &quot;vertex-ai&quot;,  &quot;theme&quot;: &quot;GitHub&quot;,  &quot;mcpServers&quot;: &#123;    &quot;github&quot;: &#123;      &quot;type&quot;: &quot;stdio&quot;,      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-github&quot;],      &quot;env&quot;: &#123;        &quot;GITHUB_PERSONAL_ACCESS_TOKEN&quot;: &quot;$&#123;GITHUB_PERSONAL_ACCESS_TOKEN&#125;&quot;      &#125;    &#125;,    &quot;github-fallback&quot;: &#123;      &quot;type&quot;: &quot;http&quot;,      &quot;url&quot;: &quot;http://localhost:8080/github-mcp&quot;,      &quot;headers&quot;: &#123;        &quot;Authorization&quot;: &quot;Bearer $&#123;GITHUB_TOKEN&#125;&quot;      &#125;    &#125;  &#125;&#125;\n\n二、Claude Code 的 MCP 配置2.1 配置文件位置Claude Code支持多个配置文件位置：\n\n用户级配置：~/.claude/claude_desktop_config.json\n项目级配置：.claude/claude_desktop_config.json\n临时配置：./mcp.json\n\n2.2 HTTP方式配置&#123;  &quot;mcpServers&quot;: &#123;    &quot;github-api&quot;: &#123;      &quot;type&quot;: &quot;http&quot;,      &quot;url&quot;: &quot;https://api.github.com/mcp&quot;,      &quot;headers&quot;: &#123;        &quot;Authorization&quot;: &quot;Bearer $&#123;GITHUB_TOKEN&#125;&quot;,        &quot;X-GitHub-API-Version&quot;: &quot;2022-11-28&quot;      &#125;    &#125;  &#125;&#125;\n\n2.3 stdio方式配置&#123;  &quot;mcpServers&quot;: &#123;    &quot;github-cli&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-github&quot;],      &quot;env&quot;: &#123;        &quot;GITHUB_PERSONAL_ACCESS_TOKEN&quot;: &quot;$&#123;GITHUB_PERSONAL_ACCESS_TOKEN&#125;&quot;      &#125;    &#125;  &#125;&#125;\n\n2.4 使用CLI命令添加MCPClaude Code提供了便捷的CLI命令：\n# 添加HTTP类型的MCP服务器claude mcp add --transport http \\  --name github-api \\  --url https://api.github.com/mcp \\  --env GITHUB_TOKEN=&quot;$&#123;GITHUB_TOKEN&#125;&quot;# 添加stdio类型的MCP服务器claude mcp add --transport stdio \\  --name github-cli \\  --command npx \\  --args &quot;-y&quot; &quot;@modelcontextprotocol/server-github&quot; \\  --env GITHUB_PERSONAL_ACCESS_TOKEN=&quot;$&#123;GITHUB_PERSONAL_ACCESS_TOKEN&#125;&quot;\n\n三、实现差异详解3.1 服务器端实现HTTP服务器示例# github_mcp_http_server.pyfrom http.server import HTTPServer, BaseHTTPRequestHandlerimport jsonimport subprocessclass GitHubMCPHandler(BaseHTTPRequestHandler):    def do_POST(self):        content_length = int(self.headers[&#x27;Content-Length&#x27;])        post_data = self.rfile.read(content_length)        # 处理MCP请求        response = self.handle_mcp_request(json.loads(post_data))        self.send_response(200)        self.send_header(&#x27;Content-type&#x27;, &#x27;application/json&#x27;)        self.end_headers()        self.wfile.write(json.dumps(response).encode())def handle_mcp_request(self, request):    # 实现MCP协议逻辑    if request.get(&#x27;method&#x27;) == &#x27;tools/list&#x27;:        return &#123;&#x27;tools&#x27;: list_available_tools()&#125;    elif request.get(&#x27;method&#x27;) == &#x27;tools/call&#x27;:        return execute_tool_call(request)    return &#123;&#125;if __name__ == &#x27;__main__&#x27;:    server = HTTPServer((&#x27;localhost&#x27;, 8080), GitHubMCPHandler)    server.serve_forever()\n\nstdio服务器示例# github_mcp_stdio_server.pyimport sysimport jsondef main():    while True:        try:            line = sys.stdin.readline()            if not line:                break            request = json.loads(line.strip())            response = handle_mcp_request(request)            print(json.dumps(response))            sys.stdout.flush()        except Exception as e:            error_response = &#123;                &#x27;error&#x27;: &#123;                    &#x27;code&#x27;: -32603,                    &#x27;message&#x27;: str(e)                &#125;            print(json.dumps(error_response))            sys.stdout.flush()if __name__ == &#x27;__main__&#x27;:    main()\n\n3.2 认证处理差异HTTP认证&#123;  &quot;headers&quot;: &#123;    &quot;Authorization&quot;: &quot;Bearer $&#123;GITHUB_TOKEN&#125;&quot;,    &quot;X-API-Key&quot;: &quot;$&#123;API_KEY&#125;&quot;  &#125;&#125;\n\nstdio认证&#123;  &quot;env&quot;: &#123;    &quot;GITHUB_PERSONAL_ACCESS_TOKEN&quot;: &quot;$&#123;GITHUB_PERSONAL_ACCESS_TOKEN&#125;&quot;,    &quot;API_KEY&quot;: &quot;$&#123;API_KEY&#125;&quot;  &#125;&#125;\n\n四、最佳实践建议4.1 选择传输方式的考虑因素\n开发阶段：使用stdio，便于调试\n生产环境：使用HTTP，便于监控和扩展\n网络环境：受限环境可能需要stdio\n性能要求：高频调用使用stdio\n\n4.2 错误处理策略&#123;  &quot;mcpServers&quot;: &#123;    &quot;github&quot;: &#123;      &quot;type&quot;: &quot;stdio&quot;,      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-github&quot;],      &quot;env&quot;: &#123;        &quot;GITHUB_PERSONAL_ACCESS_TOKEN&quot;: &quot;$&#123;GITHUB_PERSONAL_ACCESS_TOKEN&#125;&quot;,        &quot;NODE_ENV&quot;: &quot;production&quot;      &#125;,      &quot;retries&quot;: 3,      &quot;timeout&quot;: 30000    &#125;,    &quot;github-backup&quot;: &#123;      &quot;type&quot;: &quot;http&quot;,      &quot;url&quot;: &quot;http://backup-server:8080/mcp&quot;,      &quot;fallback&quot;: true    &#125;  &#125;&#125;\n\n4.3 安全考虑\n令牌管理：\n\n使用环境变量，避免硬编码\n定期轮换访问令牌\n使用最小权限原则\n\n\n网络安全：\n\nHTTP方式使用HTTPS\n验证服务器证书\n限制访问来源\n\n\n数据保护：\n\n敏感数据脱敏\n日志记录控制\n临时文件清理\n\n\n\n五、故障排除5.1 常见问题\n连接超时\n&#123;  &quot;timeout&quot;: 60000,  &quot;retries&quot;: 5,  &quot;retryDelay&quot;: 1000&#125;\n\n认证失败\n\n检查环境变量设置\n验证令牌有效性\n确认权限配置\n\n\n通信错误\n\nstdio：检查换行符（\\n vs \\r\\n）\nHTTP：检查Content-Type头\n\n\n\n5.2 调试技巧HTTP方式调试# 测试连接curl -X POST http://localhost:8080/mcp \\  -H &quot;Content-Type: application/json&quot; \\  -H &quot;Authorization: Bearer $GITHUB_TOKEN&quot; \\  -d &#x27;&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;tools/list&quot;&#125;&#x27;\n\nstdio方式调试# 手动测试echo &#x27;&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;tools/list&quot;&#125;&#x27; | npx -y @modelcontextprotocol/server-github\n\n六、性能优化6.1 HTTP优化&#123;  &quot;headers&quot;: &#123;    &quot;Connection&quot;: &quot;keep-alive&quot;,    &quot;Keep-Alive&quot;: &quot;timeout=60, max=100&quot;  &#125;,  &quot;timeout&quot;: 30000&#125;\n\n6.2 stdio优化# 批量处理请求def batch_process_requests(requests):    results = []    for request in requests:        results.append(handle_request(request))    return results\n\n七、总结HTTP和stdio两种传输方式各有优势：\n\nHTTP：易于调试、扩展性好、适合分布式部署\nstdio：性能高、实现简单、适合本地开发\n\n根据实际需求选择合适的传输方式，并做好错误处理和安全防护。通过合理的配置和优化，可以在Gemini CLI和Claude Code中稳定地使用GitHub MCP服务器，提升开发效率。\n参考资料\nModel Context Protocol官方文档\nGemini CLI文档\nClaude Code文档\n\n","categories":["开发工具"],"tags":["技术文档","指南"]},{"title":"Gemini CLI 在国内网络环境下的完整配置指南","url":"/posts/gemini-cli-proxy/","content":"Gemini CLI 在国内网络环境下的完整配置指南\n文档创建时间: 2025-12-18最后更新: 2025-12-18标签: gemini-cli, proxy, vpn, network, ai-tools, 跨域访问\n\n📑 目录\n1. 概述\n2. 系统要求\n3. 环境准备\n4. Gemini CLI 安装配置\n5. 代理配置\n6. 认证流程\n7. 常见问题与解决方案\n8. 最佳实践\n9. 验证测试\n10. 总结\n\n\n1. 📖 概述本文档提供了一套完整的 Gemini CLI 在国内网络环境下的配置解决方案，通过代理服务和 VPN 组合，实现稳定的 Google 服务访问。\n2. ⚙️ 系统要求系统要求基础环境\n\n\n组件\n最低版本\n推荐版本\n验证方法\n\n\n\nNode.js\nv18.x\nv20.x+\nnode --version\n\n\nnpm\nv9.x\nv10.x+\nnpm --version\n\n\n操作系统\nWindows 10+\nWindows 11&#x2F;macOS&#x2F;Linux\n系统信息\n\n\n网络环境代理服务要求\n\n\n要求项\n规格\n说明\n\n\n\n协议支持\n✅ HTTPS\n必须支持 SSL&#x2F;TLS\n\n\n端口配置\n✅ 自定义端口\n支持常用端口（7890, 7890, 10808等）\n\n\n连接稳定性\n✅ 高可用\n99%+ 连接成功率\n\n\n带宽要求\n✅ &gt; 1Mbps\n满足 API 调用需求\n\n\nVPN 服务要求\n\n\n要求项\n规格\n说明\n\n\n\n地理位置\n⚠️ 美国节点推荐\n避免地理位置限制\n\n\n协议支持\n✅ OpenVPN&#x2F;WireGuard\n确保兼容性\n\n\nDNS 保护\n✅ DNS leak防护\n防止 DNS 泄露\n\n\nKill Switch\n✅ 自动断网保护\n意外断开时保护隐私\n\n\n环境准备Node.js 安装Windows 安装\n访问 Node.js 官网\n下载 Windows 安装包（.msi）\n运行安装程序，勾选 “Add to PATH”\n验证安装：\n\nnode --versionnpm --version\n\nmacOS 安装# 使用 Homebrewbrew install node# 或下载官方安装包\n\nLinux 安装# Ubuntu/Debiancurl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -sudo apt-get install -y nodejs# 或使用 NodeSource\n\n网络连接测试# 测试 Google 可访问性curl -I https://google.com# 测试特定服务器连通性ping 216.239.32.223# 测试 HTTPS 代理curl -x http://127.0.0.1:7890 https://www.google.com\n\nGemini CLI 安装配置全局安装# 标准安装命令npm install -g @google/gemini-cli# 验证安装gemini --version# 查看帮助信息gemini --help# 测试调试模式gemini -d --help\n\n安装验证# 验证 npm 包安装npm list -g @google/gemini-cli# 检查可执行文件where gemini  # Windowswhich gemini   # macOS/Linux# 测试基本功能gemini --version\n\n代理配置环境变量配置Windows 系统CMD 环境：\nrem 设置 HTTP 代理（换成你自己的代理地址）set HTTP_PROXY=http://127.0.0.1:7890set HTTPS_PROXY=https://127.0.0.1:7890rem 验证设置echo %HTTP_PROXY%echo %HTTPS_PROXY%\n\nPowerShell 环境：\n# 设置代理环境变量$env:HTTP_PROXY=&quot;http://127.0.0.1:7890&quot;$env:HTTPS_PROXY=&quot;https://127.0.0.1:7890&quot;# 验证设置$env:HTTP_PROXY$env:HTTPS_PROXY\n\nmacOS&#x2F;Linux 系统# Bash/Zsh 环境export HTTP_PROXY=http://127.0.0.1:7890export HTTPS_PROXY=https://127.0.0.1:7890# 验证设置echo $HTTP_PROXYecho $HTTPS_PROXY# 添加到配置文件（永久生效）echo &#x27;export HTTP_PROXY=http://127.0.0.1:7890&#x27; &gt;&gt; ~/.bashrcecho &#x27;export HTTPS_PROXY=https://127.0.0.1:7890&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc\n\n代理排除设置# Windows CMDset NO_PROXY=localhost,127.0.0.1,.local# Windows PowerShell$env:NO_PROXY=&quot;localhost,127.0.0.1,.local&quot;# macOS/Linuxexport NO_PROXY=localhost,127.0.0.1,.local\n\n代理服务配置示例Clash 配置# Gemini CLI 专用规则rules:  # Google 相关域名走代理  - &#x27;DOMAIN-SUFFIX,googleapis.com,🔰 节点选择&#x27;  - &#x27;DOMAIN-SUFFIX,google.com,🔰 节点选择&#x27;  - &#x27;DOMAIN,generativelanguage.googleapis.com,🔰 节点选择&#x27;  - &#x27;DOMAIN,aistudio.google.com,🔰 节点选择&#x27;  # Gemini CLI 进程走代理  - &#x27;PROCESS-NAME,gemini,🔰 节点选择&#x27;proxy-groups:  - name: 🔰 节点选择    type: select    proxies:      - 美国节点1      - 美国节点2      - 美国节点3\n\n认证流程启动 Gemini CLI# 基础启动gemini# 调试模式启动gemini -d# 指定模型启动gemini --model=gemini-1.5-flash\n\n认证步骤\nGemini CLI 会自动打开浏览器进行 OAuth 认证\n登录 Google 账号\n授权 Gemini CLI 访问权限\n浏览器会跳转回本地端口（通常为 localhost:11101）\nCLI 确认认证成功\n\n常见问题与解决方案连接超时问题症状：\n\n终端显示 “Waiting for auth…” 后自动退出\n浏览器授权成功但 CLI 连接失败\n错误日志显示 AggregateError [ETIMEDOUT]\n\n解决步骤：\n# 1. 启用调试模式gemini -d# 2. 检查代理设置echo $HTTPS_PROXY  # Linux/macOSecho %HTTPS_PROXY%  # Windows# 3. 测试网络连通性curl -x $HTTPS_PROXY https://google.com# 4. 检查特定服务器curl -x $HTTPS_PROXY https://216.239.32.223# 5. 测试 DNS 解析nslookup google.com 8.8.8.8\n\n认证授权问题检查清单：\n\n 防火墙是否阻止 localhost:11101\n 杀毒软件是否拦截 Gemini CLI\n 代理是否支持 WebSocket 连接\n 浏览器是否允许重定向\n\n环境变量问题验证方法：\n# 检查当前环境变量env | grep -i proxy  # Linux/macOSset | findstr PROXY     # Windows# 测试代理连接curl -v -x $HTTPS_PROXY https://httpbin.org/ip\n\n解决方案# 临时设置（当前会话有效）export HTTPS_PROXY=http://127.0.0.1:7890# 永久设置（写入配置文件）echo &#x27;export HTTPS_PROXY=http://127.0.0.1:7890&#x27; &gt;&gt; ~/.profilesource ~/.profile# 系统级设置（需要管理员权限）sudo tee /etc/environment &gt; /dev/null &lt;&lt;EOFHTTPS_PROXY=http://127.0.0.1:7890HTTP_PROXY=http://127.0.0.1:7890NO_PROXY=localhost,127.0.0.1,.localEOF\n\n最佳实践性能优化节点评估标准\n\n\n指标\n优秀\n良好\n可接受\n\n\n\n延迟\n&lt; 100ms\n100-200ms\n200-500ms\n\n\n稳定性\n99.9%+\n99%+\n95%+\n\n\n带宽\n&gt; 10Mbps\n5-10Mbps\n&gt; 1Mbps\n\n\n成功率\n100%\n99%+\n95%+\n\n\n自动切换配置# Clash 配置示例proxy-groups:  - name: &quot;Auto-Best-Proxy&quot;    type: url-test    url: &quot;http://www.gstatic.com/generate_204&quot;    interval: 300    tolerance: 50    use:      - proxy-nodes\n\n安全策略网络安全\n选择可信服务商：避免使用免费或不稳定的代理服务\n加密通信：确保代理支持 HTTPS 协议\n日志审计：定期检查代理连接日志\n访问控制：限制代理服务的访问权限\n\n账号安全\n两步验证：为 Google 账号启用 2FA\n应用密码：使用应用专用密码而非主密码\n定期审查：检查授权的应用列表\n安全监控：监控异常登录活动\n\n验证测试基础环境验证# 测试基础连接curl -I https://www.google.com# 测试代理连接curl -x $HTTPS_PROXY -I https://www.google.com# 测试特定服务器curl -x $HTTPS_PROXY -I https://216.239.32.223# 测试 API 端点curl -x $HTTPS_PROXY https://generativelanguage.googleapis.com\n\n端到端测试脚本#!/bin/bash# Gemini CLI 认证测试脚本echo &quot;开始 Gemini CLI 认证测试...&quot;# 1. 检查环境变量if [ -z &quot;$HTTPS_PROXY&quot; ]; then    echo &quot;❌ 代理环境变量未设置&quot;    exit 1fiecho &quot;✅ 代理环境变量: $HTTPS_PROXY&quot;# 2. 测试网络连接if ! curl -s -x &quot;$HTTPS_PROXY&quot; https://www.google.com &gt; /dev/null; then    echo &quot;❌ 代理连接失败&quot;    exit 1fiecho &quot;✅ 代理连接正常&quot;# 3. 启动调试模式echo &quot;启动 Gemini CLI 调试模式...&quot;timeout 30 gemini -d &amp;GEMINI_PID=$!# 4. 等待认证完成sleep 5# 5. 检查进程状态if kill -0 $GEMINI_PID 2&gt;/dev/null; then    echo &quot;✅ Gemini CLI 进程运行中&quot;    echo &quot;请完成浏览器认证流程&quot;    wait $GEMINI_PID    echo &quot;✅ 认证流程完成&quot;else    echo &quot;❌ Gemini CLI 进程异常退出&quot;fi\n\n总结本文档提供了一套完整的 Gemini CLI 在国内网络环境下的配置解决方案，涵盖了从环境准备到最终验证的完整流程。\n关键成功因素\n代理服务稳定性：选择可靠的代理服务提供商\n环境变量配置：正确设置 HTTPS_PROXY 和相关环境变量\n网络兼容性：确保代理服务支持 HTTPS 协议和 WebSocket 连接\n系统权限配置：正确配置防火墙和杀毒软件\n\n通过遵循本文档的指导原则和最佳实践，用户可以在国内网络环境中稳定、高效地使用 Gemini CLI，享受 Google AI 技术带来的便利和强大功能。\n","categories":["开发工具"],"tags":["技术文档","指南"]},{"title":"Graphviz 流程图指南","url":"/posts/445c44cb/","content":"Graphviz 流程图指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: graphviz, flowchart, diagram, visualization, documentation\n\n📑 目录\n1. 概述\n2. 环境准备\n3. 基本使用\n4. 输出格式\n5. 常见用例\n6. 高级配置\n\n\n1. 📖 概述Graphviz 是一个开源的图形可视化软件，特别适合生成各种流程图、架构图和关系图。\n🎯 主要用途\n✅ 流程图生成\n✅ 系统架构图\n✅ 类关系图\n✅ 依赖关系图\n✅ 状态机图\n\n\n2. 🔧 环境准备2.1 安装依赖# Graphviz 流程图指南pip install graphviz# Graphviz 流程图指南conda install python-graphviz# Graphviz 流程图指南sudo apt-get install graphviz\n\n2.2 验证安装import graphviz# Graphviz 流程图指南dot = graphviz.Digraph(comment=&#x27;Test Graph&#x27;)dot.node(&#x27;A&#x27;, &#x27;Test Node&#x27;)print(dot.source)  # 输出 DOT 源码\n\n\n3. 🚀 基本使用3.1 生成流程图# Graphviz 流程图指南python drogon_flow_diagram.py\n\n3.2 基本示例from graphviz import Digraph# Graphviz 流程图指南dot = Digraph(comment=&#x27;Simple Flowchart&#x27;)dot.attr(rankdir=&#x27;LR&#x27;)  # 从左到右布局# Graphviz 流程图指南dot.node(&#x27;A&#x27;, &#x27;开始&#x27;)dot.node(&#x27;B&#x27;, &#x27;处理&#x27;)dot.node(&#x27;C&#x27;, &#x27;结束&#x27;)# Graphviz 流程图指南dot.edges([&#x27;AB&#x27;, &#x27;BC&#x27;])# Graphviz 流程图指南dot.render(&#x27;flowchart&#x27;, format=&#x27;png&#x27;, cleanup=True)\n\n\n4. 📁 输出格式生成的文件包括：\n\n\n\n文件名\n格式\n说明\n\n\n\ndrogon_http_flow.png\nPNG\n位图格式，适合网页显示\n\n\ndrogon_http_flow.svg\nSVG\n矢量图，可缩放\n\n\ndrogon_http_flow.pdf\nPDF\n适合打印和文档\n\n\ndrogon_http_flow.dot\nDOT\nGraphviz 源码\n\n\n\n5. 💡 常见用例5.1 系统架构图dot = Digraph(comment=&#x27;System Architecture&#x27;)dot.attr(rankdir=&#x27;TB&#x27;)# Graphviz 流程图指南with dot.subgraph(name=&#x27;cluster_frontend&#x27;) as c:    c.attr(label=&#x27;Frontend&#x27;)    c.node(&#x27;web&#x27;, &#x27;Web App&#x27;)with dot.subgraph(name=&#x27;cluster_backend&#x27;) as c:    c.attr(label=&#x27;Backend&#x27;)    c.node(&#x27;api&#x27;, &#x27;API Server&#x27;)    c.node(&#x27;db&#x27;, &#x27;Database&#x27;)# Graphviz 流程图指南dot.edge(&#x27;web&#x27;, &#x27;api&#x27;)dot.edge(&#x27;api&#x27;, &#x27;db&#x27;)\n\n5.2 类关系图dot = Digraph(comment=&#x27;Class Diagram&#x27;)dot.attr(rankdir=&#x27;TB&#x27;)# Graphviz 流程图指南dot.node(&#x27;Base&#x27;, &#x27;Base Class&#x27;, shape=&#x27;record&#x27;)dot.node(&#x27;Derived&#x27;, &#x27;Derived Class&#x27;, shape=&#x27;record&#x27;)# Graphviz 流程图指南dot.edge(&#x27;Base&#x27;, &#x27;Derived&#x27;, arrowhead=&#x27;empty&#x27;)\n\n\n6. ⚙️ 高级配置6.1 样式定制dot.attr(&#x27;node&#x27;, shape=&#x27;box&#x27;, style=&#x27;rounded,filled&#x27;, fillcolor=&#x27;lightblue&#x27;)dot.attr(&#x27;edge&#x27;, color=&#x27;darkblue&#x27;, fontcolor=&#x27;darkblue&#x27;)\n\n6.2 子图组织with dot.subgraph(name=&#x27;cluster_module1&#x27;) as c:    c.attr(label=&#x27;Module 1&#x27;, style=&#x27;filled&#x27;, color=&#x27;lightgrey&#x27;)    c.node(&#x27;m1_a&#x27;, &#x27;Component A&#x27;)    c.node(&#x27;m1_b&#x27;, &#x27;Component B&#x27;)\n\n\n📚 相关资源\nGraphviz 官方文档\nPython graphviz 库\nDOT 语言指南\n\n\n\n💡 提示: Graphviz 特别适合生成技术文档中的架构图和流程图，建议与其他文档生成工具配合使用。\n\n","categories":["开发工具"],"tags":["技术文档","指南"]},{"title":"VSCode Qt MSVC 配置指南","url":"/posts/55a960b4/","content":"VSCode Qt MSVC 配置指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: vscode, qt, msvc, cmake, windows, development, cpp\n\n📑 目录\n1. 概述\n2. 环境准备\n3. VS Code 配置\n3.1 C&#x2F;C++ 扩展配置\n3.2 调试器配置\n3.3 构建任务配置\n3.4 Qt 可视化调试\n\n\n4. CMake 配置\n5. 环境验证\n6. 常见问题解决\n7. 完整工作流程\n\n\n1. 📖 概述本指南详细介绍如何在 Windows 系统上配置 VS Code 进行 Qt C++ 开发，使用 MSVC 编译器和 CMake 构建系统。\n🎯 配置目标\n✅ 使用 MSVC 编译器进行 Qt 开发\n✅ VS Code 完整的 IntelliSense 支持\n✅ 集成的调试和构建功能\n✅ 跨平台 CMake 构建系统\n\n🏗️ 系统架构graph TB    A[VS Code IDE] --&gt; B[C/C++ Extension]    A --&gt; C[CMake Tools Extension]    A --&gt; D[Qt Extension]    B --&gt; E[IntelliSense Engine]    C --&gt; F[CMake Configuration]    D --&gt; G[Qt Tools Integration]    E --&gt; H[MSVC Compiler]    F --&gt; I[Build System]    G --&gt; J[Qt Libraries]    H --&gt; K[cl.exe]    I --&gt; L[cmake.exe]    J --&gt; M[Qt5/Qt6]\n\n\n2. 🔧 环境准备2.1 必需组件\n\n\n组件\n版本要求\n下载地址\n\n\n\nVisual Studio Build Tools\n2019&#x2F;2022\nMicrosoft官网\n\n\nQt\n5.6.3+ &#x2F; 6.x\nQt官网\n\n\nCMake\n3.15+\nCMake官网\n\n\nVS Code\n最新版\nVS Code官网\n\n\n2.2 VS Code 扩展安装# VSCode Qt MSVC 配置指南code --install-extension ms-vscode.cpptoolscode --install-extension ms-vscode.cmake-toolscode --install-extension ms-vscode.cpptools-extension-pack# VSCode Qt MSVC 配置指南code --install-extension twxs.cmakecode --install-extension ms-vscode.hexeditor\n\n\n3. ⚙️ VS Code 配置3.1 🧠 C&#x2F;C++ 扩展配置创建 .vscode/c_cpp_properties.json：\n&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Win32-MSVC&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;/**&quot;,                // MSVC 标准库路径                &quot;$&#123;env.VCToolsInstallDir&#125;include&quot;,                // Windows SDK 路径                &quot;$&#123;env.WindowsSdkDir&#125;Include/$&#123;env.WindowsSDKVersion&#125;/**&quot;,                // Qt 包含路径（修改为你的实际路径）                &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/include/**&quot;,                &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/include/QtCore&quot;,                &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/include/QtWidgets&quot;,                &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/include/QtGui&quot;,                // 添加其他需要的 Qt 模块                &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/include/QtNetwork&quot;            ],            &quot;defines&quot;: [                &quot;_DEBUG&quot;,                &quot;UNICODE&quot;,                &quot;_UNICODE&quot;,                // Qt 相关定义                &quot;QT_CORE_LIB&quot;,                &quot;QT_WIDGETS_LIB&quot;,                &quot;QT_GUI_LIB&quot;,                &quot;QT_NETWORK_LIB&quot;,                &quot;_WIN32_WINNT=0x0601&quot;  // Windows 7+            ],            &quot;compilerPath&quot;: &quot;C:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/14.29.30133/bin/Hostx64/x64/cl.exe&quot;,            &quot;cStandard&quot;: &quot;c17&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;windows-msvc-x64&quot;,            &quot;windowsSdkVersion&quot;: &quot;10.0.19041.0&quot;,            &quot;compileCommands&quot;: &quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;        &#125;    ],    &quot;version&quot;: 4&#125;\n\n⚙️ 关键配置说明：\n\n\n\n配置项\n说明\n示例值\n\n\n\ncompilerPath\nMSVC 编译器路径\ncl.exe 完整路径\n\n\nintelliSenseMode\nIntelliSense 引擎\nwindows-msvc-x64\n\n\nincludePath\n头文件搜索路径\nQt 和 MSVC 包含目录\n\n\ndefines\n预处理器宏定义\nQt 模块和 Windows 宏\n\n\n3.2 🐛 调试器配置创建 .vscode/launch.json：\n&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Debug Qt App (MSVC)&quot;,            &quot;type&quot;: &quot;cppvsdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/Debug/MyQtApp.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [                &#123;                    &quot;name&quot;: &quot;PATH&quot;,                    &quot;value&quot;: &quot;$&#123;env:Path&#125;;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/bin;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/plugins/platforms&quot;                &#125;,                &#123;                    &quot;name&quot;: &quot;QT_DEBUG_PLUGINS&quot;,                    &quot;value&quot;: &quot;1&quot;                &#125;            ],            &quot;console&quot;: &quot;externalTerminal&quot;,            &quot;visualizerFile&quot;: &quot;$&#123;workspaceFolder&#125;/.vscode/qt.natvis&quot;,            &quot;preLaunchTask&quot;: &quot;cmake: build debug&quot;,            &quot;postDebugTask&quot;: &quot;cmake: clean&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;Release Qt App (MSVC)&quot;,            &quot;type&quot;: &quot;cppvsdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/Release/MyQtApp.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [                &#123;                    &quot;name&quot;: &quot;PATH&quot;,                    &quot;value&quot;: &quot;$&#123;env:Path&#125;;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/bin&quot;                &#125;            ],            &quot;console&quot;: &quot;externalTerminal&quot;,            &quot;preLaunchTask&quot;: &quot;cmake: build release&quot;        &#125;    ]&#125;\n\n🔍 调试配置要点：\n\n调试器类型: 使用 cppvsdbg (MSVC 原生调试器)\n环境变量: 确保 Qt DLL 和插件路径在 PATH 中\n程序路径: Debug 和 Release 版本的正确路径\n调试插件: QT_DEBUG_PLUGINS=1 用于调试 Qt 插件问题\n\n3.3 🔨 构建任务配置创建 .vscode/tasks.json：\n&#123;    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        &#123;            &quot;label&quot;: &quot;cmake: configure&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;cmake&quot;,            &quot;args&quot;: [                &quot;-B&quot;, &quot;build&quot;,                &quot;-G&quot;, &quot;Visual Studio 16 2019&quot;,                &quot;-A&quot;, &quot;x64&quot;,                &quot;-DCMAKE_BUILD_TYPE=Debug&quot;,                &quot;-DCMAKE_PREFIX_PATH=C:/Qt/Qt5.6.3/5.6.3/msvc2015_64&quot;            ],            &quot;group&quot;: &quot;build&quot;,            &quot;problemMatcher&quot;: [],            &quot;detail&quot;: &quot;配置 CMake 项目&quot;        &#125;,        &#123;            &quot;label&quot;: &quot;cmake: build debug&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;cmake&quot;,            &quot;args&quot;: [                &quot;--build&quot;, &quot;build&quot;,                &quot;--config&quot;, &quot;Debug&quot;,                &quot;--parallel&quot;            ],            &quot;group&quot;: &#123;                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;: true            &#125;,            &quot;problemMatcher&quot;: [&quot;$msCompile&quot;],            &quot;detail&quot;: &quot;构建 Debug 版本&quot;,            &quot;dependsOn&quot;: [&quot;cmake: configure&quot;]        &#125;,        &#123;            &quot;label&quot;: &quot;cmake: build release&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;cmake&quot;,            &quot;args&quot;: [                &quot;--build&quot;, &quot;build&quot;,                &quot;--config&quot;, &quot;Release&quot;,                &quot;--parallel&quot;            ],            &quot;group&quot;: &quot;build&quot;,            &quot;problemMatcher&quot;: [&quot;$msCompile&quot;],            &quot;detail&quot;: &quot;构建 Release 版本&quot;        &#125;,        &#123;            &quot;label&quot;: &quot;cmake: clean&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;cmake&quot;,            &quot;args&quot;: [                &quot;--build&quot;, &quot;build&quot;,                &quot;--target&quot;, &quot;clean&quot;            ],            &quot;group&quot;: &quot;build&quot;,            &quot;problemMatcher&quot;: [],            &quot;detail&quot;: &quot;清理构建文件&quot;        &#125;,        &#123;            &quot;label&quot;: &quot;cmake: install qt dlls&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;powershell&quot;,            &quot;args&quot;: [                &quot;-Command&quot;,                &quot;Copy-Item &#x27;C:\\\\Qt\\\\Qt5.6.3\\\\5.6.3\\\\msvc2015_64\\\\bin\\\\*.dll&#x27; &#x27;build\\\\Debug\\\\&#x27; -Force; Copy-Item &#x27;C:\\\\Qt\\\\Qt5.6.3\\\\5.6.3\\\\msvc2015_64\\\\plugins\\\\platforms\\\\qwindows.dll&#x27; &#x27;build\\\\Debug\\\\platforms\\\\&#x27; -Force&quot;            ],            &quot;group&quot;: &quot;build&quot;,            &quot;problemMatcher&quot;: [],            &quot;detail&quot;: &quot;复制 Qt 运行时 DLL&quot;        &#125;    ]&#125;\n\n3.4 🎨 Qt 可视化调试创建 .vscode/qt.natvis 文件用于 Qt 类型可视化：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;AutoVisualizer xmlns=&quot;http://schemas.microsoft.com/vstudio/debugger/natvis/2010&quot;&gt;  &lt;Type Name=&quot;QString&quot;&gt;    &lt;DisplayString&gt;&#123;&#123; &#123;reinterpret_cast&lt;const wchar_t*&gt;(d-&gt;data()), d-&gt;size&#125; &#125;&#125;&lt;/DisplayString&gt;    &lt;StringView&gt;d-&gt;data(),d-&gt;size,utf-16&lt;/StringView&gt;    &lt;Expand&gt;      &lt;Item Name=&quot;[size]&quot;&gt;d-&gt;size&lt;/Item&gt;      &lt;Item Name=&quot;[raw]&quot;&gt;d-&gt;data(),d-&gt;size&lt;/Item&gt;    &lt;/Expand&gt;  &lt;/Type&gt;  &lt;Type Name=&quot;QByteArray&quot;&gt;    &lt;DisplayString&gt;&#123;&#123; &#123;d-&gt;data(),d-&gt;size&#125; &#125;&#125;&lt;/DisplayString&gt;    &lt;StringView&gt;d-&gt;data(),d-&gt;size&lt;/StringView&gt;    &lt;Expand&gt;      &lt;Item Name=&quot;[size]&quot;&gt;d-&gt;size&lt;/Item&gt;      &lt;ArrayItems&gt;        &lt;Size&gt;d-&gt;size&lt;/Size&gt;        &lt;ValuePointer&gt;d-&gt;data()&lt;/ValuePointer&gt;      &lt;/ArrayItems&gt;    &lt;/Expand&gt;  &lt;/Type&gt;  &lt;Type Name=&quot;QList&amp;lt;*&amp;gt;&quot;&gt;    &lt;DisplayString&gt;&#123;&#123; size=&#123;d-&gt;size&#125; &#125;&#125;&lt;/DisplayString&gt;    &lt;Expand&gt;      &lt;Item Name=&quot;[size]&quot;&gt;d-&gt;size&lt;/Item&gt;      &lt;ArrayItems&gt;        &lt;Size&gt;d-&gt;size&lt;/Size&gt;        &lt;ValuePointer&gt;e&lt;/ValuePointer&gt;      &lt;/ArrayItems&gt;    &lt;/Expand&gt;  &lt;/Type&gt;&lt;/AutoVisualizer&gt;\n\n\n4. 📦 CMake 配置4.1 📄 CMakeLists.txtcmake_minimum_required(VERSION 3.15)project(MyQtApp LANGUAGES CXX)# VSCode Qt MSVC 配置指南set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)# VSCode Qt MSVC 配置指南if(MSVC)    # 设置运行时库    set(CMAKE_MSVC_RUNTIME_LIBRARY &quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;DLL&quot;)    # 启用并行编译    add_compile_options(/MP)    # 警告设置    add_compile_options(/W3)    # 禁用一些 MSVC 警告    add_compile_definitions(_CRT_SECURE_NO_WARNINGS)endif()# VSCode Qt MSVC 配置指南set(CMAKE_PREFIX_PATH &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64&quot;)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTORCC ON)# VSCode Qt MSVC 配置指南find_package(Qt5 COMPONENTS Core Widgets Gui Network REQUIRED)# VSCode Qt MSVC 配置指南file(GLOB_RECURSE SOURCES    &quot;src/*.cpp&quot;    &quot;src/*.h&quot;    &quot;src/*.ui&quot;)# VSCode Qt MSVC 配置指南add_executable(MyQtApp $&#123;SOURCES&#125;)# VSCode Qt MSVC 配置指南target_link_libraries(MyQtApp    Qt5::Core    Qt5::Widgets    Qt5::Gui    Qt5::Network)# VSCode Qt MSVC 配置指南set_target_properties(MyQtApp PROPERTIES    RUNTIME_OUTPUT_DIRECTORY_DEBUG $&#123;CMAKE_BINARY_DIR&#125;/Debug    RUNTIME_OUTPUT_DIRECTORY_RELEASE $&#123;CMAKE_BINARY_DIR&#125;/Release)# VSCode Qt MSVC 配置指南if(WIN32)    # 设置 Windows 子系统    set_target_properties(MyQtApp PROPERTIES        WIN32_EXECUTABLE TRUE    )    # 复制 Qt DLL 到输出目录    add_custom_command(TARGET MyQtApp POST_BUILD        COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_directory        &quot;$&#123;CMAKE_PREFIX_PATH&#125;/bin&quot;        $&lt;TARGET_FILE_DIR:MyQtApp&gt;        COMMENT &quot;Copying Qt DLLs to output directory&quot;    )endif()\n\n4.2 🔧 CMakePresets.json (可选)创建 CMakePresets.json 简化配置：\n&#123;    &quot;version&quot;: 3,    &quot;cmakeMinimumRequired&quot;: &#123;        &quot;major&quot;: 3,        &quot;minor&quot;: 15,        &quot;patch&quot;: 0    &#125;,    &quot;configurePresets&quot;: [        &#123;            &quot;name&quot;: &quot;windows-msvc-debug&quot;,            &quot;generator&quot;: &quot;Visual Studio 16 2019&quot;,            &quot;architecture&quot;: &quot;x64&quot;,            &quot;toolset&quot;: &quot;host=x64&quot;,            &quot;binaryDir&quot;: &quot;$&#123;sourceDir&#125;/build&quot;,            &quot;cacheVariables&quot;: &#123;                &quot;CMAKE_BUILD_TYPE&quot;: &quot;Debug&quot;,                &quot;CMAKE_PREFIX_PATH&quot;: &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64&quot;,                &quot;CMAKE_MSVC_RUNTIME_LIBRARY&quot;: &quot;MultiThreadedDebugDLL&quot;            &#125;        &#125;,        &#123;            &quot;name&quot;: &quot;windows-msvc-release&quot;,            &quot;generator&quot;: &quot;Visual Studio 16 2019&quot;,            &quot;architecture&quot;: &quot;x64&quot;,            &quot;toolset&quot;: &quot;host=x64&quot;,            &quot;binaryDir&quot;: &quot;$&#123;sourceDir&#125;/build&quot;,            &quot;cacheVariables&quot;: &#123;                &quot;CMAKE_BUILD_TYPE&quot;: &quot;Release&quot;,                &quot;CMAKE_PREFIX_PATH&quot;: &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64&quot;,                &quot;CMAKE_MSVC_RUNTIME_LIBRARY&quot;: &quot;MultiThreadedDLL&quot;            &#125;        &#125;    ],    &quot;buildPresets&quot;: [        &#123;            &quot;name&quot;: &quot;debug&quot;,            &quot;configurePreset&quot;: &quot;windows-msvc-debug&quot;,            &quot;configuration&quot;: &quot;Debug&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;release&quot;,            &quot;configurePreset&quot;: &quot;windows-msvc-release&quot;,            &quot;configuration&quot;: &quot;Release&quot;        &#125;    ]&#125;\n\n\n5. ✅ 环境验证5.1 🔍 命令行验证# VSCode Qt MSVC 配置指南cl.exe /?# VSCode Qt MSVC 配置指南# VSCode Qt MSVC 配置指南qmake -query# VSCode Qt MSVC 配置指南# VSCode Qt MSVC 配置指南# VSCode Qt MSVC 配置指南# VSCode Qt MSVC 配置指南# VSCode Qt MSVC 配置指南cmake -G# VSCode Qt MSVC 配置指南# VSCode Qt MSVC 配置指南echo $env:VCToolsInstallDirecho $env:WindowsSdkDirecho $env:WindowsSDKVersion\n\n5.2 🧪 测试项目创建创建测试源文件 src/main.cpp：\n#include &lt;QApplication&gt;#include &lt;QMainWindow&gt;#include &lt;QLabel&gt;#include &lt;QVBoxLayout&gt;#include &lt;QPushButton&gt;#include &lt;QMessageBox&gt;#include &lt;QDebug&gt;class MainWindow : public QMainWindow &#123;    Q_OBJECTpublic:    MainWindow(QWidget *parent = nullptr) : QMainWindow(parent) &#123;        setWindowTitle(&quot;Qt MSVC Test App&quot;);        resize(400, 300);        QWidget *centralWidget = new QWidget(this);        setCentralWidget(centralWidget);        QVBoxLayout *layout = new QVBoxLayout(centralWidget);        QLabel *label = new QLabel(&quot;Hello Qt with MSVC!&quot;, this);        label-&gt;setAlignment(Qt::AlignCenter);        label-&gt;setStyleSheet(&quot;font-size: 18px; font-weight: bold;&quot;);        layout-&gt;addWidget(label);        QPushButton *button = new QPushButton(&quot;Test Message&quot;, this);        connect(button, &amp;QPushButton::clicked, this, &amp;MainWindow::showTestMessage);        layout-&gt;addWidget(button);        QPushButton *debugButton = new QPushButton(&quot;Print Debug Info&quot;, this);        connect(debugButton, &amp;QPushButton::clicked, this, &amp;MainWindow::printDebugInfo);        layout-&gt;addWidget(debugButton);    &#125;private slots:    void showTestMessage() &#123;        QMessageBox::information(this, &quot;Test&quot;, &quot;MSVC + Qt 配置成功！&quot;);        qDebug() &lt;&lt; &quot;Message box shown successfully&quot;;    &#125;    void printDebugInfo() &#123;        qDebug() &lt;&lt; &quot;=== Qt Configuration Info ===&quot;;        qDebug() &lt;&lt; &quot;Qt Version:&quot; &lt;&lt; QT_VERSION_STR;        qDebug() &lt;&lt; &quot;Compiler:&quot; &lt;&lt;#ifdef _MSC_VER            &quot;MSVC &quot; &lt;&lt; _MSC_VER;#else            &quot;Unknown&quot;;#endif        qDebug() &lt;&lt; &quot;Build Type:&quot; &lt;&lt;#ifdef _DEBUG            &quot;Debug&quot;;#else            &quot;Release&quot;;#endif        qDebug() &lt;&lt; &quot;===============================&quot;;    &#125;&#125;;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    qDebug() &lt;&lt; &quot;Starting Qt application...&quot;;    qDebug() &lt;&lt; &quot;Qt version:&quot; &lt;&lt; QT_VERSION_STR;    MainWindow window;    window.show();    return app.exec();&#125;#include &quot;main.moc&quot;\n\n\n6. 🔧 常见问题解决6.1 ❌ CMake 找不到 Qt错误信息: Could NOT find Qt5\n解决方案：\n# VSCode Qt MSVC 配置指南set(CMAKE_PREFIX_PATH &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64&quot;)# VSCode Qt MSVC 配置指南set(ENV&#123;QTDIR&#125; &quot;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64&quot;)\n\n6.2 ❌ 缺少运行时库错误信息: 无法启动此程序，因为计算机中缺少 VCRUNTIME140.dll\n解决方案：\ngraph TD    A[缺少 VCRUNTIME140.dll] --&gt; B&#123;解决方案&#125;    B --&gt; C[安装 Visual C++ Redistributable]    B --&gt; D[静态链接运行时库]    B --&gt; E[复制 DLL 到输出目录]    C --&gt; F[下载安装 vc_redist.x64.exe]    D --&gt; G[设置 CMAKE_MSVC_RUNTIME_LIBRARY]    E --&gt; H[手动复制系统 DLL]\n\nCMake 配置：\n# VSCode Qt MSVC 配置指南set(CMAKE_MSVC_RUNTIME_LIBRARY &quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;)\n\n6.3 ❌ Qt 插件加载失败错误信息: This application failed to start because it could not find or load the Qt platform plugin &quot;windows&quot;\n解决方案：\n// 在 launch.json 中添加环境变量&quot;environment&quot;: [    &#123;        &quot;name&quot;: &quot;PATH&quot;,        &quot;value&quot;: &quot;$&#123;env:Path&#125;;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/bin;C:/Qt/Qt5.6.3/5.6.3/msvc2015_64/plugins/platforms&quot;    &#125;]\n\n6.4 ❌ IntelliSense 不工作症状: Qt 头文件显示红色下划线，代码补全不工作\n解决方案：\n\n检查 c_cpp_properties.json 中的路径是否正确\n确保 Qt 版本与编译器版本匹配 (MSVC vs MinGW)\n重新加载 VS Code 窗口 (Ctrl+Shift+P → Developer: Reload Window)\n\n6.5 ❌ 调试时无法查看 Qt 对象解决方案：\n\n安装 Qt Visual Studio Tools\n使用自定义的 qt.natvis 文件\n在调试时查看 this 指针和成员变量\n\n\n7. 🚀 完整工作流程flowchart TD    A[打开项目文件夹] --&gt; B[VS Code 自动检测 CMake]    B --&gt; C[选择配置预设]    C --&gt; D[CMake 配置项目]    D --&gt; E[IntelliSense 初始化完成]    E --&gt; F[编写代码]    F --&gt; G&#123;构建项目&#125;    G --&gt; H[Ctrl+Shift+B]    H --&gt; I[编译成功]    I --&gt; J&#123;调试运行&#125;    J --&gt; K[F5 启动调试]    K --&gt; L[应用运行]    L --&gt; M[调试和测试]    M --&gt; N&#123;修改代码?&#125;    N --&gt;|是| F    N --&gt;|否| O[完成开发]\n\n7.1 📝 日常开发步骤\n打开项目：VS Code 打开项目文件夹\n配置 CMake：Ctrl+Shift+P → CMake: Configure\n选择预设：底部状态栏选择 windows-msvc-debug 或 windows-msvc-release\n智能提示：等待 IntelliSense 完成初始化\n编写代码：享受完整的代码补全和语法高亮\n构建项目：Ctrl+Shift+B 或点击底部状态栏的构建按钮\n运行调试：F5 启动调试会话\n\n7.2 🎯 推荐快捷键\n\n\n快捷键\n功能\n说明\n\n\n\nCtrl+Shift+B\n构建项目\n执行默认构建任务\n\n\nF5\n启动调试\n运行当前配置的调试会话\n\n\nCtrl+Shift+P\n命令面板\n访问所有 VS Code 命令\n\n\nCtrl+,\n设置\n打开 VS Code 设置\n\n\nCtrl+K Ctrl+S\n快捷键设置\n自定义快捷键\n\n\n\n📊 总结✅ 配置完成检查清单\n Visual Studio Build Tools 安装完成\n Qt MSVC 版本安装完成\n VS Code 必需扩展安装\n C&#x2F;C++ 配置文件正确设置\n CMake 配置文件正确设置\n 调试器配置正确\n 测试项目编译运行成功\n 调试功能正常工作\n IntelliSense 完整支持\n\n🎯 下一步建议\n学习 Qt 框架：掌握信号槽、UI 设计、多线程等\nCMake 进阶：学习自定义构建规则、交叉编译\n调试技巧：掌握断点、内存查看、性能分析\n版本控制：集成 Git 进行代码管理\n单元测试：集成 Qt Test 或 Google Test\n\n📚 推荐资源\nQt 官方文档\nCMake 官方文档\nVS Code C++ 扩展文档\nMicrosoft C++ 文档\n\n\n\n💡 提示:\n\n首次配置可能需要一些时间，耐心按照步骤操作\n遇到问题时，首先检查路径和环境变量是否正确\n建议使用相对路径和 CMake 变量提高项目可移植性\n定期更新 VS Code 扩展以获得最新功能\n\n\n","categories":["开发工具"],"tags":["技术文档","指南"]},{"title":"MariaDB C++ Windows 安装指南","url":"/posts/15251b3b/","content":"MariaDB C++ Windows 安装指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: mariadb, cpp, windows, development, database, connector\n\n📑 目录\n1. 概述\n2. 安装 MariaDB 服务器\n2.1 获取安装程序\n2.2 运行安装向导\n2.3 验证安装\n\n\n3. 安装 MariaDB 连接器\n3.1 Connector&#x2F;C++\n3.2 Connector&#x2F;C\n3.3 配置环境变量\n\n\n4. 配置 Visual Studio 项目\n4.1 包含头文件目录\n4.2 配置库文件目录\n4.3 指定依赖的库文件\n4.4 拷贝 DLL 文件\n\n\n5. 编写测试代码\n6. 常见问题和解决方案\n7. 高级配置\n\n\n1. 📖 概述在Windows下进行C++开发并使用MariaDB，主要涉及MariaDB服务器端的安装、开发库的配置，以及在你的C++项目中正确连接和使用这些库。\n🎯 目标\n✅ 安装 MariaDB 服务器\n✅ 配置 C++ 开发环境\n✅ 创建可运行的 C++ 数据库程序\n✅ 掌握基本的数据库操作\n\n🏗️ 系统架构图graph TD    A[C++ Application] --&gt; B[MariaDB Connector/C++]    B --&gt; C[MariaDB Connector/C]    C --&gt; D[MariaDB Server]    D --&gt; E[Database Files]    F[Visual Studio IDE] --&gt; G[Project Configuration]    G --&gt; H[Include Directories]    G --&gt; I[Library Directories]    G --&gt; J[Dependencies]\n\n\n2. 💾 安装 MariaDB 服务器2.1 🔍 获取安装程序访问 MariaDB官方网站的下载页面，选择适用于Windows的安装程序。\n推荐版本选择：\n\n稳定版本: MariaDB 11.8 LTS (长期支持版本)\n文件格式: .msi 安装程序\n架构: 根据你的系统选择 x64 或 x86\n\n2.2 ⚙️ 运行安装向导运行下载的 .msi 安装程序，按照向导步骤操作：\n📋 重要配置项\n\n\n配置项\n推荐设置\n说明\n\n\n\n根密码\n强密码\n管理数据库的最高权限账户\n\n\n服务名\nMariaDB 或 MySQL\n保持默认即可\n\n\n端口\n3306\n默认数据库端口\n\n\n字符集\nUTF-8\n支持多语言\n\n\n启用网络访问\n是\n允许远程连接\n\n\n⚠️ 权限错误处理如果在安装过程中遇到服务权限相关的错误：\n\n不要退出安装程序\n打开 Windows 的”服务”管理界面 (services.msc)\n找到 MariaDB 服务\n右键 → “属性” → “登录”选项卡\n将登录身份修改为”本地系统账户“\n返回安装程序点击”重试“\n\n2.3 ✅ 验证安装安装完成后，通过以下方式验证：\n方法一：命令行验证# MariaDB C++ Windows 安装指南mysql -u root -p# MariaDB C++ Windows 安装指南\n\n方法二：图形化工具\nHeidiSQL (可能随安装包提供)\nDBeaver\nNavicat\nphpMyAdmin\n\n\n3. 🔌 安装 MariaDB 连接器3.1 📦 Connector&#x2F;C++MariaDB Connector&#x2F;C++ 是官方的 C++ 数据库连接器。\n下载地址：MariaDB Connector&#x2F;C++ 官方下载页面\n版本选择指南：\ngraph LR    A[Visual Studio版本] --&gt; B[Connector版本]    B --&gt; C[VS 2019/2022]    B --&gt; D[VS 2017]    B --&gt; E[VS 2015]    C --&gt; F[最新版本]    D --&gt; G[较新版本]    E --&gt; H[兼容版本]\n\n3.2 🔧 Connector&#x2F;C (依赖项)重要：MariaDB Connector/C++ 依赖于 MariaDB Connector/C\n下载地址：MariaDB Connector&#x2F;C 官方下载页面\n3.3 🌐 配置环境变量为了确保运行时能找到必要的 DLL 文件：\n自动配置（推荐）# MariaDB C++ Windows 安装指南setx PATH &quot;%PATH%;C:\\mariadb-connector-c\\lib&quot;\n\n手动配置\n右键”此电脑” → “属性” → “高级系统设置”\n点击”环境变量”\n在”系统变量”中找到 Path\n点击”编辑” → “新建”\n添加路径：C:\\mariadb-connector-c\\lib\n\n\n4. 🛠️ 配置 Visual Studio 项目4.1 📁 包含头文件目录\n在 Visual Studio 中打开项目\n右键点击项目名称，选择 “属性”\n导航到 “配置属性” → “C&#x2F;C++” → “常规” → “附加包含目录”\n添加以下路径：C:\\mariadb-connector-cpp\\includeC:\\mariadb-connector-c\\include\n\n4.2 🔗 配置库文件目录在同一个属性页中：\n\n导航到 “配置属性” → “链接器” → “常规” → “附加库目录”\n添加以下路径：C:\\mariadb-connector-cpp\\libC:\\mariadb-connector-c\\lib\n\n4.3 📚 指定依赖的库文件\n导航到 “配置属性” → “链接器” → “输入” → “附加依赖项”\n添加以下库文件（根据实际文件名可能略有不同）：mariadbclient.liblibmariadb.libmariadbcpp.lib\n\n4.4 📋 拷贝 DLL 文件确保程序运行时能找到必要的动态链接库：\ngraph LR    A[Connector/lib] --&gt; B[项目输出目录]    A --&gt; C[libmariadb.dll]    A --&gt; D[mariadbcpp.dll]    B --&gt; E[Debug/Release文件夹]\n\n需要复制的 DLL 文件：\n\nlibmariadb.dll (来自 Connector&#x2F;C)\nmariadbcpp.dll (来自 Connector&#x2F;C++)\n其他依赖的 DLL 文件\n\n\n5. 💻 编写测试代码5.1 📄 完整测试程序#include &lt;iostream&gt;#include &lt;mariadb/conncpp.hpp&gt; // Connector/C++ 的主要头文件// 数据库配置结构struct DatabaseConfig &#123;    std::string host = &quot;localhost&quot;;    int port = 3306;    std::string database = &quot;test_db&quot;;    std::string username = &quot;root&quot;;    std::string password = &quot;your_root_password_here&quot;; // 替换为实际密码&#125;;int main() &#123;    DatabaseConfig config;    try &#123;        std::cout &lt;&lt; &quot;🔌 正在连接到 MariaDB 服务器...&quot; &lt;&lt; std::endl;        // 1. 获取驱动实例        sql::mariadb::IMariaDBDriver* driver = sql::mariadb::get_driver_instance();        // 2. 配置数据库连接属性        sql::SQLString url = &quot;jdbc:mariadb://&quot; + config.host + &quot;:&quot; +                           std::to_string(config.port) + &quot;/&quot; + config.database;        sql::Properties properties;        properties[&quot;user&quot;] = config.username;        properties[&quot;password&quot;] = config.password;        // 3. 建立连接        std::unique_ptr&lt;sql::Connection&gt; conn(driver-&gt;connect(url, properties));        std::cout &lt;&lt; &quot;✅ 成功连接到 MariaDB 服务器！&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;📊 数据库: &quot; &lt;&lt; config.database &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;🌐 主机: &quot; &lt;&lt; config.host &lt;&lt; &quot;:&quot; &lt;&lt; config.port &lt;&lt; std::endl;        // 4. 执行简单查询测试        std::cout &lt;&lt; &quot;\\n🔍 执行测试查询...&quot; &lt;&lt; std::endl;        std::unique_ptr&lt;sql::Statement&gt; stmt(conn-&gt;createStatement());        std::unique_ptr&lt;sql::ResultSet&gt; res(            stmt-&gt;executeQuery(&quot;SELECT VERSION() as version, NOW() as current_time&quot;)        );        if (res-&gt;next()) &#123;            std::cout &lt;&lt; &quot;📦 MariaDB 版本: &quot; &lt;&lt; res-&gt;getString(&quot;version&quot;) &lt;&lt; std::endl;            std::cout &lt;&lt; &quot;⏰ 当前时间: &quot; &lt;&lt; res-&gt;getString(&quot;current_time&quot;) &lt;&lt; std::endl;        &#125;        // 5. 创建测试表        std::cout &lt;&lt; &quot;\\n🏗️  创建测试表...&quot; &lt;&lt; std::endl;        stmt-&gt;execute(&quot;DROP TABLE IF EXISTS test_users&quot;);        stmt-&gt;execute(R&quot;(            CREATE TABLE test_users (                id INT AUTO_INCREMENT PRIMARY KEY,                username VARCHAR(50) NOT NULL,                email VARCHAR(100),                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP            )        )&quot;);        std::cout &lt;&lt; &quot;✅ 测试表创建成功&quot; &lt;&lt; std::endl;        // 6. 插入测试数据        std::cout &lt;&lt; &quot;\\n📝 插入测试数据...&quot; &lt;&lt; std::endl;        std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(            conn-&gt;prepareStatement(&quot;INSERT INTO test_users (username, email) VALUES (?, ?)&quot;)        );        pstmt-&gt;setString(1, &quot;test_user1&quot;);        pstmt-&gt;setString(2, &quot;user1@example.com&quot;);        pstmt-&gt;executeUpdate();        pstmt-&gt;setString(1, &quot;test_user2&quot;);        pstmt-&gt;setString(2, &quot;user2@example.com&quot;);        pstmt-&gt;executeUpdate();        std::cout &lt;&lt; &quot;✅ 测试数据插入成功&quot; &lt;&lt; std::endl;        // 7. 查询测试数据        std::cout &lt;&lt; &quot;\\n📋 查询测试数据...&quot; &lt;&lt; std::endl;        std::unique_ptr&lt;sql::ResultSet&gt; selectRes(            stmt-&gt;executeQuery(&quot;SELECT * FROM test_users ORDER BY id&quot;)        );        std::cout &lt;&lt; &quot;+----+------------+---------------------+---------------------+&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;| ID | Username   | Email               | Created At          |&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;+----+------------+---------------------+---------------------+&quot; &lt;&lt; std::endl;        while (selectRes-&gt;next()) &#123;            std::cout &lt;&lt; &quot;| &quot; &lt;&lt; std::setw(2) &lt;&lt; selectRes-&gt;getInt(&quot;id&quot;)                      &lt;&lt; &quot; | &quot; &lt;&lt; std::setw(10) &lt;&lt; selectRes-&gt;getString(&quot;username&quot;)                      &lt;&lt; &quot; | &quot; &lt;&lt; std::setw(19) &lt;&lt; selectRes-&gt;getString(&quot;email&quot;)                      &lt;&lt; &quot; | &quot; &lt;&lt; std::setw(19) &lt;&lt; selectRes-&gt;getString(&quot;created_at&quot;)                      &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;        &#125;        std::cout &lt;&lt; &quot;+----+------------+---------------------+---------------------+&quot; &lt;&lt; std::endl;        // 8. 统计记录数        std::unique_ptr&lt;sql::ResultSet&gt; countRes(            stmt-&gt;executeQuery(&quot;SELECT COUNT(*) as total FROM test_users&quot;)        );        if (countRes-&gt;next()) &#123;            std::cout &lt;&lt; &quot;\\n📊 总记录数: &quot; &lt;&lt; countRes-&gt;getInt(&quot;total&quot;) &lt;&lt; std::endl;        &#125;        std::cout &lt;&lt; &quot;\\n🎉 所有测试通过！MariaDB C++ 连接配置成功！&quot; &lt;&lt; std::endl;    &#125; catch (sql::SQLException&amp; e) &#123;        std::cerr &lt;&lt; &quot;❌ 数据库连接或查询错误:&quot; &lt;&lt; std::endl;        std::cerr &lt;&lt; &quot;   错误信息: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        std::cerr &lt;&lt; &quot;   错误代码: &quot; &lt;&lt; e.getErrorCode() &lt;&lt; std::endl;        std::cerr &lt;&lt; &quot;   SQL状态: &quot; &lt;&lt; e.getSQLState() &lt;&lt; std::endl;        return 1;    &#125; catch (std::exception&amp; e) &#123;        std::cerr &lt;&lt; &quot;❌ 程序错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;    return 0;&#125;\n\n5.2 🏃‍♂️ 运行测试\n编译项目\nBuild → Build Solution (Ctrl+Shift+B)\n\n运行程序\nDebug → Start Without Debugging (Ctrl+F5)\n\n预期输出\n🔌 正在连接到 MariaDB 服务器...✅ 成功连接到 MariaDB 服务器！📊 数据库: test_db🌐 主机: localhost:3306🔍 执行测试查询...📦 MariaDB 版本: 11.8.0⏰ 当前时间: 2025-11-14 16:30:00🏗️  创建测试表...✅ 测试表创建成功📝 插入测试数据...✅ 测试数据插入成功📋 查询测试数据...+----+------------+---------------------+---------------------+| ID | Username   | Email               | Created At          |+----+------------+---------------------+---------------------+|  1 | test_user1 | user1@example.com   | 2025-11-14 16:30:01 ||  2 | test_user2 | user2@example.com   | 2025-11-14 16:30:01 |+----+------------+---------------------+---------------------+📊 总记录数: 2🎉 所有测试通过！MariaDB C++ 连接配置成功！\n\n\n6. 🔧 常见问题和解决方案6.1 ❌ 连接失败错误信息: Can&#39;t connect to MySQL server\n解决方案:\ngraph TD    A[连接失败] --&gt; B&#123;检查项目&#125;    B --&gt; C[MariaDB服务是否启动]    B --&gt; D[端口3306是否被占用]    B --&gt; E[防火墙设置]    B --&gt; F[用户名密码是否正确]    C --&gt; G[启动服务: net start mysql]    D --&gt; H[更换端口或释放端口]    E --&gt; I[添加防火墙例外]    F --&gt; J[重置root密码]\n\n6.2 ❌ DLL 找不到错误信息: 无法启动此程序，因为计算机中丢失 libmariadb.dll\n解决方案:\n\n确认 DLL 文件在正确位置\n检查 PATH 环境变量\n将 DLL 复制到项目输出目录\n\n6.3 ❌ 编译错误常见编译错误及解决方案:\n\n\n\n错误信息\n原因\n解决方案\n\n\n\n无法找到头文件\nInclude 目录未正确配置\n检查附加包含目录设置\n\n\n无法解析的外部符号\n库文件未正确链接\n检查附加依赖项和库目录\n\n\n字符集不匹配\nUnicode&#x2F;ANSI 编码问题\n在项目设置中统一字符集\n\n\n\n7. 🚀 高级配置7.1 🔐 连接池配置#include &lt;mariadb/conncpp.hpp&gt;class MariaDBConnectionPool &#123;private:    std::unique_ptr&lt;sql::mariadb::IMariaDBDriver&gt; driver;    sql::SQLString url;    sql::Properties properties;    std::vector&lt;std::unique_ptr&lt;sql::Connection&gt;&gt; connections;    std::mutex mutex;    int maxConnections;public:    MariaDBConnectionPool(const std::string&amp; host, int port,                         const std::string&amp; database,                         const std::string&amp; username,                         const std::string&amp; password,                         int maxConn = 10)        : maxConnections(maxConn) &#123;        driver = std::unique_ptr&lt;sql::mariadb::IMariaDBDriver&gt;(            sql::mariadb::get_driver_instance()        );        url = &quot;jdbc:mariadb://&quot; + host + &quot;:&quot; + std::to_string(port) + &quot;/&quot; + database;        properties[&quot;user&quot;] = username;        properties[&quot;password&quot;] = password;        properties[&quot;autoReconnect&quot;] = &quot;true&quot;;        properties[&quot;useSSL&quot;] = &quot;false&quot;;    &#125;    std::unique_ptr&lt;sql::Connection&gt; getConnection() &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        for (auto&amp; conn : connections) &#123;            if (conn &amp;&amp; !conn-&gt;isClosed()) &#123;                return std::move(conn);            &#125;        &#125;        // 创建新连接        return std::unique_ptr&lt;sql::Connection&gt;(            driver-&gt;connect(url, properties)        );    &#125;    void returnConnection(std::unique_ptr&lt;sql::Connection&gt; conn) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        if (conn &amp;&amp; connections.size() &lt; maxConnections) &#123;            connections.push_back(std::move(conn));        &#125;    &#125;&#125;;\n\n7.2 📝 事务处理void transactionExample(std::unique_ptr&lt;sql::Connection&gt;&amp; conn) &#123;    try &#123;        // 开始事务        std::unique_ptr&lt;sql::Statement&gt; stmt(conn-&gt;createStatement());        stmt-&gt;execute(&quot;START TRANSACTION&quot;);        // 执行多个SQL操作        std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(            conn-&gt;prepareStatement(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;)        );        // 扣款        pstmt-&gt;setDouble(1, 100.0);        pstmt-&gt;setInt(2, 1);        pstmt-&gt;executeUpdate();        // 加款        pstmt-&gt;setDouble(1, 100.0);        pstmt-&gt;setInt(2, 2);        pstmt-&gt;executeUpdate();        // 提交事务        conn-&gt;commit();        std::cout &lt;&lt; &quot;✅ 事务执行成功&quot; &lt;&lt; std::endl;    &#125; catch (sql::SQLException&amp; e) &#123;        // 回滚事务        conn-&gt;rollback();        std::cerr &lt;&lt; &quot;❌ 事务执行失败，已回滚: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;\n\n7.3 🌍 国际化支持void setupUTF8Connection(std::unique_ptr&lt;sql::Connection&gt;&amp; conn) &#123;    try &#123;        // 设置连接字符集        std::unique_ptr&lt;sql::Statement&gt; stmt(conn-&gt;createStatement());        stmt-&gt;execute(&quot;SET NAMES &#x27;utf8mb4&#x27;&quot;);        stmt-&gt;execute(&quot;SET CHARACTER SET utf8mb4&quot;);        std::cout &lt;&lt; &quot;✅ UTF-8 字符集配置完成&quot; &lt;&lt; std::endl;        // 测试中文支持        std::unique_ptr&lt;sql::PreparedStatement&gt; pstmt(            conn-&gt;prepareStatement(&quot;INSERT INTO test_table (name) VALUES (?)&quot;)        );        pstmt-&gt;setString(1, &quot;测试中文字符&quot;);        pstmt-&gt;executeUpdate();    &#125; catch (sql::SQLException&amp; e) &#123;        std::cerr &lt;&lt; &quot;❌ UTF-8 配置失败: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;\n\n\n📊 总结✅ 成功标志\n MariaDB 服务器安装完成\n Connector&#x2F;C 和 Connector&#x2F;C++ 安装完成\n Visual Studio 项目配置正确\n 测试程序运行成功\n 基本数据库操作正常\n\n🎯 下一步建议\n学习高级 SQL 操作：存储过程、触发器、视图\n掌握连接池技术：提高应用程序性能\n了解事务处理：确保数据一致性\n实现错误处理：增强程序健壮性\n安全配置：防止 SQL 注入攻击\n\n📚 推荐资源\nMariaDB Connector&#x2F;C++ 官方文档\nSQL 基础教程\nC++ 数据库编程最佳实践\n\n\n\n💡 提示: 在生产环境中，请务必：\n\n使用强密码和连接加密\n实施适当的错误处理和日志记录\n定期备份数据库\n监控数据库性能和安全\n\n\n","categories":["数据库系统","关系型数据库"],"tags":["技术文档","指南"]},{"title":"Windows 环境下配置 GitHub MCP 服务器完整指南","url":"/posts/windows-github-mcp/","content":"Windows 环境下配置 GitHub MCP 服务器完整指南\n文档创建时间: 2025-12-18最后更新: 2025-12-18标签: github, mcp, windows, powershell, gemini-cli, ai-tools\n\n📑 目录\n1. 概述\n2. 生成 GitHub PAT\n3. 设置环境变量\n4. 编辑 Gemini CLI 配置\n5. 安装必要的依赖\n6. 验证配置\n7. 故障排除\n8. 最佳实践\n9. 总结\n\n\n1. 📖 概述本文将详细介绍在Windows环境下如何配置GitHub MCP (Model Context Protocol) 服务器，让您可以在Gemini CLI中直接操作GitHub仓库。\n2. 🔑 生成 GitHub PAT步骤 1：生成 GitHub PAT按照以下步骤在GitHub创建一个Fine-grained Token（细粒度令牌）：\n1.1 访问GitHub设置\n登录GitHub账户\n点击右上角头像\n选择 “Settings”（设置）\n在左侧菜单中选择 “Developer settings”\n点击 “Personal access tokens” → “Fine-grained tokens”\n\n1.2 创建新令牌\n点击 “Generate new token”\n输入令牌名称（如：”Gemini MCP Server”）\n设置过期时间（建议选择90天）\n\n1.3 配置权限Repository access：\n\n选择你要访问的仓库\n建议选择 “Only select repositories” 并指定相关仓库\n\nPermissions（权限配置）：\n\nContents → Read &amp; Write（读写代码内容）\nIssues → Read &amp; Write（管理Issues）\nPull requests → Read &amp; Write（管理PR）\nMetadata → Read（读取仓库元数据）\n\n1.4 复制令牌生成后立即复制并保存令牌，格式如下：\nghp_abcd1234efgh5678ijkl90mnopqrstuvwx\n\n步骤 2：设置环境变量（Windows）2.1 使用PowerShell设置在Windows PowerShell中运行以下命令：\n# 设置用户级环境变量setx GITHUB_PERSONAL_ACCESS_TOKEN &quot;你的GitHub令牌&quot;# 设置会话级环境变量（立即生效）$env:GITHUB_PERSONAL_ACCESS_TOKEN = &quot;你的GitHub令牌&quot;\n\n2.2 验证设置重新打开一个新的PowerShell窗口，验证环境变量：\n# 查看环境变量值echo $env:GITHUB_PERSONAL_ACCESS_TOKEN# 或者Get-ChildItem Env:GITHUB_PERSONAL_ACCESS_TOKEN\n\n步骤 3：编辑 Gemini CLI 配置3.1 定位配置文件\n全局配置路径：%USERPROFILE%\\.gemini\\settings.json\n项目级配置路径：你的项目目录\\.gemini\\settings.json\n\n3.2 创建配置文件如果配置文件不存在，先创建：\n# 创建配置目录mkdir $env:USERPROFILE\\.gemini# 编辑配置文件notepad $env:USERPROFILE\\.gemini\\settings.json\n\n3.3 配置MCP服务器在 settings.json 中写入以下内容：\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;github&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-github&quot;],      &quot;env&quot;: &#123;        &quot;GITHUB_PERSONAL_ACCESS_TOKEN&quot;: &quot;$&#123;GITHUB_PERSONAL_ACCESS_TOKEN&#125;&quot;      &#125;    &#125;  &#125;&#125;\n\n步骤 4：安装必要的依赖4.1 安装Node.js（如果尚未安装）访问 Node.js官网 下载并安装LTS版本。\n4.2 安装GitHub MCP服务器在PowerShell中执行：\n# 全局安装GitHub MCP服务器npm install -g @modelcontextprotocol/server-github# 验证安装npx @modelcontextprotocol/server-github --help\n\n步骤 5：验证配置5.1 启动Gemini CLI# 启动Gemini CLIgemini\n\n5.2 测试MCP连接在Gemini CLI中输入：\n/mcp\n\n如果配置成功，你应该能看到 “github mcp server connected” 的提示。\n5.3 测试功能尝试以下命令测试GitHub MCP功能：\n列出我仓库中的open issues查看我的个人资料信息列出最近修改的仓库\n\n故障排除常见问题及解决方案\nMCP服务器连接失败\n\n检查环境变量是否正确设置\n确认GitHub PAT权限配置正确\n验证网络连接\n\n\n权限错误\n\n确保PAT包含必要的权限\n检查PAT是否已过期\n\n\nnpx命令失败\n\n确保Node.js已正确安装\n检查npm全局安装路径\n\n\n\n最佳实践\n安全性：\n\n定期更新PAT\n使用最小权限原则\n不要在代码中硬编码令牌\n\n\n性能优化：\n\n使用项目级配置而非全局配置\n定期清理不必要的MCP服务器配置\n\n\n维护：\n\n定期检查令牌有效性\n更新MCP服务器版本\n\n\n\n总结通过以上步骤，您已经在Windows环境下成功配置了GitHub MCP服务器，现在可以在Gemini CLI中直接操作GitHub仓库了。这个配置让您能够更高效地管理代码仓库，提升开发效率。\n相关链接\nGitHub Fine-grained tokens文档\nModel Context Protocol官网\nGemini CLI文档\n\n","categories":["开发工具"],"tags":["技术文档","指南"]},{"title":"MySQL Windows 安装指南","url":"/posts/e2f925a8/","content":"MySQL Windows 安装指南目录\n概述\n第一步：下载与解压\n第二步：配置 my.ini 文件\n第三步：初始化与安装服务\n第四步：服务管理与登录\n用户与权限管理\n备份与恢复\n常见问题与故障排除\n\n概述本指南详细介绍如何在 Windows 操作系统上，通过官方的 ZIP 压缩包手动安装、配置 MySQL，并将其注册为 Windows 服务。这种方式让你可以完全控制 MySQL 的安装位置和配置。\n第一步：下载与解压\n下载 MySQL Community Server:访问官方下载页面：https://dev.mysql.com/downloads/mysql/选择 “Windows (x86, 64-bit), ZIP Archive” 版本进行下载。\n\n解压文件:将下载的 ZIP 文件解压到一个你选择的稳定路径，例如 C:\\mysql。路径中最好不要包含中文或空格。\n解压后的目录结构大致如下：\n&lt;Your-MySQL-Path&gt;\\├── bin\\          # 可执行文件 (mysqld, mysql, mysqldump 等)├── include\\├── lib\\└── share\\\n\n第二步：配置 my.ini 文件\n在你的 MySQL 根目录下（例如 C:\\mysql）创建一个名为 my.ini 的文本文件。这是 MySQL 的核心配置文件。\n\n创建 data 目录: 在根目录下手动创建一个名为 data 的空文件夹，用于存放数据库文件。\n\n编辑 my.ini: 将以下内容复制到 my.ini 文件中，并务必将 &lt;Your-MySQL-Path&gt; 替换为你自己的实际路径（注意路径中的反斜杠 \\ 需要转义为 \\\\）。\n[mysqld]# 设置 3306 端口port=3306# 设置 mysql 的安装目录basedir=&lt;Your-MySQL-Path&gt;# 设置 mysql 数据库的数据的存放目录datadir=&lt;Your-MySQL-Path&gt;\\\\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为 utf8mb4character-set-server=utf8mb4# 默认存储引擎default-storage-engine=INNODB# [MySQL 8.0+ 新特性] 默认认证方式default_authentication_plugin=mysql_native_password[mysql]# 设置 mysql 客户端默认字符集default-character-set=utf8mb4[client]# 设置 mysql 客户端连接时的默认端口port=3306default-character-set=utf8mb4\n\n第三步：初始化与安装服务以管理员身份打开命令提示符 (CMD) 或 PowerShell，并进入 bin 目录。\ncd &lt;Your-MySQL-Path&gt;\\bin\n\n\n初始化数据库:\nmysqld --initialize --console\n重要: 此命令会创建 data 目录并生成一个临时的 root 用户密码。请在输出的日志中找到并立即复制保存这行信息：A temporary password is generated for root@localhost: &lt;随机密码&gt;\n\n安装 MySQL 服务:\n# 安装服务，服务名为 MySQLmysqld --install MySQL# 如果 my.ini 不在默认位置，可以使用 --defaults-file 指定# mysqld --install MySQL --defaults-file=\\&quot;&lt;Your-MySQL-Path&gt;\\\\my.ini\\&quot;\n如果看到 Service successfully installed. 则表示安装成功。\n\n\n第四步：服务管理与登录\n启动服务:\nnet start MySQL\n\n登录并修改密码:使用上一步中保存的临时密码登录。\nmysql -u root -p\n在提示 Enter password: 后，粘贴你的临时密码并按回车。\n\n修改 root 密码:登录成功后，立即修改为一个更强的密码。\nALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;YourNewStrongPassword&#x27;;FLUSH PRIVILEGES;EXIT;\n\n用户与权限管理-- 创建一个新用户 &#x27;appuser&#x27;，密码为 &#x27;password123&#x27;CREATE USER &#x27;appuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password123&#x27;;-- 授予 &#x27;appuser&#x27; 对 &#x27;mydatabase&#x27; 数据库的所有权限GRANT ALL PRIVILEGES ON mydatabase.* TO &#x27;appuser&#x27;@&#x27;localhost&#x27;;-- 刷新权限使之生效FLUSH PRIVILEGES;\n\n备份与恢复备份使用 mysqldump 工具进行备份。\n# MySQL Windows 安装指南mysqldump -u root -p mydatabase &gt; D:\\\\backups\\\\mydatabase_backup.sql# MySQL Windows 安装指南mysqldump -u root -p --all-databases &gt; D:\\\\backups\\\\all_databases.sql\n\n恢复# MySQL Windows 安装指南mysql -u root -p mydatabase &lt; D:\\\\backups\\\\mydatabase_backup.sql\n\n常见问题与故障排除Q: 服务启动失败?A:\n\n检查 data 目录下的 .err 日志文件，查找具体的错误信息。\n检查端口（如 3306）是否被其他程序占用 (netstat -ano | findstr 3306)。\n\nQ: 忘记 root 密码?A:\n\n以管理员身份打开 cmd，停止 MySQL 服务：net stop MySQL。\n创建 mysql-init.txt 文件，内容为：ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;NewPassword&#39;;\n使用无权限验证模式启动 MySQL 并加载该文件：mysqld --init-file=&quot;C:\\\\mysql-init.txt&quot; --console\n看到服务启动后，关闭该 cmd 窗口，然后正常启动 MySQL 服务：net start MySQL。现在你可以用 NewPassword 登录了。\n\nQ: 字符集乱码?A: 确保 my.ini 文件中 [mysqld], [mysql], [client] 下都设置了 character-set-server=utf8mb4 或 default-character-set=utf8mb4。\n","categories":["后端服务架构","数据库与缓存"],"tags":["Windows","MySQL","数据库","服务配置"]},{"title":"Nginx Ubuntu 反向代理指南","url":"/posts/ebeb0722/","content":"Nginx Ubuntu 反向代理指南目录\n第一步：安装 Nginx\n第二步：设置基础 Web 服务器\n第三步：配置反向代理与 HTTPS\n第四步：使用 Certbot 自动配置 SSL\n第五步：配置多个本地应用的反向代理 (可选)\n第六步：配置负载均衡 (可选)\n附录：性能与安全优化\n常见问题\n\n第一步：安装 Nginx# Nginx Ubuntu 反向代理指南sudo apt update# Nginx Ubuntu 反向代理指南sudo apt install -y nginx# Nginx Ubuntu 反向代理指南sudo ufw allow &#x27;Nginx Full&#x27;# Nginx Ubuntu 反向代理指南sudo systemctl status nginx\n安装完成后，通过浏览器访问 http://&lt;你的服务器IP&gt;，应能看到 Nginx 的欢迎页面。\n第二步：设置基础 Web 服务器即使我们主要用 Nginx 做反向代理，创建一个基础的服务器块（Server Block）也是一个好习惯。\n# Nginx Ubuntu 反向代理指南sudo mkdir -p /var/www/your_domain.com/htmlsudo chown -R $USER:$USER /var/www/your_domain.com# Nginx Ubuntu 反向代理指南sudo nano /etc/nginx/sites-available/your_domain.com\n\n将以下基础配置粘贴进去：\nserver &#123;    listen 80;    listen [::]:80;    root /var/www/your_domain.com/html;    index index.html;    server_name your_domain.com www.your_domain.com;    location / &#123;        try_files $uri $uri/ =404;    &#125;&#125;\n\n# Nginx Ubuntu 反向代理指南sudo ln -s /etc/nginx/sites-available/your_domain.com /etc/nginx/sites-enabled/# Nginx Ubuntu 反向代理指南sudo nginx -t# Nginx Ubuntu 反向代理指南sudo systemctl restart nginx\n\n第三步：配置反向代理与 HTTPS现在，我们将修改配置文件，使其将 HTTP 请求重定向到 HTTPS，并将所有流量反向代理到一个后端应用（例如，一个运行在 localhost:8080 的 Node.js 或 Java 应用）。\n编辑你的配置文件：sudo nano /etc/nginx/sites-available/your_domain.com\n# Nginx Ubuntu 反向代理指南server &#123;    listen 80;    listen [::]:80;    server_name your_domain.com www.your_domain.com;    # 将所有 HTTP 请求 301 重定向到 HTTPS    return 301 https://$host$request_uri;&#125;# Nginx Ubuntu 反向代理指南server &#123;    listen 443 ssl http2;    listen [::]:443 ssl http2;    server_name your_domain.com www.your_domain.com;    # SSL 证书路径 (稍后由 Certbot 自动填充)    ssl_certificate /etc/letsencrypt/live/your_domain.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/your_domain.com/privkey.pem;    # --- SSL/TLS 安全增强配置 ---    # 推荐只使用 TLS 1.2 和 1.3，这是当前的安全标准    ssl_protocols TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    # 现代 OpenSSL 兼容的安全加密套件（2024年推荐）    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;    # SSL 会话缓存优化    ssl_session_cache shared:SSL:10m;    ssl_session_timeout 10m;    ssl_session_tickets off;    # OCSP Stapling    ssl_stapling on;    ssl_stapling_verify on;    resolver 8.8.8.8 8.8.4.4 valid=300s;    resolver_timeout 5s;        # --- 安全头 (Security Headers) ---    # HSTS (HTTP Strict Transport Security): 强制客户端在指定时间内只能通过 HTTPS 访问    add_header Strict-Transport-Security &quot;max-age=15768000; includeSubDomains; preload&quot; always;    # X-Frame-Options: 防止点击劫持攻击    add_header X-Frame-Options DENY;    # X-Content-Type-Options: 防止 MIME 类型嗅探攻击    add_header X-Content-Type-Options nosniff;    # X-XSS-Protection: 启用 XSS 保护    add_header X-XSS-Protection &quot;1; mode=block&quot;;    # Referrer Policy: 控制referrer信息发送    add_header Referrer-Policy &quot;strict-origin-when-cross-origin&quot;;    # Content Security Policy: 防止代码注入攻击（基础配置）    add_header Content-Security-Policy &quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; img-src &#x27;self&#x27; data: https:; font-src &#x27;self&#x27; data: https:; connect-src &#x27;self&#x27;; frame-ancestors &#x27;none&#x27;;&quot;;    # 核心：反向代理配置    location / &#123;        # 将请求转发到后端应用        proxy_pass http://127.0.0.1:8080;        # 设置必要的请求头，以便后端应用能获取到真实的客户端信息        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        # WebSocket 支持 (如果后端应用需要)        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;    &#125;&#125;\n\n第四步：使用 Certbot 自动配置 SSLLet’s Encrypt 提供免费的 SSL 证书，certbot 是其官方推荐的客户端。\n# Nginx Ubuntu 反向代理指南sudo apt install -y certbot python3-certbot-nginx# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南sudo certbot --nginx -d your_domain.com -d www.your_domain.com# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南sudo certbot renew --dry-run\n执行完毕后，你的网站就应该可以通过 https://your_domain.com 访问了。\n第五步：配置多个本地应用的反向代理 (可选)如果你有多个本地应用需要通过同一个域名访问，可以基于不同的路径前缀进行反向代理配置。\n编辑你的配置文件：sudo nano /etc/nginx/sites-available/your_domain.com\n# Nginx Ubuntu 反向代理指南server &#123;    listen 443 ssl http2;    listen [::]:443 ssl http2;    server_name your_domain.com www.your_domain.com;    # SSL 证书路径 (由 Certbot 自动配置)    ssl_certificate /etc/letsencrypt/live/your_domain.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/your_domain.com/privkey.pem;    # SSL/TLS 安全配置...    # (同之前的配置)    # --- 多个应用的反向代理配置 ---    # API 服务 (运行在端口 3000)    location /api/ &#123;        proxy_pass http://127.0.0.1:3000/;        # 设置必要的请求头        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        # API 服务优化配置        proxy_buffering on;        proxy_buffer_size 4k;        proxy_buffers 8 4k;    &#125;    # 管理后台 (运行在端口 8080)    location /admin/ &#123;        proxy_pass http://127.0.0.1:8080/;        # 设置必要的请求头        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;    # WebSocket 服务 (运行在端口 9090)    location /ws/ &#123;        proxy_pass http://127.0.0.1:9090/;        # WebSocket 特殊配置        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        # WebSocket 超时配置        proxy_read_timeout 86400;        proxy_send_timeout 86400;    &#125;    # 静态文件服务 (前端应用，运行在端口 3001)    location / &#123;        proxy_pass http://127.0.0.1:3001/;        # 设置必要的请求头        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        # 静态文件优化        proxy_cache_bypass $http_upgrade;        proxy_set_header Connection &quot;&quot;;    &#125;    # 特定文件类型的缓存配置    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ &#123;        proxy_pass http://127.0.0.1:3001;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        # 缓存配置        expires 1y;        add_header Cache-Control &quot;public, immutable&quot;;        add_header Vary Accept-Encoding;    &#125;&#125;\n\n配置说明\n路径匹配规则：\n\n/api/ → 匹配所有以 /api/ 开头的请求\n/admin/ → 匹配所有以 /admin/ 开头的请求\n/ws/ → 匹配所有以 /ws/ 开头的请求\n/ → 匹配所有其他请求（默认）\n\n\nproxy_pass 路径处理：\n\nproxy_pass http://127.0.0.1:3000/ → 末尾的 / 会将匹配的 location 路径部分完全替换\n例如：/api/users → 转发到 http://127.0.0.1:3000/users（/api/ 被完全移除）\n\n对比示例：\n# 带末尾斜杠（移除匹配路径）location /api/ &#123;    proxy_pass http://127.0.0.1:3000/;&#125;# /api/users → http://127.0.0.1:3000/users# 不带末尾斜杠（保留完整路径）location /api/ &#123;    proxy_pass http://127.0.0.1:3000;&#125;# /api/users → http://127.0.0.1:3000/api/users\n\nWebSocket 支持注意事项：\n\n必须设置 proxy_http_version 1.1\n必须添加 Upgrade 和 Connection 头\n建议增加超时时间，防止连接断开\n\n\n测试配置：\n\n\n# Nginx Ubuntu 反向代理指南sudo nginx -t# Nginx Ubuntu 反向代理指南sudo systemctl restart nginx# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南# Nginx Ubuntu 反向代理指南curl -I https://your_domain.com\n\n第六步：配置负载均衡 (可选)如果你有多个后端应用服务器，可以使用 Nginx 的 upstream 模块来实现负载均衡。\n编辑你的配置文件：sudo nano /etc/nginx/sites-available/your_domain.com\n# Nginx Ubuntu 反向代理指南upstream backend_servers &#123;    # 默认策略是轮询 (Round Robin)    server backend1.example.com:8080;    server backend2.example.com:8080;    # 也可以指定权重 (weight)    # server backend1.example.com:8080 weight=3;    # server backend2.example.com:8080 weight=1;    # 或者使用 ip_hash 策略，确保同一客户端总是访问同一台服务器    # ip_hash;&#125;server &#123;    listen 443 ssl http2;    listen [::]:443 ssl http2;    server_name your_domain.com;    # SSL 证书配置（同前文）    ssl_certificate /etc/letsencrypt/live/your_domain.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/your_domain.com/privkey.pem;    # SSL 安全配置（同前文）    ssl_protocols TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;    location / &#123;        # 将请求转发到上游服务器组        proxy_pass http://backend_servers;        # 设置必要的请求头        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;&#125;\n修改配置后，不要忘记测试和重启 Nginx：sudo nginx -t &amp;&amp; sudo systemctl restart nginx。\n附录：性能与安全优化Gzip 压缩在 /etc/nginx/nginx.conf 的 http 块中添加或取消注释：\nhttp &#123;    # ...    gzip on;    gzip_vary on;    gzip_proxied any;    gzip_comp_level 6;    gzip_min_length 1000;    gzip_types        text/plain        text/css        text/xml        text/javascript        application/javascript        application/xml+rss        application/json        application/xml        image/svg+xml;    # ...&#125;\n\n隐藏 Nginx 版本号同样在 http 块中添加：\nhttp &#123;    # ...    server_tokens off;    # ...&#125;\n\n缓冲区优化在 http 或 server 块中配置：\n# Nginx Ubuntu 反向代理指南client_body_buffer_size 128k;client_max_body_size 20m;# Nginx Ubuntu 反向代理指南proxy_buffering on;proxy_buffer_size 4k;proxy_buffers 8 4k;proxy_busy_buffers_size 8k;# Nginx Ubuntu 反向代理指南client_header_timeout 10;client_body_timeout 10;keepalive_timeout 65;send_timeout 10;\n\n连接限制防止 DoS 攻击：\n# Nginx Ubuntu 反向代理指南limit_conn_zone $binary_remote_addr zone=addr:10m;# Nginx Ubuntu 反向代理指南limit_conn addr 10;\n\n禁用不安全的 HTTP 方法server &#123;    # ...    # 禁用 TRACE 和 TRACK 方法    if ($request_method ~ ^(TRACE|TRACK)$) &#123;        return 405;    &#125;&#125;\n\n常见问题Q: 502 Bad Gateway 错误?A: 这通常意味着 Nginx 无法连接到你的后端应用。请检查：\n\n你的后端应用（如 Node.js, Java）是否正在 127.0.0.1:8080 上正常运行。\n检查后端应用的防火墙设置。\n查看 Nginx 的错误日志 sudo tail -f /var/log/nginx/error.log。\n\nQ: HTTPS 网站提示不安全?A: 这通常是 SSL 证书配置问题。\n\n确保证书路径正确。\n确保证书链完整 (fullchain.pem)。\n使用 SSL Labs 的 SSL Test 工具来全面分析你的 HTTPS 配置。\n\nQ: 证书续期失败?\nA: 检查以下几点：\n\n确认服务器时间正确：sudo timedatectl status\n手动测试续期：sudo certbot renew --dry-run\n检查 cron 或 systemd timer 是否正常运行：sudo systemctl status certbot.timer\n\nQ: WebSocket 连接失败?\nA: 检查以下配置：\n\n确保设置了 proxy_http_version 1.1\n确保添加了正确的 Upgrade 和 Connection 头\n检查后端应用是否支持 WebSocket\n确认超时设置足够长\n\nQ: 静态文件 404 错误?\nA: 可能的原因：\n\n后端应用端口未正确启动\n静态文件路径不正确\n权限问题：检查 sudo chown -R www-data:www-data /var/www/\n检查 SELinux 或 AppArmor 是否阻止访问\n\nQ: 如何查看 Nginx 访问日志和错误日志?\nA: 日志文件位置：\n\n访问日志：/var/log/nginx/access.log\n错误日志：/var/log/nginx/error.log\n实时监控：sudo tail -f /var/log/nginx/error.log\n\nQ: 如何重载 Nginx 配置而不中断服务?\nA: 使用重载命令：\nsudo nginx -t &amp;&amp; sudo systemctl reload nginx","categories":["后端服务架构","Web服务器配置"],"tags":["Ubuntu","Nginx","反向代理","HTTPS","SSL","Let's Encrypt","负载均衡"]},{"title":"Apache Ubuntu 反向代理指南","url":"/posts/d0dcdb61/","content":"Apache Ubuntu 反向代理指南目录\n第一步：安装 Apache\n第二步：设置虚拟主机 (Virtual Host)\n第三步：配置反向代理\n第四步：使用 Certbot 配置 HTTPS\n附录：性能与安全优化\n常见问题\n\n第一步：安装 Apache# Apache Ubuntu 反向代理指南sudo apt update# Apache Ubuntu 反向代理指南sudo apt install apache2# Apache Ubuntu 反向代理指南sudo ufw allow &#x27;Apache Full&#x27;# Apache Ubuntu 反向代理指南sudo systemctl status apache2\n安装完成后，通过浏览器访问 http://&lt;你的服务器IP&gt;，应能看到 Apache 的默认欢迎页面。\n第二步：设置虚拟主机 (Virtual Host)虚拟主机允许你在同一台服务器上托管多个网站。\n# Apache Ubuntu 反向代理指南sudo mkdir -p /var/www/your_domain.com/htmlsudo chown -R $USER:$USER /var/www/your_domain.com# Apache Ubuntu 反向代理指南sudo nano /etc/apache2/sites-available/your_domain.com.conf\n\n将以下基础配置粘贴进去。这会告诉 Apache 在哪里找到网站文件，并设置域名。\n&lt;VirtualHost *:80&gt;    ServerAdmin webmaster@localhost    ServerName your_domain.com    ServerAlias www.your_domain.com    DocumentRoot /var/www/your_domain.com/html    ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log    CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt;\n\n# Apache Ubuntu 反向代理指南sudo a2ensite your_domain.com.confsudo a2enmod rewrite# Apache Ubuntu 反向代理指南sudo apache2ctl configtest# Apache Ubuntu 反向代理指南sudo systemctl restart apache2\n\n第三步：配置反向代理反向代理允许 Apache 接收请求，然后将其转发到后端的另一个服务（例如一个 Node.js 或 Java 应用）。\n# Apache Ubuntu 反向代理指南sudo a2enmod proxysudo a2enmod proxy_httpsudo a2enmod proxy_balancersudo a2enmod lbmethod_byrequests# Apache Ubuntu 反向代理指南sudo systemctl restart apache2\n\n现在，编辑你的站点配置文件 sudo nano /etc/apache2/sites-available/your_domain.com.conf，并修改它以包含 ProxyPass。\n&lt;VirtualHost *:80&gt;    ServerName your_domain.com    ServerAlias www.your_domain.com    # 将所有请求转发到运行在 8080 端口的后端应用    ProxyPreserveHost On    ProxyPass / http://127.0.0.1:8080/    ProxyPassReverse / http://127.0.0.1:8080/&lt;/VirtualHost&gt;\n再次重启 Apache 后，所有到 your_domain.com 的请求都会被转发到 localhost:8080。\n第四步：使用 Certbot 配置 HTTPSLet’s Encrypt 提供免费的 SSL 证书，certbot 是其官方推荐的客户端。\n# Apache Ubuntu 反向代理指南sudo apt install certbot python3-certbot-apache# Apache Ubuntu 反向代理指南# Apache Ubuntu 反向代理指南sudo certbot --apache -d your_domain.com -d www.your_domain.com\n在安装过程中，Certbot 会询问你是否要将所有 HTTP 请求自动重定向到 HTTPS，推荐选择“Redirect”。\n完成后，你的配置文件会被自动更新，类似于：\n&lt;VirtualHost *:443&gt;    ServerName your_domain.com    # ... 其他配置 ...    SSLEngine on    SSLCertificateFile /etc/letsencrypt/live/your_domain.com/fullchain.pem    SSLCertificateKeyFile /etc/letsencrypt/live/your_domain.com/privkey.pem    # --- SSL/TLS 安全增强配置 ---    # 推荐只使用 TLS 1.2 和 1.3，禁用过时的、不安全的协议    SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1    # 一个现代且安全的加密套件列表    SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256    SSLHonorCipherOrder on    # ... 反向代理配置 ...    ProxyPass / http://127.0.0.1:8080/    ProxyPassReverse / http://127.0.0.1:8080/&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;    # ... Certbot 自动生成的重定向到 HTTPS 的配置 ...&lt;/VirtualHost&gt;\n\n附录：性能与安全优化启用 Gzip&#x2F;Deflate 压缩# Apache Ubuntu 反向代理指南sudo a2enmod deflatesudo systemctl restart apache2\n在 /etc/apache2/apache2.conf 中添加配置：\n&lt;IfModule mod_deflate.c&gt;    AddOutputFilterByType DEFLATE text/html text/plain text/xml text/css application/javascript&lt;/IfModule&gt;\n\n添加安全头在你的 HTTPS (*:443) VirtualHost 配置中添加：\n&lt;IfModule mod_headers.c&gt;    # HSTS (HTTP Strict Transport Security): 强制客户端在指定时间内只能通过 HTTPS 访问    Header always set Strict-Transport-Security &quot;max-age=15768000; includeSubDomains&quot;    # X-Frame-Options: 防止点击劫持攻击    Header always set X-Frame-Options &quot;SAMEORIGIN&quot;    # X-Content-Type-Options: 防止 MIME 类型嗅探攻击    Header always set X-Content-Type-Options &quot;nosniff&quot;&lt;/IfModule&gt;\n\n隐藏服务器信息在 /etc/apache2/conf-enabled/security.conf 中，确保设置为：\nServerTokens ProdServerSignature Off\n\n常见问题Q: 503 Service Unavailable 错误?A: 这通常意味着 Apache 无法连接到你的后端应用，但代理模块已启用。请检查：\n\n你的后端应用是否正在运行。\nProxyPass 指令中的地址和端口是否正确。\n\nQ: 重启 Apache 失败?A: 运行 sudo apache2ctl configtest 来检查配置文件的语法错误。常见的错误包括模块未启用（如 proxy_http）或拼写错误。\n","categories":["后端服务架构","Web服务器配置"],"tags":["Ubuntu","反向代理","HTTPS","SSL","Let's Encrypt","Apache","HTTPD"]},{"title":"PostgreSQL C++ Windows 安装指南","url":"/posts/b71a62b0/","content":"PostgreSQL C++ Windows 安装指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: postgresql, c, windows, development, database, libpq\n\n📑 目录\n1. 概述\n2. 系统组件\n3. PostgreSQL 安装\n3.1 下载安装包\n3.2 运行安装程序\n\n\n4. C 开发环境配置\n4.1 包含头文件配置\n4.2 链接库配置\n4.3 运行时依赖配置\n\n\n5. 验证与测试\n6. 常见问题解决\n7. 高级配置\n\n\n1. 📖 概述本指南详细说明如何在 Windows 系统上配置 PostgreSQL 的 C 语言开发环境，包括服务器安装、客户端库配置和开发环境设置。\n🎯 配置目标\n✅ 安装 PostgreSQL 数据库服务器\n✅ 配置 C 语言客户端库 (libpq)\n✅ 设置开发环境和编译选项\n✅ 创建可运行的 C 数据库应用程序\n\n🏗️ 系统架构graph TD    A[C Application] --&gt; B[libpq Client Library]    B --&gt; C[PostgreSQL Server]    C --&gt; D[Database Files]    E[Visual Studio] --&gt; F[Project Configuration]    F --&gt; G[Include Directories]    F --&gt; H[Library Directories]    F --&gt; I[Dependencies]    G --&gt; J[postgresql/include]    H --&gt; K[postgresql/lib]    I --&gt; L[libpq.lib]\n\n\n2. 🔧 系统组件\n\n\n组件\n主要作用\n获取与说明\n\n\n\nPostgreSQL 服务器\n提供数据库服务核心，包含运行实例所需的所有程序\n从官网下载安装包，通常自动安装\n\n\nC客户端库 (libpq)\nC程序连接和操作PostgreSQL数据库的主要库，包含头文件和链接库\n安装时必须勾选 “PostgreSQL C Libraries (libpq)”\n\n\nCommand Line Tools\n提供 psql 等命令行工具，用于数据库管理和调试\n推荐安装，便于开发和测试\n\n\npgAdmin\n图形化管理工具，可视化管理数据库\n可选安装，便于日常管理\n\n\n\n3. 💾 PostgreSQL 安装3.1 🌐 下载安装包访问 PostgreSQL官网下载页面：\n推荐版本选择：\n\n最新稳定版: PostgreSQL 16.x\n架构: x64 (64位)\n安装包格式: Windows exe 安装程序\n\ngraph LR    A[访问官网] --&gt; B[选择Windows版本]    B --&gt; C[下载安装包]    C --&gt; D[运行安装程序]    D --&gt; E[配置组件选择]    E --&gt; F[完成安装]\n\n3.2 ⚙️ 运行安装程序\n启动安装程序\n# 以管理员权限运行postgresql-16.1-1-windows-x64.exe\n\n组件选择界面\n关键步骤：在 “Select Components” 界面，请确保勾选以下选项：\n✅ PostgreSQL Server                    (必须)✅ Command Line Tools                  (推荐)✅ PostgreSQL C Libraries (libpq)     (必须)✅ pgAdmin 4                          (可选)\n\n重要配置项\n\n\n\n配置项\n推荐设置\n说明\n\n\n\n安装目录\nC:\\Program Files\\PostgreSQL\\16\n默认路径，避免包含空格或中文\n\n\n数据目录\nC:\\Program Files\\PostgreSQL\\16\\data\n数据库存储位置\n\n\n超级用户密码\n强密码\n记住postgres用户密码\n\n\n端口\n5432\n默认端口，确保未被占用\n\n\n区域设置\nChinese (Simplified), China\n或根据需要选择\n\n\n\n安装完成验证\n# 检查服务状态services.msc  # 查看postgresql服务是否运行# 测试连接psql -U postgres -h localhost\n\n\n4. 🛠️ C 开发环境配置安装完成后，PostgreSQL 通常位于 C:\\Program Files\\PostgreSQL\\16 目录。\n4.1 📁 包含头文件配置头文件路径: C:\\Program Files\\PostgreSQL\\16\\include\n关键头文件:\n#include &lt;libpq-fe.h&gt;          // 主要的客户端接口#include &lt;libpq/libpq-fs.h&gt;    // 大对象支持#include &lt;postgres_ext.h&gt;      // PostgreSQL 扩展定义\n\nVisual Studio 配置:\n\n右键项目 → 属性\n配置属性 → C&#x2F;C++ → 常规\n附加包含目录 添加：C:\\Program Files\\PostgreSQL\\16\\include\n\n4.2 🔗 链接库配置库文件路径: C:\\Program Files\\PostgreSQL\\16\\lib\n主要库文件:\nlibpq.lib        // 主要的客户端库ws2_32.lib       // Windows Socket 库advapi32.lib     // Windows API 库\n\nVisual Studio 配置:\n\n配置属性 → 链接器 → 常规\n\n附加库目录 添加：\nC:\\Program Files\\PostgreSQL\\16\\lib\n\n配置属性 → 链接器 → 输入\n\n附加依赖项 添加：\nlibpq.lib;ws2_32.lib;advapi32.lib;\n\n4.3 🔄 运行时依赖配置DLL 文件: C:\\Program Files\\PostgreSQL\\16\\bin\\libpq.dll\n配置方法 (三选一):\n方法一：环境变量配置 (推荐)# PostgreSQL C++ Windows 安装指南setx PATH &quot;%PATH%;C:\\Program Files\\PostgreSQL\\16\\bin&quot;# PostgreSQL C++ Windows 安装指南# PostgreSQL C++ Windows 安装指南\n\n方法二：项目配置# PostgreSQL C++ Windows 安装指南set PATH=C:\\Program Files\\PostgreSQL\\16\\bin;%PATH%your_app.exe\n\n方法三：复制 DLL# PostgreSQL C++ Windows 安装指南copy &quot;C:\\Program Files\\PostgreSQL\\16\\bin\\libpq.dll&quot; &quot;your_project_dir\\Debug\\&quot;copy &quot;C:\\Program Files\\PostgreSQL\\16\\bin\\libpq.dll&quot; &quot;your_project_dir\\Release\\&quot;\n\n\n5. 🧪 验证与测试5.1 📄 测试程序创建测试文件 test_pgsql.c:\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;libpq-fe.h&gt;int main() &#123;    printf(&quot;🐘 PostgreSQL C Development Environment Test\\n&quot;);    printf(&quot;=============================================\\n\\n&quot;);    // 1. 检查 libpq 版本    printf(&quot;📋 libpq Library Information:\\n&quot;);    printf(&quot;   Version: %s\\n&quot;, PQlibVersion());    // 2. 连接字符串    const char *conninfo = &quot;host=localhost port=5432 dbname=postgres user=postgres password=your_password&quot;;    printf(&quot;\\n🔌 Attempting to connect to PostgreSQL...\\n&quot;);    // 3. 建立连接    PGconn *conn = PQconnectdb(conninfo);    if (PQstatus(conn) != CONNECTION_OK) &#123;        fprintf(stderr, &quot;❌ Connection failed: %s\\n&quot;, PQerrorMessage(conn));        PQfinish(conn);        return 1;    &#125;    printf(&quot;✅ Connection established successfully!\\n&quot;);    // 4. 获取服务器信息    printf(&quot;\\n📊 Server Information:\\n&quot;);    printf(&quot;   Host: %s\\n&quot;, PQhost(conn));    printf(&quot;   Port: %s\\n&quot;, PQport(conn));    printf(&quot;   Database: %s\\n&quot;, PQdb(conn));    printf(&quot;   User: %s\\n&quot;, PQuser(conn));    // 5. 执行简单查询    printf(&quot;\\n🔍 Executing test query...\\n&quot;);    PGresult *res = PQexec(conn, &quot;SELECT version() as version, current_database() as database&quot;);    if (PQresultStatus(res) != PGRES_TUPLES_OK) &#123;        fprintf(stderr, &quot;❌ Query failed: %s\\n&quot;, PQerrorMessage(conn));        PQclear(res);        PQfinish(conn);        return 1;    &#125;    // 6. 显示查询结果    printf(&quot;✅ Query executed successfully!\\n&quot;);    printf(&quot;📋 Query Results:\\n&quot;);    int rows = PQntuples(res);    int cols = PQnfields(res);    for (int i = 0; i &lt; rows; i++) &#123;        for (int j = 0; j &lt; cols; j++) &#123;            printf(&quot;   %s: %s\\n&quot;, PQfname(res, j), PQgetvalue(res, i, j));        &#125;    &#125;    // 7. 清理资源    PQclear(res);    PQfinish(conn);    printf(&quot;\\n🎉 All tests completed successfully!\\n&quot;);    printf(&quot;🚀 Your PostgreSQL C development environment is ready!\\n&quot;);    return 0;&#125;\n\n5.2 🔨 编译命令Visual Studio 编译# PostgreSQL C++ Windows 安装指南# PostgreSQL C++ Windows 安装指南msbuild YourProject.vcxproj /p:Configuration=Debug\n\n命令行编译 (cl.exe)# PostgreSQL C++ Windows 安装指南&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat&quot;# PostgreSQL C++ Windows 安装指南cl /EHsc /I&quot;C:\\Program Files\\PostgreSQL\\16\\include&quot; ^   test_pgsql.c /link ^   /LIBPATH:&quot;C:\\Program Files\\PostgreSQL\\16\\lib&quot; ^   libpq.lib ws2_32.lib advapi32.lib\n\nGCC (MinGW) 编译gcc -o test_pgsql test_pgsql.c ^   -I&quot;C:\\Program Files\\PostgreSQL\\16\\include&quot; ^   -L&quot;C:\\Program Files\\PostgreSQL\\16\\lib&quot; ^   -lpq -lws2_32 -ladvapi32\n\n5.3 ✅ 预期输出🐘 PostgreSQL C Development Environment Test=============================================📋 libpq Library Information:   Version: 160001🔌 Attempting to connect to PostgreSQL...✅ Connection established successfully!📊 Server Information:   Host: localhost   Port: 5432   Database: postgres   User: postgres🔍 Executing test query...✅ Query executed successfully!📋 Query Results:   version: PostgreSQL 16.1, compiled by Visual C++ build 1938, 64-bit   database: postgres🎉 All tests completed successfully!🚀 Your PostgreSQL C development environment is ready!\n\n\n6. 🔧 常见问题解决6.1 ❌ 编译错误错误: 无法打开源文件: &#39;libpq-fe.h&#39;解决方案:\n# PostgreSQL C++ Windows 安装指南# PostgreSQL C++ Windows 安装指南include_directories(&quot;C:/Program Files/PostgreSQL/16/include&quot;)\n\n错误: 无法解析的外部符号 _PQconnectdb解决方案:\n# PostgreSQL C++ Windows 安装指南# PostgreSQL C++ Windows 安装指南link_directories(&quot;C:/Program Files/PostgreSQL/16/lib&quot;)target_link_libraries(your_target libpq ws2_32 advapi32)\n\n6.2 ❌ 运行时错误错误: 无法启动此程序，因为计算机中缺少 libpq.dll解决方案:\ngraph TD    A[缺少 libpq.dll] --&gt; B&#123;解决方案&#125;    B --&gt; C[添加 PATH 环境变量]    B --&gt; D[复制 DLL 到程序目录]    B --&gt; E[使用 Visual Studio 调试环境]    C --&gt; F[系统属性 → 环境变量 → PATH]    D --&gt; G[复制到 Debug/Release 文件夹]    E --&gt; H[项目属性 → 调试 → 环境]\n\n错误: connection to server at &quot;localhost&quot; (::1), port 5432 failed解决方案:\n\n检查 PostgreSQL 服务是否启动\n验证端口和主机配置\n检查防火墙设置\n\n6.3 ❌ 权限问题错误: FATAL: password authentication failed for user &quot;postgres&quot;解决方案:\n\n确认密码正确\n检查 pg_hba.conf 认证配置\n重置 postgres 用户密码\n\n\n7. 🚀 高级配置7.1 📝 CMake 配置示例创建 CMakeLists.txt:\ncmake_minimum_required(VERSION 3.10)project(PostgreSQLCTest)# PostgreSQL C++ Windows 安装指南set(CMAKE_C_STANDARD 99)# PostgreSQL C++ Windows 安装指南find_package(PostgreSQL REQUIRED)# PostgreSQL C++ Windows 安装指南include_directories($&#123;PostgreSQL_INCLUDE_DIRS&#125;)# PostgreSQL C++ Windows 安装指南add_executable(test_pgsql test_pgsql.c)# PostgreSQL C++ Windows 安装指南target_link_libraries(test_pgsql $&#123;PostgreSQL_LIBRARIES&#125;)# PostgreSQL C++ Windows 安装指南if(WIN32)    target_link_libraries(test_pgsql ws2_32 advapi32)endif()# PostgreSQL C++ Windows 安装指南message(STATUS &quot;PostgreSQL version: $&#123;PostgreSQL_VERSION&#125;&quot;)message(STATUS &quot;PostgreSQL include dir: $&#123;PostgreSQL_INCLUDE_DIRS&#125;&quot;)message(STATUS &quot;PostgreSQL libraries: $&#123;PostgreSQL_LIBRARIES&#125;&quot;)\n\n7.2 🔒 安全连接配置// SSL 连接示例const char *conninfo = &quot;host=localhost &quot;                      &quot;port=5432 &quot;                      &quot;dbname=postgres &quot;                      &quot;user=postgres &quot;                      &quot;password=your_password &quot;                      &quot;sslmode=require &quot;                      &quot;sslcert=client.crt &quot;                      &quot;sslkey=client.key&quot;;PGconn *conn = PQconnectdb(conninfo);// 检查 SSL 状态if (PQsslInUse(conn)) &#123;    printf(&quot;✅ SSL connection established\\n&quot;);    printf(&quot;   SSL Protocol: %s\\n&quot;, PQsslAttribute(conn, &quot;protocol&quot;));&#125;\n\n7.3 📊 性能优化配置// 连接池配置示例#define MAX_CONNECTIONS 10typedef struct &#123;    PGconn *connections[MAX_CONNECTIONS];    int available[MAX_CONNECTIONS];    int count;&#125; ConnectionPool;ConnectionPool* create_pool(const char* conninfo) &#123;    ConnectionPool *pool = malloc(sizeof(ConnectionPool));    pool-&gt;count = MAX_CONNECTIONS;    for (int i = 0; i &lt; MAX_CONNECTIONS; i++) &#123;        pool-&gt;connections[i] = PQconnectdb(conninfo);        pool-&gt;available[i] = 1;    &#125;    return pool;&#125;PGconn* get_connection(ConnectionPool *pool) &#123;    for (int i = 0; i &lt; pool-&gt;count; i++) &#123;        if (pool-&gt;available[i]) &#123;            pool-&gt;available[i] = 0;            return pool-&gt;connections[i];        &#125;    &#125;    return NULL; // 所有连接都在使用中&#125;\n\n\n📊 总结✅ 配置完成检查清单\n PostgreSQL 服务器安装完成\n C 客户端库 (libpq) 安装完成\n 开发环境配置正确\n 测试程序编译运行成功\n 基本数据库操作正常工作\n 错误处理机制完善\n\n🎯 下一步建议\n学习 libpq API：掌握连接管理、查询执行、结果处理\n实现连接池：提高应用程序性能\n异步编程：使用非阻塞操作提升响应性\n错误处理：完善异常情况和资源清理\n事务管理：确保数据一致性\n\n📚 推荐资源\nPostgreSQL 官方文档\nlibpq C API 参考\nPostgreSQL 教程\nC 数据库编程最佳实践\n\n\n\n💡 提示:\n\n首次配置可能需要一些时间，请耐心按照步骤操作\n生产环境中请使用 SSL 连接和强密码\n定期备份数据库和配置文件\n监控数据库性能和连接状态\n\n\n","categories":["数据库系统","关系型数据库"],"tags":["技术文档","指南"]},{"title":"Redis Windows 安装指南","url":"/posts/4996968/","content":"Redis Windows 安装指南目录\n重要：Redis on Windows 现状\n方法一：在 WSL2 中运行 Redis (官方推荐)\n方法二：使用旧版 Redis for Windows\n客户端连接\n常见问题\n\n重要：Redis on Windows 现状Redis 官方并未正式支持和维护原生的 Windows 版本。\n\n官方推荐方案: 在 Windows 10&#x2F;11 上，官方推荐使用 WSL2 (Windows Subsystem for Linux) 来安装和运行原生的、最新的 Linux 版 Redis。这能提供最佳的性能和兼容性。\n旧的 Windows 版本: 曾有一个由微软维护的 Windows 移植版 Redis (MicrosoftArchive/redis)，但该项目已于多年前停止更新，其最新版本仅为 3.x，与现代 Redis (6.x, 7.x) 相比功能陈旧且存在已知漏洞。\n\n本指南将优先介绍 WSL2 的方法，并将旧的原生 Windows 版本安装作为备用方案。\n方法一：在 WSL2 中运行 Redis (官方推荐)1. 安装 WSL2 和一个 Linux 发行版如果你的系统尚未安装 WSL2，请参照微软官方文档进行安装。推荐安装 Ubuntu。微软官方 WSL 安装指南\n2. 在 Ubuntu (WSL) 中安装 Redis打开你的 Ubuntu 终端，执行以下命令：\n# Redis Windows 安装指南sudo apt update# Redis Windows 安装指南sudo apt install redis-server\n\n3. 配置和管理 Redis 服务# Redis Windows 安装指南sudo service redis-server start# Redis Windows 安装指南sudo service redis-server status# Redis Windows 安装指南redis-cli ping  # 应该返回 PONG# Redis Windows 安装指南# Redis Windows 安装指南sudo nano /etc/redis/redis.conf# Redis Windows 安装指南# Redis Windows 安装指南sudo service redis-server restart\n在 WSL2 中运行的 Redis，你可以直接通过 localhost 从你的 Windows 主机访问它。\n方法二：使用旧版 Redis for Windows警告: 此方法安装的是一个过时的 Redis 3.x 版本，不推荐用于生产环境。\n1. 下载从 MicrosoftArchive/redis 的 GitHub Releases 页面下载最新的 .msi 或 .zip 文件。\n\n下载地址: https://github.com/microsoftarchive/redis/releases\n\n2. 安装与配置\n解压: 将 ZIP 文件解压到一个稳定路径，例如 C:\\redis。\n重命名配置文件: 将 redis.windows.conf 复制一份，并重命名为 redis.conf。\n编辑 redis.conf:# 设置密码requirepass your_strong_password# (可选) 修改端口# port 6379\n\n3. 注册为 Windows 服务以管理员身份打开命令提示符 (CMD)，并进入你的 Redis 目录。\ncd C:\\redis# Redis Windows 安装指南redis-server.exe --service-install redis.conf --service-name Redis# Redis Windows 安装指南redis-server.exe --service-start --service-name Redis\n\n4. 管理服务# Redis Windows 安装指南redis-server.exe --service-stop --service-name Redis# Redis Windows 安装指南redis-server.exe --service-uninstall --service-name Redis# Redis Windows 安装指南\n\n客户端连接无论你使用哪种方法安装，都可以使用 redis-cli 或图形化客户端进行连接。\n使用 redis-cli# Redis Windows 安装指南redis-cli -h localhost -p 6379# Redis Windows 安装指南redis-cli -h localhost -p 6379 -a your_strong_password\n\n图形化客户端推荐使用 Another Redis Desktop Manager 或 TablePlus 等现代 Redis 客户端。在连接时，主机地址填写 localhost，并填入对应的端口和密码即可。\n常见问题Q: 为什么不直接在 Windows 上编译最新的 Redis 源码?A: Redis 源码严重依赖 Linux 的内核特性（如 fork()），使其很难被直接、稳定地移植到 Windows。官方已放弃这条路线，全面拥抱 WSL2。\nQ: WSL2 中的 Redis 如何与我的 Windows 应用通信?A: WSL2 与 Windows 主机共享网络。你的 Windows 应用可以直接通过 localhost 或 127.0.0.1 连接到在 WSL2 中运行的 Redis 服务，就像它在本地运行一样。\nQ: 旧版 Redis for Windows 有什么风险?A: 主要风险是它不再接收安全更新，可能存在已知的安全漏洞。同时，它也缺少许多现代 Redis 的新功能和性能改进。\n","categories":["后端服务架构","数据库与缓存"],"tags":["Windows","服务配置","Redis","缓存","WSL2"]},{"title":"Redis Hiredis Linux 安装指南","url":"/posts/f0a1549f/","content":"Redis Hiredis Linux 安装指南目录\n概述\n第一步：安装和配置 Redis 服务\n第二步：安装 hiredis 客户端库\n第三步：搭建 C++ 项目 (CMake)\n第四步：编写 RedisClient 封装类\n第五步：编写主程序并测试\n常见问题\n最佳实践\n\n概述本指南将介绍如何在 Linux (Ubuntu&#x2F;Debian) 环境下，为 C++ 项目配置 Redis 开发环境。我们将使用 hiredis 这个官方推荐的、轻量级的 C 语言客户端库。\n第一步：安装和配置 Redis 服务1. 安装 Redis 服务器# Redis Hiredis Linux 安装指南sudo apt updatesudo apt install -y redis-server\n\n2. 配置 Redis为了安全和远程访问，建议修改配置文件。\n# Redis Hiredis Linux 安装指南sudo nano /etc/redis/redis.conf\n找到并修改以下几行：\n# Redis Hiredis Linux 安装指南bind 0.0.0.0# Redis Hiredis Linux 安装指南requirepass your_strong_password# Redis Hiredis Linux 安装指南protected-mode no\n\n3. 管理 Redis 服务# Redis Hiredis Linux 安装指南sudo systemctl restart redis-server# Redis Hiredis Linux 安装指南sudo systemctl status redis-server# Redis Hiredis Linux 安装指南sudo systemctl enable redis-server\n\n第二步：安装 hiredis 客户端库hiredis 是与 Redis 一同开发的官方 C 客户端库。\n# Redis Hiredis Linux 安装指南sudo apt install -y libhiredis-dev\n这会自动将头文件和库文件安装到系统标准路径中。\n第三步：搭建 C++ 项目 (CMake)1. 创建项目结构mkdir redis_cpp_demo &amp;&amp; cd redis_cpp_demomkdir src includetouch CMakeLists.txt src/main.cpp src/redis_client.cpp include/redis_client.h\n\n2. 编写 CMakeLists.txt使用 pkg-config 来查找 hiredis 是最简单和最可移植的方式。\ncmake_minimum_required(VERSION 3.10)project(RedisCppDemo)set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)# Redis Hiredis Linux 安装指南find_package(PkgConfig REQUIRED)pkg_check_modules(HIREDIS REQUIRED hiredis)# Redis Hiredis Linux 安装指南include_directories($&#123;HIREDIS_INCLUDE_DIRS&#125;)# Redis Hiredis Linux 安装指南add_executable(redis_demo src/main.cpp src/redis_client.cpp)# Redis Hiredis Linux 安装指南target_link_libraries(redis_demo PRIVATE $&#123;HIREDIS_LIBRARIES&#125;)\n\n第四步：编写 RedisClient 封装类创建一个 C++ 类来封装 hiredis 的 C 风格 API，使其更易于使用。\ninclude/redis_client.h:\n#ifndef REDIS_CLIENT_H#define REDIS_CLIENT_H#include &lt;string&gt;#include &lt;vector&gt;#include &lt;hiredis/hiredis.h&gt;class RedisClient &#123;public:    RedisClient(const std::string&amp; host = &quot;127.0.0.1&quot;, int port = 6379, const std::string&amp; password = &quot;&quot;);    ~RedisClient();    bool connect();    void disconnect();    bool isConnected() const;    std::string getLastError() const;    // String commands    bool set(const std::string&amp; key, const std::string&amp; value);    std::string get(const std::string&amp; key);    // Hash commands    bool hset(const std::string&amp; key, const std::string&amp; field, const std::string&amp; value);    std::string hget(const std::string&amp; key, const std::string&amp; field);    // Key commands    bool del(const std::string&amp; key);    bool exists(const std::string&amp; key);private:    redisContext* m_context;    std::string m_host;    int m_port;    std::string m_password;    bool authenticate();&#125;;#endif // REDIS_CLIENT_H\n\nsrc/redis_client.cpp:\n#include &quot;redis_client.h&quot;#include &lt;iostream&gt;#include &lt;cstring&gt; // For strcmpRedisClient::RedisClient(const std::string&amp; host, int port, const std::string&amp; password)    : m_context(nullptr), m_host(host), m_port(port), m_password(password) &#123;&#125;RedisClient::~RedisClient() &#123;    disconnect();&#125;bool RedisClient::connect() &#123;    struct timeval timeout = &#123;2, 0&#125;; // 2 seconds    m_context = redisConnectWithTimeout(m_host.c_str(), m_port, timeout);    if (m_context == nullptr || m_context-&gt;err) &#123;        return false;    &#125;    if (!m_password.empty() &amp;&amp; !authenticate()) &#123;        disconnect();        return false;    &#125;    return true;&#125;void RedisClient::disconnect() &#123;    if (m_context) &#123;        redisFree(m_context);        m_context = nullptr;    &#125;&#125;bool RedisClient::isConnected() const &#123;    return m_context != nullptr &amp;&amp; m_context-&gt;err == 0;&#125;std::string RedisClient::getLastError() const &#123;    return (m_context &amp;&amp; m_context-&gt;errstr) ? m_context-&gt;errstr : &quot;&quot;;&#125;bool RedisClient::authenticate() &#123;    redisReply* reply = static_cast&lt;redisReply*&gt;(redisCommand(m_context, &quot;AUTH %s&quot;, m_password.c_str()));    if (!reply) return false;    bool success = (reply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; strcmp(reply-&gt;str, &quot;OK&quot;) == 0);    freeReplyObject(reply);    return success;&#125;bool RedisClient::set(const std::string&amp; key, const std::string&amp; value) &#123;    if (!isConnected()) return false;    redisReply* reply = static_cast&lt;redisReply*&gt;(redisCommand(m_context, &quot;SET %s %s&quot;, key.c_str(), value.c_str()));    if (!reply) return false;    bool success = (reply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; strcmp(reply-&gt;str, &quot;OK&quot;) == 0);    freeReplyObject(reply);    return success;&#125;std::string RedisClient::get(const std::string&amp; key) &#123;    if (!isConnected()) return &quot;&quot;;    redisReply* reply = static_cast&lt;redisReply*&gt;(redisCommand(m_context, &quot;GET %s&quot;, key.c_str()));    if (!reply || reply-&gt;type != REDIS_REPLY_STRING) &#123;        if (reply) freeReplyObject(reply);        return &quot;&quot;;    &#125;    std::string result = reply-&gt;str;    freeReplyObject(reply);    return result;&#125;bool RedisClient::del(const std::string&amp; key) &#123;    if (!isConnected()) return false;    redisReply* reply = static_cast&lt;redisReply*&gt;(redisCommand(m_context, &quot;DEL %s&quot;, key.c_str()));    if (!reply) return false;    bool success = (reply-&gt;type == REDIS_REPLY_INTEGER &amp;&amp; reply-&gt;integer &gt; 0);    freeReplyObject(reply);    return success;&#125;bool RedisClient::hset(const std::string&amp; key, const std::string&amp; field, const std::string&amp; value) &#123;    if (!isConnected()) return false;    redisReply* reply = static_cast&lt;redisReply*&gt;(redisCommand(m_context, &quot;HSET %s %s %s&quot;, key.c_str(), field.c_str(), value.c_str()));    if (!reply) return false;    bool success = (reply-&gt;type == REDIS_REPLY_INTEGER);    freeReplyObject(reply);    return success;&#125;std::string RedisClient::hget(const std::string&amp; key, const std::string&amp; field) &#123;    if (!isConnected()) return &quot;&quot;;    redisReply* reply = static_cast&lt;redisReply*&gt;(redisCommand(m_context, &quot;HGET %s %s&quot;, key.c_str(), field.c_str()));    if (!reply || reply-&gt;type != REDIS_REPLY_STRING) &#123;        if (reply) freeReplyObject(reply);        return &quot;&quot;;    &#125;    std::string result = reply-&gt;str;    freeReplyObject(reply);    return result;&#125;bool RedisClient::exists(const std::string&amp; key) &#123;    if (!isConnected()) return false;    redisReply* reply = static_cast&lt;redisReply*&gt;(redisCommand(m_context, &quot;EXISTS %s&quot;, key.c_str()));    if (!reply) return false;    bool success = (reply-&gt;type == REDIS_REPLY_INTEGER &amp;&amp; reply-&gt;integer == 1);    freeReplyObject(reply);    return success;&#125;\n\n第五步：编写主程序并测试src/main.cpp:\n#include &quot;redis_client.h&quot;#include &lt;iostream&gt;int main() &#123;    RedisClient redis(&quot;127.0.0.1&quot;, 6379, &quot;your_strong_password&quot;);    if (!redis.connect()) &#123;        std::cerr &lt;&lt; &quot;Failed to connect to Redis: &quot; &lt;&lt; redis.getLastError() &lt;&lt; std::endl;        return 1;    &#125;    std::cout &lt;&lt; &quot;=== Redis C++ Client Test ===\\n&quot;;    // 1. String operations    std::cout &lt;&lt; &quot;\\n1. Testing string operations...\\n&quot;;    if (redis.set(&quot;test_key&quot;, &quot;Hello from hiredis!&quot;)) &#123;        std::cout &lt;&lt; &quot;SET successful.\\n&quot;;        std::string value = redis.get(&quot;test_key&quot;);        std::cout &lt;&lt; &quot;GET &#x27;test_key&#x27;: &quot; &lt;&lt; value &lt;&lt; std::endl;    &#125;    // 2. Hash operations    std::cout &lt;&lt; &quot;\\n2. Testing hash operations...\\n&quot;;    redis.hset(&quot;user:1001&quot;, &quot;name&quot;, &quot;Alice&quot;);    redis.hset(&quot;user:1001&quot;, &quot;age&quot;, &quot;30&quot;);    std::cout &lt;&lt; &quot;User name: &quot; &lt;&lt; redis.hget(&quot;user:1001&quot;, &quot;name&quot;) &lt;&lt; std::endl;    // 3. Key operations    std::cout &lt;&lt; &quot;\\n3. Cleaning up...\\n&quot;;    if (redis.del(&quot;test_key&quot;)) &#123;        std::cout &lt;&lt; &quot;DEL &#x27;test_key&#x27; successful.\\n&quot;;    &#125;    if (redis.del(&quot;user:1001&quot;)) &#123;        std::cout &lt;&lt; &quot;DEL &#x27;user:1001&#x27; successful.\\n&quot;;    &#125;    return 0;&#125;\n\n常见问题Q1: 连接被拒绝 (Connection refused)?A: 确认 Redis 服务正在运行，并且 redis.conf 中的 bind 指令允许你的 IP 访问。检查防火墙设置。\nQ2: 认证失败 (Authentication failed)?A: 确认 redis.conf 中的 requirepass 与你客户端代码中使用的密码完全一致。\nQ3: 编译时找不到 hiredis/hiredis.h?A: 确认 libhiredis-dev 已正确安装。运行 pkg-config --cflags hiredis 检查 pkg-config 是否能找到头文件路径。如果不能，你的 pkg-config 路径可能不完整。\n最佳实践\n连接管理: 对于需要频繁操作 Redis 的长时运行应用，应使用连接池来复用 RedisClient 对象，避免频繁地建立和断开 TCP 连接。\n错误处理: 在每次 Redis 命令执行后，都应检查 reply 指针是否为 nullptr 以及 m_context-&gt;err 标志，以处理网络断开等问题。\n异步操作: hiredis 也提供了异步 API (redisAsyncContext)。对于高并发场景，应使用异步客户端以避免阻塞。\n配置外置: 不要将 Redis 的地址、端口和密码硬编码在代码中。将它们放在配置文件或环境变量中。\n\n","categories":["后端服务架构","数据库与缓存"],"tags":["C++","开发环境","Linux","Redis","hiredis"]},{"title":"文件管理 API 规范","url":"/posts/eed6fb04/","content":"文件管理 API 规范\n文档创建时间: 2025-11-14最后更新: 2025-11-14版本: v1.0标签: api, rest, file-management, authentication, swagger\n\n📑 目录\n1. 基础信息\n2. 认证与授权\n3. 文件管理\n4. 文件支持\n5. 错误处理\n6. 安全机制\n7. 速率限制\n8. OpenAPI 规范\n\n\n1. 📋 基础信息\n\n\n项目\n说明\n\n\n\nBase URL\n/api/v1\n\n\n协议\nHTTPS\n\n\n数据格式\nJSON\n\n\n认证方式\nJWT Bearer Token\n\n\nAPI 版本\nv1.0\n\n\n🔐 认证请求格式GET /api/v1/files/list HTTP/1.1Host: your-domain.comAuthorization: Bearer &lt;jwt_token&gt;Content-Type: application/json\n\n\n2. 🔐 认证与授权2.1 👤 用户注册sequenceDiagram    participant C as Client    participant A as API Server    participant D as Database    C-&gt;&gt;A: POST /auth/register    A-&gt;&gt;A: 验证输入数据    A-&gt;&gt;D: 检查用户是否存在    D--&gt;&gt;A: 返回检查结果    A-&gt;&gt;A: 加密密码    A-&gt;&gt;D: 创建新用户    D--&gt;&gt;A: 返回用户信息    A-&gt;&gt;A: 生成JWT Token    A--&gt;&gt;C: 返回用户信息和Token\n\n接口详情请求:\nPOST /api/v1/auth/registerContent-Type: application/json\n\n请求体:\n&#123;    &quot;username&quot;: &quot;string&quot;,    &quot;email&quot;: &quot;user@example.com&quot;,    &quot;password&quot;: &quot;string&quot;,    &quot;confirmPassword&quot;: &quot;string&quot;&#125;\n\n验证规则:\n&#123;    &quot;username&quot;: &#123;        &quot;required&quot;: true,        &quot;minLength&quot;: 3,        &quot;maxLength&quot;: 20,        &quot;pattern&quot;: &quot;^[a-zA-Z0-9_]+$&quot;    &#125;,    &quot;email&quot;: &#123;        &quot;required&quot;: true,        &quot;format&quot;: &quot;email&quot;    &#125;,    &quot;password&quot;: &#123;        &quot;required&quot;: true,        &quot;minLength&quot;: 8,        &quot;pattern&quot;: &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\\\d@$!%*?&amp;]&quot;    &#125;&#125;\n\n成功响应 (201):\n&#123;    &quot;success&quot;: true,    &quot;message&quot;: &quot;注册成功&quot;,    &quot;data&quot;: &#123;        &quot;user&quot;: &#123;            &quot;id&quot;: &quot;uuid&quot;,            &quot;username&quot;: &quot;string&quot;,            &quot;email&quot;: &quot;user@example.com&quot;,            &quot;createdAt&quot;: &quot;2025-11-14T10:00:00Z&quot;        &#125;,        &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;    &#125;&#125;\n\n2.2 🔑 用户登录请求:\nPOST /api/v1/auth/loginContent-Type: application/json\n\n请求体:\n&#123;    &quot;username&quot;: &quot;string&quot;,    &quot;password&quot;: &quot;string&quot;&#125;\n\n成功响应 (200):\n&#123;    &quot;success&quot;: true,    &quot;message&quot;: &quot;登录成功&quot;,    &quot;data&quot;: &#123;        &quot;user&quot;: &#123;            &quot;id&quot;: &quot;uuid&quot;,            &quot;username&quot;: &quot;string&quot;,            &quot;email&quot;: &quot;user@example.com&quot;,            &quot;lastLoginAt&quot;: &quot;2025-11-14T10:00:00Z&quot;        &#125;,        &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;,        &quot;expiresIn&quot;: 86400    &#125;&#125;\n\n2.3 🌐 OAuth 集成graph TD    A[用户点击Google登录] --&gt; B[重定向到Google OAuth]    B --&gt; C[用户授权]    C --&gt; D[Google回调处理]    D --&gt; E[创建或查找用户]    E --&gt; F[生成JWT Token]    F --&gt; G[重定向到应用]    style A fill:#e1f5fe    style G fill:#e8f5e8\n\n\n3. 📁 文件管理3.1 📤 单文件上传sequenceDiagram    participant C as Client    participant S as API Server    participant F as File Storage    participant D as Database    C-&gt;&gt;S: POST /files/upload (multipart/form-data)    S-&gt;&gt;S: 验证认证Token    S-&gt;&gt;S: 文件类型和大小验证    S-&gt;&gt;S: 生成唯一文件名    S-&gt;&gt;F: 保存文件    F--&gt;&gt;S: 返回文件信息    S-&gt;&gt;D: 保存文件元数据    D--&gt;&gt;S: 返回保存结果    S--&gt;&gt;C: 返回上传结果\n\n接口详情请求:\nPOST /api/v1/files/uploadAuthorization: Bearer &lt;token&gt;Content-Type: multipart/form-data\n\n请求体:\nfile: &lt;binary_data&gt;\n\n成功响应 (200):\n&#123;    &quot;success&quot;: true,    &quot;message&quot;: &quot;文件上传成功&quot;,    &quot;data&quot;: &#123;        &quot;file&quot;: &#123;            &quot;id&quot;: &quot;uuid&quot;,            &quot;name&quot;: &quot;document.pdf&quot;,            &quot;originalName&quot;: &quot;我的文档.pdf&quot;,            &quot;size&quot;: 1048576,            &quot;mimeType&quot;: &quot;application/pdf&quot;,            &quot;path&quot;: &quot;/uploads/2025/11/14/uuid-document.pdf&quot;,            &quot;uploadTime&quot;: &quot;2025-11-14T10:00:00Z&quot;,            &quot;checksum&quot;: &quot;sha256:abc123...&quot;        &#125;    &#125;&#125;\n\n3.2 📦 多文件上传请求:\nPOST /api/v1/files/multi-uploadAuthorization: Bearer &lt;token&gt;Content-Type: multipart/form-data\n\n限制:\n\n最大文件数量: 10个\n单文件最大大小: 100MB\n总大小限制: 500MB\n\n成功响应 (200):\n&#123;    &quot;success&quot;: true,    &quot;message&quot;: &quot;文件上传成功&quot;,    &quot;data&quot;: &#123;        &quot;uploaded&quot;: [            &#123;                &quot;id&quot;: &quot;uuid1&quot;,                &quot;name&quot;: &quot;file1.pdf&quot;,                &quot;size&quot;: 1048576,                &quot;path&quot;: &quot;/uploads/uuid1-file1.pdf&quot;            &#125;,            &#123;                &quot;id&quot;: &quot;uuid2&quot;,                &quot;name&quot;: &quot;file2.jpg&quot;,                &quot;size&quot;: 2097152,                &quot;path&quot;: &quot;/uploads/uuid2-file2.jpg&quot;            &#125;        ],        &quot;failed&quot;: [],        &quot;summary&quot;: &#123;            &quot;total&quot;: 2,            &quot;uploaded&quot;: 2,            &quot;failed&quot;: 0,            &quot;totalSize&quot;: 3145728        &#125;    &#125;&#125;\n\n3.3 📋 获取文件列表请求:\nGET /api/v1/files/list?page=1&amp;limit=20&amp;sort=name&amp;order=ascAuthorization: Bearer &lt;token&gt;\n\n查询参数:\n\n\n\n参数\n类型\n默认值\n说明\n\n\n\npage\ninteger\n1\n页码\n\n\nlimit\ninteger\n20\n每页数量 (1-100)\n\n\nsort\nstring\nname\n排序字段 (name, size, uploadTime)\n\n\norder\nstring\ndesc\n排序方向 (asc, desc)\n\n\nsearch\nstring\n-\n搜索文件名\n\n\ntype\nstring\n-\n文件类型过滤\n\n\n成功响应 (200):\n&#123;    &quot;success&quot;: true,    &quot;message&quot;: &quot;Success&quot;,    &quot;data&quot;: &#123;        &quot;files&quot;: [            &#123;                &quot;id&quot;: &quot;uuid&quot;,                &quot;name&quot;: &quot;document.pdf&quot;,                &quot;size&quot;: 1048576,                &quot;mimeType&quot;: &quot;application/pdf&quot;,                &quot;path&quot;: &quot;/api/v1/files/download/uuid-document.pdf&quot;,                &quot;uploadTime&quot;: &quot;2025-11-14T10:00:00Z&quot;,                &quot;downloadCount&quot;: 5,                &quot;thumbnail&quot;: &quot;/api/v1/files/thumbnail/uuid-document.jpg&quot;            &#125;        ],        &quot;pagination&quot;: &#123;            &quot;page&quot;: 1,            &quot;limit&quot;: 20,            &quot;total&quot;: 100,            &quot;totalPages&quot;: 5,            &quot;hasNext&quot;: true,            &quot;hasPrev&quot;: false        &#125;,        &quot;stats&quot;: &#123;            &quot;totalFiles&quot;: 100,            &quot;totalSize&quot;: 1073741824,            &quot;totalDownloads&quot;: 1250        &#125;    &#125;&#125;\n\n3.4 ⬇️ 文件下载请求:\nGET /api/v1/files/download/:filenameAuthorization: Bearer &lt;token&gt;\n\nURL 参数:\n\nfilename: 文件名或文件ID\n\n功能特性:\n\n✅ 支持断点续传\n✅ 下载统计\n✅ 访问权限验证\n✅ 下载日志记录\n\n响应头:\nContent-Type: application/octet-streamContent-Disposition: attachment; filename=&quot;document.pdf&quot;Content-Length: 1048576Accept-Ranges: bytesETag: &quot;abc123...&quot;Last-Modified: Wed, 14 Nov 2025 10:00:00 GMT\n\n\n4. 📎 文件支持4.1 🎨 允许的文件类型graph TD    A[支持的文件类型] --&gt; B[图片文件]    A --&gt; C[文档文件]    A --&gt; D[压缩文件]    A --&gt; E[代码文件]    B --&gt; B1[image/*]    B --&gt; B2[jpeg, png, gif, webp]    C --&gt; C1[application/pdf]    C --&gt; C2[application/msword]    C --&gt; C3[text/plain]    D --&gt; D1[application/zip]    D --&gt; D2[application/x-rar-compressed]    E --&gt; E1[text/x-code]    E --&gt; E2[application/json]\n\n详细MIME类型列表:\n&#123;    &quot;images&quot;: [&quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;, &quot;image/webp&quot;, &quot;image/svg+xml&quot;],    &quot;documents&quot;: [        &quot;application/pdf&quot;,        &quot;application/msword&quot;,        &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;,        &quot;application/vnd.ms-excel&quot;,        &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;,        &quot;text/plain&quot;,        &quot;text/markdown&quot;    ],    &quot;archives&quot;: [        &quot;application/zip&quot;,        &quot;application/x-rar-compressed&quot;,        &quot;application/x-7z-compressed&quot;    ],    &quot;code&quot;: [        &quot;text/x-code&quot;,        &quot;application/json&quot;,        &quot;text/xml&quot;,        &quot;application/xml&quot;    ]&#125;\n\n4.2 📏 文件大小限制\n\n\n文件类型\n最大大小\n说明\n\n\n\n图片文件\n50MB\nJPEG, PNG, GIF等\n\n\nPDF文档\n100MB\nPDF文档\n\n\nOffice文档\n100MB\nWord, Excel, PowerPoint\n\n\n压缩文件\n200MB\nZIP, RAR, 7Z\n\n\n其他文件\n50MB\n其他允许的类型\n\n\n4.3 🖼️ 缩略图生成graph LR    A[上传文件] --&gt; B&#123;是否为图片?&#125;    B --&gt;|是| C[生成缩略图]    B --&gt;|否| D[使用默认图标]    C --&gt; E[存储缩略图]    D --&gt; F[返回图标路径]    E --&gt; G[返回缩略图URL]\n\n缩略图规格:\n\n尺寸: 200x200 像素\n格式: JPEG\n质量: 85%\n存储路径: /thumbnails/{file_id}.jpg\n\n\n5. ❌ 错误处理5.1 📊 标准错误响应格式&#123;    &quot;success&quot;: false,    &quot;error&quot;: &#123;        &quot;code&quot;: &quot;ERROR_CODE&quot;,        &quot;message&quot;: &quot;用户友好的错误描述&quot;,        &quot;details&quot;: &quot;详细错误信息（开发环境）&quot;,        &quot;timestamp&quot;: &quot;2025-11-14T10:00:00Z&quot;,        &quot;path&quot;: &quot;/api/v1/files/upload&quot;    &#125;,    &quot;requestId&quot;: &quot;uuid-for-tracking&quot;&#125;\n\n5.2 📋 HTTP 状态码\n\n\n状态码\n说明\n示例场景\n\n\n\n200\n成功\n文件上传成功\n\n\n201\n创建成功\n用户注册成功\n\n\n400\n请求错误\n参数验证失败\n\n\n401\n未认证\nToken无效或过期\n\n\n403\n权限不足\n访问他人文件\n\n\n404\n资源不存在\n文件不存在\n\n\n409\n冲突\n用户名已存在\n\n\n413\n文件过大\n超过大小限制\n\n\n415\n不支持的类型\n文件类型不允许\n\n\n422\n验证失败\n业务逻辑验证失败\n\n\n429\n请求过多\n超出速率限制\n\n\n500\n服务器错误\n内部服务器错误\n\n\n5.3 🔧 错误代码定义const ErrorCodes = &#123;    // 认证相关    AUTH_TOKEN_MISSING: &#x27;AUTH_001&#x27;,    AUTH_TOKEN_INVALID: &#x27;AUTH_002&#x27;,    AUTH_TOKEN_EXPIRED: &#x27;AUTH_003&#x27;,    // 用户相关    USER_NOT_FOUND: &#x27;USER_001&#x27;,    USER_ALREADY_EXISTS: &#x27;USER_002&#x27;,    USER_CREDENTIALS_INVALID: &#x27;USER_003&#x27;,    // 文件相关    FILE_NOT_FOUND: &#x27;FILE_001&#x27;,    FILE_TOO_LARGE: &#x27;FILE_002&#x27;,    FILE_TYPE_NOT_ALLOWED: &#x27;FILE_003&#x27;,    FILE_UPLOAD_FAILED: &#x27;FILE_004&#x27;,    // 系统相关    RATE_LIMIT_EXCEEDED: &#x27;SYS_001&#x27;,    MAINTENANCE_MODE: &#x27;SYS_002&#x27;,    QUOTA_EXCEEDED: &#x27;SYS_003&#x27;&#125;;\n\n\n6. 🔒 安全机制6.1 🛡️ 认证与授权graph TD    A[客户端请求] --&gt; B[JWT验证]    B --&gt; C&#123;Token有效?&#125;    C --&gt;|否| D[返回401错误]    C --&gt;|是| E[权限检查]    E --&gt; F&#123;权限充足?&#125;    F --&gt;|否| G[返回403错误]    F --&gt;|是| H[处理请求]    H --&gt; I[返回响应]\n\nJWT Token 结构&#123;    &quot;header&quot;: &#123;        &quot;alg&quot;: &quot;HS256&quot;,        &quot;typ&quot;: &quot;JWT&quot;    &#125;,    &quot;payload&quot;: &#123;        &quot;sub&quot;: &quot;user_id&quot;,        &quot;username&quot;: &quot;string&quot;,        &quot;email&quot;: &quot;user@example.com&quot;,        &quot;role&quot;: &quot;user&quot;,        &quot;iat&quot;: 1640000000,        &quot;exp&quot;: 1640086400    &#125;&#125;\n\n6.2 🔐 密码安全// 密码加密示例const bcrypt = require(&#x27;bcrypt&#x27;);const hashPassword = async (password) =&gt; &#123;    const saltRounds = 12;    return await bcrypt.hash(password, saltRounds);&#125;;const verifyPassword = async (password, hash) =&gt; &#123;    return await bcrypt.compare(password, hash);&#125;;\n\n6.3 📝 输入验证文件名验证:\n&#123;    &quot;filename&quot;: &#123;        &quot;required&quot;: true,        &quot;pattern&quot;: &quot;^[a-zA-Z0-9._-]+$&quot;,        &quot;maxLength&quot;: 255,        &quot;sanitize&quot;: true    &#125;&#125;\n\nSQL注入防护:\n\n使用参数化查询\n输入转义和过滤\n最小权限原则\n\n\n7. ⏱️ 速率限制7.1 🚦 限制策略graph LR    A[请求] --&gt; B[速率限制检查]    B --&gt; C&#123;超出限制?&#125;    C --&gt;|是| D[返回429错误]    C --&gt;|否| E[处理请求]    E --&gt; F[更新计数器]    style D fill:#ffcdd2    style F fill:#c8e6c9\n\n7.2 📊 限制规则\n\n\n端点类型\n时间窗口\n最大请求数\n说明\n\n\n\n认证相关\n15分钟\n5次&#x2F;IP\n登录、注册\n\n\n文件上传\n1小时\n50次&#x2F;用户\n单文件上传\n\n\n文件下载\n1小时\n200次&#x2F;用户\n文件下载\n\n\n其他API\n15分钟\n100次&#x2F;IP\n一般请求\n\n\n7.3 📈 限制响应头HTTP/1.1 429 Too Many RequestsX-RateLimit-Limit: 5X-RateLimit-Remaining: 0X-RateLimit-Reset: 1640090000Retry-After: 900\n\n\n8. 📋 OpenAPI 规范8.1 🔍 Swagger 配置openapi: 3.0.0info:  title: 文件管理系统 API  description: 基于JWT认证的文件管理系统API文档  version: 1.0.0  contact:    name: API Support    email: support@example.com  license:    name: MIT    url: https://opensource.org/licenses/MITservers:  - url: https://api.example.com/api/v1    description: 生产环境  - url: https://dev-api.example.com/api/v1    description: 开发环境security:  - bearerAuth: []components:  securitySchemes:    bearerAuth:      type: http      scheme: bearer      bearerFormat: JWT\n\n8.2 📝 API 文档生成访问 Swagger UI:\n\n生产环境: https://api.example.com/docs\n开发环境: https://dev-api.example.com/docs\n\n下载 OpenAPI 规范:\ncurl -o api-spec.json https://api.example.com/api-spec\n\n\n📊 API 使用统计9.1 📈 使用情况监控graph TD    A[API请求] --&gt; B[记录请求日志]    B --&gt; C[更新统计数据]    C --&gt; D[实时监控面板]    E[错误请求] --&gt; F[错误日志记录]    F --&gt; G[告警系统]    G --&gt; H[运维团队]\n\n9.2 🔍 分析指标\n\n\n指标\n说明\n用途\n\n\n\n请求量\nAPI调用次数\n性能分析\n\n\n响应时间\n平均响应时间\n性能优化\n\n\n错误率\n4xx&#x2F;5xx错误比例\n系统稳定性\n\n\n并发用户\n同时在线用户数\n容量规划\n\n\n\n📚 客户端集成10.1 🖥️ JavaScript 客户端示例class FileManagerAPI &#123;    constructor(baseURL) &#123;        this.baseURL = baseURL;        this.token = null;    &#125;    setToken(token) &#123;        this.token = token;    &#125;    async request(method, endpoint, data = null, options = &#123;&#125;) &#123;        const config = &#123;            method,            headers: &#123;                &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,                ...options.headers            &#125;        &#125;;        if (this.token) &#123;            config.headers.Authorization = `Bearer $&#123;this.token&#125;`;        &#125;        if (data) &#123;            config.body = JSON.stringify(data);        &#125;        const response = await fetch(`$&#123;this.baseURL&#125;$&#123;endpoint&#125;`, config);        return await response.json();    &#125;    // 用户登录    async login(username, password) &#123;        const result = await this.request(&#x27;POST&#x27;, &#x27;/auth/login&#x27;, &#123;            username,            password        &#125;);        if (result.success) &#123;            this.setToken(result.data.token);        &#125;        return result;    &#125;    // 上传文件    async uploadFile(file) &#123;        const formData = new FormData();        formData.append(&#x27;file&#x27;, file);        const response = await fetch(`$&#123;this.baseURL&#125;/files/upload`, &#123;            method: &#x27;POST&#x27;,            headers: &#123;                &#x27;Authorization&#x27;: `Bearer $&#123;this.token&#125;`            &#125;,            body: formData        &#125;);        return await response.json();    &#125;    // 获取文件列表    async getFiles(page = 1, limit = 20) &#123;        return await this.request(&#x27;GET&#x27;, `/files/list?page=$&#123;page&#125;&amp;limit=$&#123;limit&#125;`);    &#125;&#125;// 使用示例const api = new FileManagerAPI(&#x27;https://api.example.com/api/v1&#x27;);\n\n\n📋 总结✅ API 特性总览\n🔐 安全认证: JWT Token 认证机制\n📁 文件管理: 完整的文件上传下载功能\n🎯 权限控制: 用户级别的访问控制\n⚡ 性能优化: 支持断点续传和缩略图\n📊 监控统计: 完整的API使用统计\n📝 文档完整: 详细的API文档和示例\n\n🚀 集成建议\n前端应用: 使用 JavaScript SDK 快速集成\n移动应用: 使用 RESTful API 进行数据交互\n第三方服务: 通过 Webhook 接收文件事件通知\n企业集成: 支持 SSO 和企业级权限管理\n\n🔧 扩展功能\n🔄 文件同步: 多设备文件同步\n📤 分享链接: 生成文件分享链接\n🔍 全文搜索: 文件内容全文检索\n🗂️ 版本管理: 文件版本历史记录\n📱 移动端: 专用的移动端API\n\n\n\n💡 使用提示:\n\n所有API调用都需要有效的JWT Token\n建议使用HTTPS确保传输安全\n定期轮换API密钥和密码\n监控API使用情况避免超出配额限制\n\n\n","categories":["Web架构安全"],"tags":["技术文档","指南"]},{"title":"OpenSSL mTLS Windows 指南","url":"/posts/d1520bc/","content":"OpenSSL mTLS Windows 指南目录\n概述\n第一步：在 Windows 上安装 OpenSSL\n第二步：生成根证书 (CA)\n第三步：生成服务器证书\n第四步：生成客户端证书\n第五步：验证与打包\n附录A：Windows 批处理自动化脚本\n附录B：在 IIS 中配置双向认证\n附录C：在 Nginx for Windows 中配置双向认证\n附录D：生成 DH 参数 (可选)\n附录E：常用 OpenSSL 命令\n\n概述双向认证（Mutual TLS, mTLS）是一种高安全性的认证模式，它要求客户端和服务器双方都出示并验证对方的数字证书，从而确保通信双方的身份都是可信的。本指南将详细介绍如何在 Windows 系统上使用 OpenSSL 创建一套完整的、用于双向认证的证书。\nWindows 环境注意事项\nWindows 系统默认不包含 OpenSSL，需要单独安装\n路径分隔符使用反斜杠 \\\n批处理脚本使用 .bat 格式\n文件权限管理与 Linux 不同\n\n第一步：在 Windows 上安装 OpenSSL方法1：使用 Chocolatey (推荐)# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://community.chocolatey.org/install.ps1&#x27;))# OpenSSL mTLS Windows 指南choco install openssl -y\n\n方法2：手动下载安装\n访问 https://slproweb.com/products/Win32OpenSSL.html\n下载适合您系统的版本（Light 版本即可）\n运行安装程序，选择安装路径（如 C:\\OpenSSL-Win64）\n将 OpenSSL 的 bin 目录添加到系统 PATH 环境变量\n\n验证安装打开命令提示符或 PowerShell：\nopenssl version\n\n第二步：生成根证书 (CA)CA 是整个信任体系的基础，其私钥必须被严格保管。\n1. 创建工作目录# OpenSSL mTLS Windows 指南mkdir C:\\certscd C:\\certs\n\n2. 创建 CA 私钥# OpenSSL mTLS Windows 指南openssl genrsa -out ca.key 4096\n\n3. 创建自签名的 CA 证书使用上一步的私钥，创建一个有效期为10年的根证书。\n# OpenSSL mTLS Windows 指南openssl req -new -x509 -days 3650 -key ca.key -out ca.crt ^  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=MyOrg CA/CN=MyRootCA&quot;\n\n第三步：生成服务器证书服务器证书用于向客户端证明其身份，其 CN (Common Name) 或 SAN (Subject Alternative Name) 必须与服务器的域名或 IP 地址匹配。\n1. 创建服务器私钥openssl genrsa -out server.key 2048\n\n2. 创建服务器证书签名请求 (CSR)CSR 文件包含了服务器的公钥和身份信息，将用于向 CA 申请签名。\nopenssl req -new -key server.key -out server.csr ^  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=MyOrg/CN=server.your_domain.com&quot;\n\n3. 创建扩展配置文件 (v3.ext)创建文本文件 v3.ext，内容如下：\nauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, keyEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]DNS.1 = server.your_domain.comDNS.2 = api.your_domain.comIP.1 = 192.168.1.100\n\n4. 使用 CA 签发服务器证书# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial ^  -days 365 -sha256 -extfile v3.ext -out server.crt\n\n第四步：生成客户端证书客户端证书用于向服务器证明客户端的身份。\n1. 创建客户端私钥openssl genrsa -out client.key 2048\n\n2. 创建客户端 CSRopenssl req -new -key client.key -out client.csr ^  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=MyOrg/CN=my_client_id&quot;\n\n3. 创建客户端扩展配置文件创建文本文件 v3_client.ext，内容如下：\nauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignatureextendedKeyUsage = clientAuth\n\n4. 使用 CA 签发客户端证书# OpenSSL mTLS Windows 指南openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial ^  -days 365 -sha256 -extfile v3_client.ext -out client.crt\n\n第五步：验证与打包1. 验证证书链# OpenSSL mTLS Windows 指南openssl verify -CAfile ca.crt server.crt# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南openssl verify -CAfile ca.crt client.crt# OpenSSL mTLS Windows 指南\n\n2. 打包为 PKCS#12 (.p12) 格式 (可选).p12 文件是一个加密的容器，可以同时包含证书和私钥，方便在各种应用（如浏览器、Java KeyStore）中导入。\n# OpenSSL mTLS Windows 指南echo Creating PKCS#12 file...openssl pkcs12 -export -out client.p12 -inkey client.key -in client.crt -certfile ca.crt ^  -name &quot;My Client Certificate&quot;# OpenSSL mTLS Windows 指南openssl pkcs12 -info -in client.p12 -nodes# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南\n\n附录A：Windows 批处理自动化脚本将以下内容保存为 generate_certs.bat，双击运行或在命令提示符中执行即可一键生成所有证书。\n@echo offsetlocal enabledelayedexpansionecho === Generating Mutual TLS Certificates on Windows ===:: --- Configuration ---set COUNTRY=CNset STATE=Beijingset CITY=Beijingset ORG=MyOrganizationset DOMAIN=your_domain.comset CERT_DAYS=365set KEY_SIZE=2048:: --- Clean up old files ---echo Cleaning up old certificate files...del /Q *.key *.crt *.csr *.p12 *.srl v3*.ext 2&gt;nul:: 1. Generate CA Certificateecho [1/4] Generating CA certificate...openssl genrsa -out ca.key %KEY_SIZE%openssl req -new -x509 -days 3650 -key ca.key -out ca.crt ^  -subj &quot;/C=%COUNTRY%/ST=%STATE%/L=%CITY%/O=%ORG% CA/CN=MyRootCA&quot;:: 2. Generate Server Certificateecho [2/4] Generating Server certificate...openssl genrsa -out server.key %KEY_SIZE%openssl req -new -key server.key -out server.csr ^  -subj &quot;/C=%COUNTRY%/ST=%STATE%/L=%CITY%/O=%ORG%/CN=server.%DOMAIN%&quot;:: Create server extension file(echo authorityKeyIdentifier=keyid,issuerecho basicConstraints=CA:FALSEecho keyUsage = digitalSignature, keyEnciphermentecho extendedKeyUsage = serverAuthecho subjectAltName = @alt_namesecho.echo [alt_names]echo DNS.1 = server.%DOMAIN%echo DNS.2 = localhostecho DNS.3 = api.%DOMAIN%echo IP.1 = 127.0.0.1) &gt; v3_server.extopenssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial ^  -days %CERT_DAYS% -sha256 -extfile v3_server.ext -out server.crt:: 3. Generate Client Certificateecho [3/4] Generating Client certificate...openssl genrsa -out client.key %KEY_SIZE%openssl req -new -key client.key -out client.csr ^  -subj &quot;/C=%COUNTRY%/ST=%STATE%/L=%CITY%/O=%ORG%/CN=client1&quot;:: Create client extension file(echo authorityKeyIdentifier=keyid,issuerecho basicConstraints=CA:FALSEecho keyUsage = digitalSignatureecho extendedKeyUsage = clientAuth) &gt; v3_client.extopenssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial ^  -days %CERT_DAYS% -sha256 -extfile v3_client.ext -out client.crt:: 4. Verify and Packageecho [4/4] Verifying and packaging certificates...openssl verify -CAfile ca.crt server.crtopenssl verify -CAfile ca.crt client.crtecho Creating PKCS#12 file...echo Please enter password when prompted:openssl pkcs12 -export -out client.p12 -inkey client.key -in client.crt -certfile ca.crt ^  -name &quot;MyClientCert&quot;:: --- Clean up temporary files ---echo Cleaning up temporary files...del /Q *.csr *.srl v3*.ext 2&gt;nulecho.echo === All certificates generated successfully! ===echo.echo Files created:echo   ca.key    - CA private key (KEEP SECRET!)echo   ca.crt    - CA certificateecho   server.key - Server private keyecho   server.crt - Server certificateecho   client.key - Client private keyecho   client.crt - Client certificateecho   client.p12 - PKCS#12 bundle (if created)echo.echo === Next Steps ===echo 1. Import client.p12 into Windows Certificate Store (double-click)echo 2. Export CA certificate (ca.crt) to trusted root CAsecho 3. Configure your web server (IIS/Nginx) for mTLSpause\n\n附录B：在 IIS 中配置双向认证1. 导入服务器证书# OpenSSL mTLS Windows 指南Import-Module WebAdministration# OpenSSL mTLS Windows 指南$certPath = &quot;C:\\certs\\server.p12&quot;$certPassword = ConvertTo-SecureString -String &quot;YourPassword&quot; -Force -AsPlainTextImport-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\\LocalMachine\\My -Password $certPassword\n\n2. 将 CA 证书添加到受信任的根证书颁发机构# OpenSSL mTLS Windows 指南certmgr.msc# OpenSSL mTLS Windows 指南certutil -addstore &quot;Root&quot; &quot;C:\\certs\\ca.crt&quot;\n\n3. 配置 SSL 设置# OpenSSL mTLS Windows 指南Get-WebBinding -Name &quot;Default Web Site&quot; -Protocol &quot;https&quot; | Set-WebBindingProperty -Name &quot;sslFlags&quot; -Value &quot;Ssl, SslRequireCert&quot;\n\n4. 通过 IIS 管理器配置\n打开 IIS 管理器\n选择您的网站\n双击 “SSL 设置”\n勾选 “要求 SSL”\n勾选 “要求客户端证书”\n选择 “接受” 或 “要求”\n\n附录C：在 Nginx for Windows 中配置双向认证基础配置编辑 nginx.conf 文件：\nserver &#123;    listen 443 ssl http2;    server_name server.your_domain.com;    # SSL 证书配置    ssl_certificate         C:/certs/server.crt;    ssl_certificate_key     C:/certs/server.key;    # mTLS 配置 - CA 证书用于验证客户端    ssl_client_certificate  C:/certs/ca.crt;    ssl_verify_client       on;    ssl_verify_depth        2;    # SSL 安全配置    ssl_protocols           TLSv1.2 TLSv1.3;    ssl_ciphers             ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384;    ssl_prefer_server_ciphers on;    location / &#123;        # 设置客户端证书信息到环境变量        proxy_set_header X-SSL-Client-S-DN $ssl_client_s_dn;        proxy_set_header X-SSL-Client-Verify $ssl_client_verify;        proxy_set_header X-SSL-Client-Cert $ssl_client_cert;        # 你的应用逻辑        root   html;        index  index.html index.htm;    &#125;&#125;\n\n附录D：生成 DH 参数 (可选)Diffie-Hellman (DH) 参数用于密钥交换协议，以实现**完美前向保密 (Perfect Forward Secrecy, PFS)**。\n# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南openssl dhparam -out dhparam.pem 2048# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南\n\n附录E：常用 OpenSSL 命令Windows 证书管理命令# OpenSSL mTLS Windows 指南certmgr.msc# OpenSSL mTLS Windows 指南certutil -store MY &gt; certificates.txt# OpenSSL mTLS Windows 指南certutil -verify certificate.cer# OpenSSL mTLS Windows 指南certutil -addstore &quot;Root&quot; ca.crtcertutil -addstore &quot;My&quot; server.crt\n\nOpenSSL 命令\n查看证书内容: openssl x509 -in mycert.crt -text -noout\n查看证书有效期: openssl x509 -in mycert.crt -dates -noout\n查看证书序列号: openssl x509 -in mycert.crt -noout -serial\n查看证书指纹: openssl x509 -in mycert.crt -noout -fingerprint -sha256\n查看私钥内容: openssl rsa -in mykey.key -text -noout\n移除私钥密码: openssl rsa -in encrypted.key -out decrypted.key\n加密私钥: openssl rsa -in decrypted.key -aes256 -out encrypted.key\n验证证书链: openssl verify -CAfile ca.crt server.crt\n验证私钥与证书是否匹配:# 方法1：比较模数openssl x509 -noout -modulus -in mycert.crt | openssl md5openssl rsa -noout -modulus -in mykey.key | openssl md5# 两个命令的输出应完全一致\n\nWindows 特定操作# OpenSSL mTLS Windows 指南# OpenSSL mTLS Windows 指南openssl x509 -outform der -in certificate.pem -out certificate.der# OpenSSL mTLS Windows 指南openssl x509 -inform der -in certificate.der -out certificate.pem# OpenSSL mTLS Windows 指南certutil -store MY &gt; my_certificates.txt# OpenSSL mTLS Windows 指南openssl s_client -connect server.domain.com:443 -cert client.crt -key client.key\n\n故障排除常见问题\nOpenSSL 命令未找到\n\n确认 OpenSSL 已安装\n检查 PATH 环境变量是否包含 OpenSSL bin 目录\n\n\n证书验证失败\n\n检查证书文件路径是否正确\n确认 CA 证书已正确导入到受信任的根证书存储\n\n\nIIS 配置问题\n\n确认服务器证书已正确安装\n检查 SSL 绑定设置\n\n\n批处理脚本执行失败\n\n以管理员身份运行\n检查文件权限\n\n\n\n调试命令# OpenSSL mTLS Windows 指南openssl s_client -connect localhost:443 -showcerts# OpenSSL mTLS Windows 指南openssl verify -CAfile ca.crt -untrusted intermediate.crt server.crt# OpenSSL mTLS Windows 指南type C:\\nginx\\logs\\error.log","categories":["后端服务架构","安全与证书"],"tags":["Windows","SSL","OpenSSL","TLS","mTLS","双向认证","CA","证书","DH"]},{"title":"Web 认证方法指南","url":"/posts/f2ed900f/","content":"Web 认证方法指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: web, authentication, authorization, security, session, jwt, oauth\n\n📑 目录\n1. 核心概念\n1.1 认证 vs. 授权\n\n\n2. Session-Cookie 认证\n2.1 工作原理\n2.2 实现示例\n2.3 优缺点\n\n\n3. Token 认证（JWT）\n3.1 工作原理\n3.2 实现示例\n3.3 优缺点\n\n\n4. OAuth 认证\n4.1 认证流程\n4.2 实现示例\n\n\n5. 方案对比与选择\n5.1 对比表\n5.2 使用场景\n\n\n\n\n1. 核心概念1.1 🔍 认证 vs. 授权\n\n\n概念\n问题\n解决方案\n示例\n\n\n\n认证\n“你是谁？”\n验证用户身份\n用户名密码登录\n\n\n授权\n“你能做什么？”\n验证用户权限\n是否允许删除文章\n\n\ngraph LR    A[用户] --&gt; B[认证 Authentication]    B --&gt; C[你是谁？]    B --&gt; D[身份验证]    D --&gt; E[授权 Authorization]    E --&gt; F[你能做什么？]    E --&gt; G[权限检查]\n\n\n2. Session-Cookie 认证这是最传统、最易于理解的认证方式。它依赖于服务器端的 Session 存储和客户端的 Cookie。\n2.1 ⚙️ 工作原理sequenceDiagram    participant U as User    participant B as Browser    participant S as Server    participant DB as Session Store    U-&gt;&gt;B: 输入用户名密码    B-&gt;&gt;S: POST /login    S-&gt;&gt;DB: 验证用户凭据    DB--&gt;&gt;S: 返回用户信息    S-&gt;&gt;DB: 创建Session    DB--&gt;&gt;S: 返回Session ID    S--&gt;&gt;B: Set-Cookie: session_id    B-&gt;&gt;S: GET /protected (Cookie)    S-&gt;&gt;DB: 验证Session ID    DB--&gt;&gt;S: 返回Session数据    S--&gt;&gt;B: 返回受保护内容\n\n工作流程：\n\n用户登录，服务器验证用户名和密码\n验证通过后，服务器在内存或数据库中创建唯一的 Session 记录\n服务器通过 Set-Cookie 将 Session ID 返回给浏览器\n浏览器后续请求自动通过 Cookie 携带 Session ID\n服务器验证 Session ID 确认用户身份\n\n2.2 💻 实现示例const express = require(&#x27;express&#x27;);const session = require(&#x27;express-session&#x27;);const app = express();// 配置 session 中间件app.use(session(&#123;  secret: &#x27;your_secret_key&#x27;, // 用于加密 session ID 的密钥，非常重要  resave: false,  saveUninitialized: false,  cookie: &#123;    secure: false, // 生产环境应设为 true (仅 HTTPS)    maxAge: 60000, // 1分钟    httpOnly: true // 防止 XSS 攻击  &#125;&#125;));// 登录路由app.post(&#x27;/login&#x27;, express.json(), (req, res) =&gt; &#123;  const &#123; username, password &#125; = req.body;  // 1. 验证用户名和密码 (这里应为数据库查询和密码比对)  if (username === &#x27;admin&#x27; &amp;&amp; password === &#x27;123456&#x27;) &#123;    // 2. 认证成功，将用户信息存入 session    req.session.isLoggedIn = true;    req.session.user = &#123;      username: username,      loginTime: new Date()    &#125;;    res.json(&#123; message: &#x27;登录成功！&#x27; &#125;);  &#125; else &#123;    res.status(401).json(&#123; error: &#x27;用户名或密码错误&#x27; &#125;);  &#125;&#125;);// 受保护的路由，需要登录才能访问app.get(&#x27;/profile&#x27;, (req, res) =&gt; &#123;  // 3. 检查 session 中是否存在用户信息  if (req.session.isLoggedIn) &#123;    res.json(&#123;      message: `欢迎回来, $&#123;req.session.user.username&#125;`,      loginTime: req.session.user.loginTime    &#125;);  &#125; else &#123;    res.status(401).json(&#123; error: &#x27;请先登录！&#x27; &#125;);  &#125;&#125;);// 登出路由app.post(&#x27;/logout&#x27;, (req, res) =&gt; &#123;  // 4. 销毁 session  req.session.destroy((err) =&gt; &#123;    if (err) &#123;      return res.status(500).json(&#123; error: &#x27;登出失败&#x27; &#125;);    &#125;    res.clearCookie(&#x27;connect.sid&#x27;); // 清除 Cookie    res.json(&#123; message: &#x27;已登出&#x27; &#125;);  &#125;);&#125;);app.listen(3000);\n\n2.3 ✅ 优缺点\n\n\n优点\n缺点\n\n\n\n✅ 技术成熟，易于理解\n❌ 在分布式环境中需要共享 Session 存储\n\n\n✅ 易于控制（服务端可强制失效）\n❌ 依赖 Cookie，跨域场景复杂\n\n\n✅ 安全性较高（httpOnly Cookie）\n❌ 占用服务器存储资源\n\n\n✅ 适合传统的服务器端渲染应用\n❌ CSRF 攻击风险\n\n\n\n3. Token 认证（JWT）这是一种无状态的认证方式。服务器不再存储会话信息，而是将所有认证信息加密后形成一个令牌（Token）。\n3.1 ⚙️ 工作原理sequenceDiagram    participant U as User    participant C as Client    participant S as Server    U-&gt;&gt;C: 输入用户名密码    C-&gt;&gt;S: POST /login    S-&gt;&gt;S: 验证用户凭据    S-&gt;&gt;S: 生成JWT Token    S--&gt;&gt;C: 返回JWT Token    C-&gt;&gt;C: 存储 Token (localStorage)    Note over C,S: 后续请求    C-&gt;&gt;S: GET /api/data&lt;br/&gt;Authorization: Bearer &lt;token&gt;    S-&gt;&gt;S: 验证 Token 签名    S--&gt;&gt;C: 返回数据\n\nJWT 结构：\nHeader.Payload.Signature例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InVzZXIiLCJpYXQiOjE2MzU2Nzg5MDJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n3.2 💻 实现示例const express = require(&#x27;express&#x27;);const jwt = require(&#x27;jsonwebtoken&#x27;);const app = express();const SECRET_KEY = &#x27;your_super_secret_jwt_key&#x27;; // 必须非常复杂，且妥善保管// 登录路由，颁发 Tokenapp.post(&#x27;/login&#x27;, express.json(), (req, res) =&gt; &#123;  const &#123; username, password &#125; = req.body;  // 1. 验证用户名和密码  if (username === &#x27;admin&#x27; &amp;&amp; password === &#x27;123456&#x27;) &#123;    // 2. 认证成功，生成 JWT    const token = jwt.sign(      &#123;        username: username,        role: &#x27;user&#x27;,        iat: Math.floor(Date.now() / 1000) // 签发时间      &#125;, // Payload (有效载荷)，存放用户信息      SECRET_KEY,      &#123; expiresIn: &#x27;1h&#x27; &#125; // Token 有效期 1 小时    );    res.json(&#123;      message: &#x27;登录成功！&#x27;,      token: token,      expiresIn: &#x27;1h&#x27;    &#125;);  &#125; else &#123;    res.status(401).json(&#123; error: &#x27;用户名或密码错误&#x27; &#125;);  &#125;&#125;);// 中间件：验证 Tokenconst authenticateJWT = (req, res, next) =&gt; &#123;  const authHeader = req.headers.authorization;  if (authHeader) &#123;    const token = authHeader.split(&#x27; &#x27;)[1]; // 格式：Bearer &lt;token&gt;    // 3. 验证 Token    jwt.verify(token, SECRET_KEY, (err, decoded) =&gt; &#123;      if (err) &#123;        return res.status(403).json(&#123;          error: &#x27;Token 无效或过期&#x27;,          details: err.message        &#125;);      &#125;      req.user = decoded; // 将解码出的用户信息挂载到 req 对象上      next(); // 验证通过，继续后续处理    &#125;);  &#125; else &#123;    res.status(401).json(&#123; error: &#x27;请求头中没有 Token&#x27; &#125;);  &#125;&#125;;// 受保护的路由，需要有效的 Token 才能访问app.get(&#x27;/profile&#x27;, authenticateJWT, (req, res) =&gt; &#123;  res.json(&#123;    message: `欢迎回来, $&#123;req.user.username&#125;`,    role: req.user.role,    tokenInfo: &#123;      issuedAt: new Date(req.user.iat * 1000),      // 注意：实际应用中应该从其他地方获取过期时间    &#125;  &#125;);&#125;);// Token 刷新路由app.post(&#x27;/refresh&#x27;, express.json(), (req, res) =&gt; &#123;  const &#123; token &#125; = req.body;  if (!token) &#123;    return res.status(401).json(&#123; error: &#x27;需要提供 Token&#x27; &#125;);  &#125;  try &#123;    const decoded = jwt.verify(token, SECRET_KEY, &#123; ignoreExpiration: true &#125;);    // 检查是否在刷新窗口期内（例如：过期后15分钟内）    const now = Math.floor(Date.now() / 1000);    const isWithinRefreshWindow = (now - decoded.exp) &lt; 900; // 15分钟    if (!isWithinRefreshWindow) &#123;      return res.status(403).json(&#123; error: &#x27;Token 过期太久，请重新登录&#x27; &#125;);    &#125;    // 生成新的 Token    const newToken = jwt.sign(      &#123; username: decoded.username, role: decoded.role &#125;,      SECRET_KEY,      &#123; expiresIn: &#x27;1h&#x27; &#125;    );    res.json(&#123; token: newToken &#125;);  &#125; catch (error) &#123;    res.status(403).json(&#123; error: &#x27;无效的 Token&#x27; &#125;);  &#125;&#125;);app.listen(3000);\n\n3.3 ✅ 优缺点\n\n\n优点\n缺点\n\n\n\n✅ 无状态，易于扩展\n❌ Token 一旦签发，在有效期内无法强制失效\n\n\n✅ 天然支持跨域\n❌ Token 管理更复杂（如失效问题）\n\n\n✅ 适合分布式&#x2F;API 服务\n❌ 存储 Token 的安全性问题\n\n\n✅ 减少服务器存储压力\n❌ 需要处理 Token 刷新机制\n\n\n\n4. OAuth 认证OAuth 2.0 是一个授权框架，它允许用户授权第三方应用访问他们存储在另一台服务提供商上的信息，而无需将用户名和密码提供给第三方应用。\n4.1 🔄 认证流程sequenceDiagram    participant U as User    participant C as Client App    participant A as Auth Server    participant R as Resource Server    U-&gt;&gt;C: 点击&quot;使用GitHub登录&quot;    C-&gt;&gt;A: 重定向到授权页面    U-&gt;&gt;A: 登录并授权    A-&gt;&gt;C: 重定向回调 + 授权码    C-&gt;&gt;A: 用授权码交换访问令牌    A-&gt;&gt;C: 返回访问令牌    C-&gt;&gt;R: 用访问令牌请求用户资源    R-&gt;&gt;A: 验证访问令牌    A--&gt;&gt;R: 令牌有效    R--&gt;&gt;C: 返回用户资源\n\n4.2 💻 实现示例const express = require(&#x27;express&#x27;);const axios = require(&#x27;axios&#x27;);const querystring = require(&#x27;querystring&#x27;);const app = express();// GitHub OAuth 配置const GITHUB_CLIENT_ID = &#x27;your_github_client_id&#x27;;const GITHUB_CLIENT_SECRET = &#x27;your_github_client_secret&#x27;;const REDIRECT_URI = &#x27;http://localhost:3000/auth/github/callback&#x27;;// 1. 重定向用户到 GitHubapp.get(&#x27;/auth/github&#x27;, (req, res) =&gt; &#123;  const params = querystring.stringify(&#123;    client_id: GITHUB_CLIENT_ID,    redirect_uri: REDIRECT_URI,    scope: &#x27;user:email&#x27;, // 请求的权限范围    state: Math.random().toString(36).substring(7) // CSRF 保护  &#125;);  const githubAuthUrl = `https://github.com/login/oauth/authorize?$&#123;params&#125;`;  res.redirect(githubAuthUrl);&#125;);// 2. GitHub 回调地址app.get(&#x27;/auth/github/callback&#x27;, async (req, res) =&gt; &#123;  const &#123; code, state &#125; = req.query;  try &#123;    // 3. 用 code 换取 access_token    const tokenResponse = await axios.post(&#x27;https://github.com/login/oauth/access_token&#x27;, &#123;      client_id: GITHUB_CLIENT_ID,      client_secret: GITHUB_CLIENT_SECRET,      code: code,      state: state // 验证 state 防止 CSRF    &#125;, &#123;      headers: &#123; &#x27;Accept&#x27;: &#x27;application/json&#x27; &#125;    &#125;);    const tokenData = tokenResponse.data;    const accessToken = tokenData.access_token;    // 4. 使用 access_token 获取用户信息    const userResponse = await axios.get(&#x27;https://api.github.com/user&#x27;, &#123;      headers: &#123; &#x27;Authorization&#x27;: `token $&#123;accessToken&#125;` &#125;    &#125;);    // 5. 获取用户邮箱（如果设置了邮箱为私有）    const emailResponse = await axios.get(&#x27;https://api.github.com/user/emails&#x27;, &#123;      headers: &#123; &#x27;Authorization&#x27;: `token $&#123;accessToken&#125;` &#125;    &#125;);    const userData = userResponse.data;    const emails = emailResponse.data;    const primaryEmail = emails.find(email =&gt; email.primary)?.email;    // 6. 根据 userData 处理本地用户登录和 session/jwt 创建    const user = await findOrCreateUser(&#123;      githubId: userData.id,      username: userData.login,      email: primaryEmail,      avatar: userData.avatar_url    &#125;);    // 这里可以创建 session 或 JWT    const sessionToken = createSessionForUser(user);    res.redirect(`/dashboard?token=$&#123;sessionToken&#125;`);  &#125; catch (error) &#123;    console.error(&#x27;GitHub OAuth error:&#x27;, error);    res.status(500).json(&#123; error: &#x27;OAuth 授权失败&#x27; &#125;);  &#125;&#125;);// 辅助函数：查找或创建用户async function findOrCreateUser(githubData) &#123;  // 这里应该连接数据库查找或创建用户  // 返回用户对象  return &#123;    id: githubData.githubId,    username: githubData.username,    email: githubData.email,    avatar: githubData.avatar  &#125;;&#125;// 辅助函数：为用户创建会话function createSessionForUser(user) &#123;  // 这里可以创建 JWT 或 session  return &#x27;generated_session_token&#x27;;&#125;app.listen(3000);\n\n\n5. 方案对比与选择5.1 📊 对比表\n\n\n认证方式\n适用场景\n状态管理\n跨域支持\n扩展性\n安全性\n实现复杂度\n\n\n\nSession-Cookie\n传统的服务器端渲染 Web 应用\n有状态\n⚠️ 需要配置\n⚠️ 需要共享存储\n✅ 高\n🟢 简单\n\n\nToken (JWT)\n前后端分离 SPA、移动端 APP、API 接口\n无状态\n✅ 原生支持\n✅ 极好\n✅ 中高\n🟡 中等\n\n\nOAuth\n需要第三方登录功能的任何应用\n混合\n✅ 原生支持\n✅ 极好\n✅ 高\n🔴 复杂\n\n\n5.2 🎯 使用场景🌐 Web 应用\n传统 Web 应用：Session-Cookie\n现代 SPA：JWT Token\n混合模式：JWT + 可选 Session\n\n📱 移动端应用\nNative App：JWT Token\nHybrid App：JWT Token\n小程序：Session-Cookie 或 JWT\n\n🔗 API 服务\nRESTful API：JWT Token\nGraphQL API：JWT Token\n微服务架构：JWT Token\n\n🤝 单点登录 (SSO)\n企业内应用：OAuth 2.0 &#x2F; SAML\n跨平台应用：OAuth 2.0\n第三方登录：OAuth 2.0\n\n5.3 🔄 常见组合graph TD    A[Web应用] --&gt; B[主认证方式]    A --&gt; C[辅助认证方式]    B --&gt; D[Session-Cookie&lt;br/&gt;传统Web应用]    B --&gt; E[JWT Token&lt;br/&gt;SPA/移动端]    B --&gt; F[OAuth&lt;br/&gt;第三方登录]    C --&gt; G[CSRF保护]    C --&gt; H[HTTPS强制]    C --&gt; I[Rate Limiting]    C --&gt; J[输入验证]\n\n现代常见组合：\n\nWeb App：Session 或 JWT + HTTPS + CSRF Protection\nMobile&#x2F;Native App：JWT + HTTPS + Device Fingerprinting\n单点登录：OAuth 或 JWT + Centralized Auth Server\n第三方登录：OAuth + Local Account Binding\n\n\n⚠️ 安全最佳实践无论选择哪种认证方式，都务必遵循以下安全原则：\n\n🔒 使用 HTTPS - 保证传输过程的安全\n🕐 设置合理的过期时间 - Token 和 Session 都不应长期有效\n🛡️ 防范常见攻击：\nXSS (Cross-Site Scripting)\nCSRF (Cross-Site Request Forgery)\n点击劫持 (Clickjacking)\n\n\n📝 记录安全日志 - 监控异常登录行为\n🔄 定期轮换密钥 - 定期更换 JWT 密钥和会话密钥\n✅ 实施最小权限原则 - 只授予必要的权限\n\n\n📚 参考资源\nRFC 6749 - OAuth 2.0\nJWT.io - JWT 在线工具\nOWASP Authentication Cheat Sheet\nExpress.js 官方文档\n\n\n\n💡 提示: 在选择认证方案时，请综合考虑：\n\n应用架构和部署环境\n用户体验需求\n安全性要求\n开发和维护成本\n团队技术栈熟悉度\n\n\n","categories":["Web架构安全"],"tags":["技术文档","指南"]},{"title":"C++ Web 代理设计架构","url":"/posts/95bf2167/","content":"C++ Web 代理设计架构\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: agents, cpp, web-development, specialization, ai-assistants, claude-code\n\n📑 目录\n1. 概述\n2. 设计原则\n3. Agent 架构\n4. 核心团队 Agents\n4.1 Project Architect Agent\n4.2 API Designer Agent\n4.3 Core Logic Developer Agent\n4.4 Web Service Integrator Agent\n4.5 Build &amp; Dependency Expert Agent\n4.6 QA Specialist Agent\n4.7 Deployment Operator Agent\n\n\n5. 协作流程\n6. 使用指南\n7. 扩展和维护\n\n\n1. 📖 概述本指南详细说明如何为 C++ Web 项目创建专门化的 AI Agent 团队，每个 Agent 都具有特定的职责和专业能力，通过协同工作完成从设计到部署的完整开发流程。\n🎯 设计目标\n✅ 专业化分工 - 每个 Agent 专注于特定领域\n✅ 流程标准化 - 建立清晰的开发工作流程\n✅ 质量保证 - 确保代码质量和最佳实践\n✅ 可扩展性 - 支持项目规模和复杂度增长\n✅ 一致性 - 维护项目规范和标准统一\n\n🏗️ 系统架构图graph TB    A[Project Requirements] --&gt; B[Team Lead / Coordinator]    B --&gt; C[Project Architect]    B --&gt; D[API Designer]    B --&gt; E[Core Logic Developer]    B --&gt; F[Web Service Integrator]    B --&gt; G[Build Expert]    B --&gt; H[QA Specialist]    B --&gt; I[Deployment Operator]    C --&gt; J[System Architecture]    C --&gt; K[Technology Stack]    D --&gt; L[API Specifications]    D --&gt; M[Documentation]    E --&gt; N[Business Logic]    E --&gt; O[Core Algorithms]    F --&gt; P[Web Framework Integration]    F --&gt; Q[Request Handling]    G --&gt; R[Build Configuration]    G --&gt; S[Dependency Management]    H --&gt; T[Testing Strategy]    H --&gt; U[Quality Metrics]    I --&gt; V[Containerization]    I --&gt; W[Deployment Scripts]    J --&gt; X[C++ Web Application]    L --&gt; X    N --&gt; X    P --&gt; X    R --&gt; X    T --&gt; X    V --&gt; X\n\n\n2. 🎯 设计原则2.1 🔄 职责分离原则每个 Agent 都应该有明确的职责边界，避免功能重叠：\ngraph LR    A[架构设计] --&gt; B[业务逻辑] --&gt; C[Web集成] --&gt; D[构建部署]    style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#e8f5e8    style D fill:#fff3e0\n\n2.2 📋 可追溯性原则每个产出物都应该能够追溯到创建它的 Agent：\n\n\n\nAgent\n产出物\n可追溯标识\n\n\n\nArchitect\nCMakeLists.txt\n// Generated by: cpp_architect\n\n\nAPI Designer\nOpenAPI spec\n// Designed by: api_designer\n\n\nCore Logic\n.cpp/.hpp files\n// Implemented by: core_logic_developer\n\n\n2.3 🔄 迭代改进原则Agent 应该能够基于反馈进行迭代改进，而不需要完全重写。\n\n3. 🏢 Agent 架构3.1 🔧 标准化 Agent 结构每个 Agent 都遵循统一的模板结构：\n# C++ Web 代理设计架构## Description&#123;详细的角色描述和职责&#125;## Capabilities- &#123;核心能力列表&#125;- &#123;专业技能&#125;- &#123;工具和框架&#125;## Workflow1. &#123;步骤1&#125;2. &#123;步骤2&#125;3. &#123;步骤3&#125;## Input Dependencies- &#123;需要的前置输入&#125;- &#123;依赖的文件或配置&#125;## Output Artifacts- &#123;生成的文件&#125;- &#123;文档产出&#125;- &#123;配置文件&#125;## Collaboration- &#123;与其他 Agent 的协作方式&#125;- &#123;交互接口&#125;- &#123;数据交换格式&#125;\n\n3.2 🔗 Agent 通信协议定义标准化的 Agent 间通信格式：\n&#123;  &quot;agent_name&quot;: &quot;core_logic_developer&quot;,  &quot;task_id&quot;: &quot;task_uuid&quot;,  &quot;inputs&quot;: &#123;    &quot;api_spec&quot;: &quot;path/to/openapi.yaml&quot;,    &quot;architecture&quot;: &quot;path/to/architecture.md&quot;  &#125;,  &quot;outputs&quot;: &#123;    &quot;source_files&quot;: [&quot;src/*.cpp&quot;, &quot;include/*.hpp&quot;],    &quot;unit_tests&quot;: [&quot;tests/*.cpp&quot;]  &#125;,  &quot;metadata&quot;: &#123;    &quot;created_at&quot;: &quot;2025-11-14T10:00:00Z&quot;,    &quot;version&quot;: &quot;1.0&quot;  &#125;&#125;\n\n\n4. 🎭 核心团队 Agents4.1 🏗️ Project Architect AgentAgent: cpp_architectDescription:你是一位经验丰富的 C++ 系统架构师。你的核心职责是为新的 C++ Web 服务项目进行高层次设计和技术选型。你专注于系统的可扩展性、性能和可维护性。\nCapabilities:\n\n系统架构设计和模式选择\nC++ Web 框架技术选型\n性能分析和优化策略\n代码规范和最佳实践制定\n项目结构设计\n依赖关系管理\n\nWorkflow:\n\n需求分析 - 分析项目需求，确定核心模块和组件\n技术选型 - 选择合适的 C++ Web 框架并说明理由\n架构设计 - 设计系统架构图，包括组件关系和数据流\n接口定义 - 定义关键的数据结构、接口和命名空间\n规范制定 - 制定代码规范和项目结构准则\n\nInput Dependencies:\n\n项目需求文档\n性能要求\n部署环境信息\n团队技能水平\n\nOutput Artifacts:\n\ndocs/architecture.md - 架构设计文档\nCMakeLists.txt - 初始构建配置\nproject_structure.txt - 项目目录结构规划\ninclude/core/ - 核心模块头文件草图\n\nCollaboration:\n\n向 API Designer 提供架构约束\n接收 Build Expert 的技术反馈\n指导 Core Logic Developer 的模块设计\n\n\n4.2 📝 API Designer AgentAgent: api_designerDescription:你是一名专注于 API 设计的专家。你的任务是将业务需求转化为一组清晰、符合 RESTful 规范或 RPC 规范的 Web API 接口。\nCapabilities:\n\nRESTful API 设计原则\nOpenAPI&#x2F;Swagger 规范编写\nAPI 文档生成和维护\n数据模型设计\n错误处理和状态码设计\nAPI 版本管理策略\n\nWorkflow:\n\n需求沟通 - 与 cpp_architect 和需求方沟通，理解功能点\n接口设计 - 设计每个 API 端点的 URL 路径、HTTP 方法\n数据格式定义 - 定义请求和响应的数据格式（JSON Schema）\n文档编写 - 编写详细的 API 文档，包括参数说明、状态码和示例\n验证测试 - 创建 API 验证测试用例\n\nInput Dependencies:\n\n业务需求文档\n系统架构设计\n用户故事和用例\n\nOutput Artifacts:\n\napi/openapi.yaml - OpenAPI 规范文件\ndocs/api.md - 人类可读的 API 文档\ninclude/api/dtos.hpp - C++ 数据传输对象定义\ntests/api_validation.cpp - API 验证测试\n\nCollaboration:\n\n从 Architect 获取架构约束\n为 Core Logic Developer 提供数据结构\n与 QA Specialist 协作设计测试用例\n\n\n4.3 ⚙️ Core Logic Developer AgentAgent: core_logic_developerDescription:你是一名纯粹的 C++ 核心逻辑程序员。你只关心业务逻辑和算法的实现，不涉及任何 Web 或网络细节。你编写的代码应该是框架无关的、可测试的。\nCapabilities:\n\n现代 C++ 编程（C++17&#x2F;20）\n算法和数据结构实现\n设计模式应用\n内存管理和性能优化\n异常处理和错误管理\n单元测试编写\n\nWorkflow:\n\n需求理解 - 接收来自 api_designer 的数据结构定义和业务规则\n设计实现 - 实现具体的业务逻辑类、函数和算法\n编码质量 - 确保代码高效、安全（异常处理、内存管理）\n测试编写 - 为每个函数和类编写单元测试\n规范遵循 - 遵循 cpp_architect 制定的代码规范\n\nInput Dependencies:\n\nAPI 数据结构定义\n业务逻辑规则\n性能要求\n代码规范\n\nOutput Artifacts:\n\nsrc/core/*.cpp - 纯净的 C++ 业务逻辑实现\ninclude/core/*.hpp - 核心逻辑头文件\ntests/unit/*.cpp - 单元测试文件\ndocs/core_design.md - 核心逻辑设计文档\n\nCollaboration:\n\n从 API Designer 获取数据模型\n向 Web Service Integrator 提供接口\n与 QA Specialist 协作测试策略\n\n\n4.4 🌐 Web Service Integrator AgentAgent: web_service_integratorDescription:你是一名集成专家，负责将 core_logic_developer 编写的业务逻辑与 cpp_architect 选定的 Web 框架”粘合”在一起。\nCapabilities:\n\nWeb 框架集成（Drogon, Pistache, Crow 等）\nHTTP 请求&#x2F;响应处理\n序列化&#x2F;反序列化（JSON, XML 等）\n路由配置和管理\n中间件开发\n错误处理和日志记录\n\nWorkflow:\n\n框架准备 - 引入 core_logic_developer 创建的库或代码\n控制器开发 - 使用选定的 Web 框架创建控制器\n请求处理 - 在控制器中处理 HTTP 请求，调用业务逻辑\n响应格式化 - 将业务逻辑结果序列化为 HTTP 响应\n路由配置 - 配置路由，将 URL 映射到对应的控制器\n\nInput Dependencies:\n\n选定的 Web 框架\n核心业务逻辑代码\nAPI 接口定义\n系统架构设计\n\nOutput Artifacts:\n\nsrc/web/*.cpp - Web 框架特定的源代码\nsrc/main.cpp - 程序入口文件\nconfig/routes.json - 路由配置文件\ndocs/integration_guide.md - 集成指南\n\nCollaboration:\n\n集成 Core Logic Developer 的代码\n实现 API Designer 定义的接口\n使用 Architect 选择的框架\n\n\n4.5 🔨 Build &amp; Dependency Expert AgentAgent: build_dependency_expertDescription:你是一名构建系统大师，精通 CMake 和 C++ 依赖管理（如 Conan, vcpkg）。你确保项目可以在不同平台上一键构建。\nCapabilities:\n\nCMake 高级配置和优化\n包管理器集成（Conan, vcpkg, Hunter）\n跨平台构建配置\nCI&#x2F;CD 管道设置\n静态分析和代码检查集成\n构建性能优化\n\nWorkflow:\n\n构建配置 - 维护和优化 CMakeLists.txt 文件\n依赖管理 - 管理项目的所有第三方依赖\n编译配置 - 配置编译选项、警告级别、优化设置\n工具集成 - 设置静态分析或代码格式化工具\nCI&#x2F;CD 配置 - 创建持续集成和部署管道\n\nInput Dependencies:\n\n项目架构和依赖需求\n目标平台信息\n团队开发工具链\n\nOutput Artifacts:\n\nCMakeLists.txt - 完整的构建配置\nconanfile.txt - Conan 依赖配置\n.github/workflows/ - CI&#x2F;CD 配置文件\nscripts/build.sh - 构建脚本\ndocs/build_guide.md - 构建指南\n\nCollaboration:\n\n支持所有其他 Agent 的构建需求\n优化整个项目的构建流程\n确保跨平台兼容性\n\n\n4.6 🔍 QA Specialist AgentAgent: qa_specialistDescription:你是一名一丝不苟的质量保证工程师。你为项目的所有关键部分编写全面的测试用例，并确保代码质量标准得到执行。\nCapabilities:\n\n单元测试和集成测试设计\n性能测试和基准测试\n代码覆盖率分析\n静态代码分析\n测试自动化\n质量指标监控\n\nWorkflow:\n\n测试策略 - 制定全面的测试策略和计划\n单元测试 - 为 core_logic_developer 编写的每个函数和类编写单元测试\n集成测试 - 为 web_service_integrator 创建的 API 端点编写集成测试\n质量检查 - 进行代码覆盖率分析和静态代码分析\nCI 集成 - 确保测试融入 CI&#x2F;CD 流程\n\nInput Dependencies:\n\n业务逻辑代码\nAPI 接口定义\n质量标准和要求\n\nOutput Artifacts:\n\ntests/unit/*.cpp - 单元测试\ntests/integration/*.cpp - 集成测试\ntests/performance/*.cpp - 性能测试\n.codecov.yml - 代码覆盖率配置\ndocs/testing_guide.md - 测试指南\n\nCollaboration:\n\n验证 Core Logic Developer 的代码\n测试 Web Service Integrator 的接口\n确保 Deployment Operator 的部署质量\n\n\n4.7 🚀 Deployment Operator AgentAgent: deployment_operatorDescription:你是一名 DevOps 工程师，负责将开发完成的服务打包并部署到目标环境，确保生产环境的稳定性和可靠性。\nCapabilities:\n\n容器化（Docker, Podman）\n容器编排（Docker Compose, Kubernetes）\n配置管理\n监控和日志\n自动化部署脚本\n基础设施即代码\n\nWorkflow:\n\n容器化 - 编写 Dockerfile，创建服务的容器镜像\n编排配置 - 编写 docker-compose.yml 文件，用于一键部署\n脚本编写 - 编写部署脚本或 CI&#x2F;CD 流水线配置\n配置模板 - 生成生产环境配置文件模板\n监控设置 - 配置监控和日志收集\n\nInput Dependencies:\n\n构建好的应用程序\n部署环境信息\n运行时配置需求\n\nOutput Artifacts:\n\nDockerfile - 容器镜像定义\ndocker-compose.yml - 服务编排配置\nscripts/deploy.sh - 部署脚本\nconfig/production.env - 生产环境配置\ndocs/deployment_guide.md - 部署指南\n\nCollaboration:\n\n打包 Build Expert 的构建产物\n部署 Web Service Integrator 的服务\n配置 QA Specialist 批准的版本\n\n\n5. 🔄 协作流程5.1 📋 标准开发流程sequenceDiagram    participant PM as Project Manager    participant A as Architect    participant API as API Designer    participant CL as Core Logic    participant WSI as Web Integrator    participant BE as Build Expert    participant QA as QA Specialist    participant DO as Deployment Operator    PM-&gt;&gt;A: 项目需求    A-&gt;&gt;API: 架构约束    A-&gt;&gt;BE: 技术栈选择    API-&gt;&gt;CL: API 规范    CL-&gt;&gt;WSI: 核心逻辑    WSI-&gt;&gt;BE: 依赖需求    BE-&gt;&gt;QA: 构建配置    QA-&gt;&gt;DO: 测试报告    DO-&gt;&gt;PM: 部署就绪\n\n5.2 🔄 迭代开发流程\nSprint Planning - Architect 和团队确定下一个迭代目标\nAPI Design - API Designer 先行设计接口规范\nParallel Development - Core Logic 和 Web Integrator 并行开发\nIntegration Testing - QA Specialist 执行集成测试\nBuild &amp; Deploy - Build Expert 和 Deployment Operator 完成构建部署\n\n5.3 🚨 错误处理流程graph TD    A[发现错误] --&gt; B&#123;错误类型&#125;    B --&gt;|构建错误| C[Build Expert]    B --&gt;|逻辑错误| D[Core Logic Developer]    B --&gt;|集成错误| E[Web Service Integrator]    B --&gt;|测试失败| F[QA Specialist]    C --&gt; G[修复配置]    D --&gt; H[修复逻辑]    E --&gt; I[修复集成]    F --&gt; J[修复测试]    G --&gt; K[重新验证]    H --&gt; K    I --&gt; K    J --&gt; K    K --&gt; L[错误解决]\n\n\n6. 📖 使用指南6.1 🚀 快速开始步骤 1: 初始化项目/agents create cpp_architect&quot;创建一个新的 C++ Web 项目，需要实现用户管理系统，要求高性能和可扩展性&quot;\n\n步骤 2: 生成架构/agents create api_designer&quot;基于架构设计用户管理系统的 API，包括用户注册、登录、信息管理等接口&quot;\n\n步骤 3: 实现核心逻辑/agents create core_logic_developer&quot;实现用户管理的核心业务逻辑，包括用户验证、密码加密、数据校验等&quot;\n\n6.2 🔧 Agent 管理命令# C++ Web 代理设计架构/agents create &lt;agent_name&gt; &quot;&lt;task_description&gt;&quot;# C++ Web 代理设计架构/agents switch &lt;agent_name&gt;# C++ Web 代理设计架构/agents list# C++ Web 代理设计架构/agents remove &lt;agent_name&gt;# C++ Web 代理设计架构/agents status &lt;agent_name&gt;\n\n6.3 📝 协作最佳实践\n明确依赖关系 - 在每个任务开始前明确依赖的产出物\n版本控制 - 每个 Agent 的产出都应该进行版本管理\n文档同步 - 确保 Agent 间的文档保持同步\n定期同步 - 建立定期的 Agent 同步会议或检查点\n质量门禁 - 每个 Agent 的产出都应该通过质量检查\n\n\n7. 🔄 扩展和维护7.1 ➕ 添加新 Agent当项目需要新的专业能力时，可以添加专门的 Agent：\n# C++ Web 代理设计架构**Description:**你是一名安全专家，专注于确保 C++ Web 应用的安全性。**Capabilities:**- 安全漏洞评估- 加密算法实现- 认证和授权机制- 安全编码规范- 渗透测试\n\n7.2 🔧 Agent 优化定期评估和优化现有 Agent：\n\n性能评估 - 监控 Agent 的工作效率\n质量评估 - 检查 Agent 产出的质量\n能力更新 - 根据新技术更新 Agent 能力\n协作优化 - 改进 Agent 间的协作流程\n\n7.3 📊 Agent 性能指标\n\n\nAgent\n关键指标\n目标值\n\n\n\nArchitect\n架构设计时间\n&lt; 2小时\n\n\nAPI Designer\nAPI 规范完成率\n100%\n\n\nCore Logic\n代码覆盖率\n&gt; 80%\n\n\nWeb Integrator\n集成成功率\n&gt; 95%\n\n\nBuild Expert\n构建成功率\n100%\n\n\nQA Specialist\n缺陷发现率\n&gt; 90%\n\n\nDeployment Operator\n部署成功率\n&gt; 99%\n\n\n\n📊 总结✅ Agent 团队优势\n✅ 专业化分工 - 每个 Agent 专注于特定领域\n✅ 标准化流程 - 建立可重复的开发流程\n✅ 质量保证 - 多层次的质量控制机制\n✅ 可扩展性 - 支持项目规模增长\n✅ 知识传承 - Agent 间共享最佳实践\n\n🎯 实施建议\n从简单开始 - 先创建核心 Agent，逐步完善\n持续迭代 - 根据项目反馈优化 Agent 设计\n文档驱动 - 保持良好的文档习惯\n工具集成 - 集成现有的开发工具和平台\n团队培训 - 确保团队理解 Agent 协作模式\n\n📚 扩展资源\nClaude Code Agent 文档\nC++ Web 框架比较\n现代 C++ 最佳实践\nAPI 设计指南\n\n\n\n💡 提示:\n\nAgent 间的协作需要明确的接口和规范\n定期回顾和优化 Agent 工作流程\n保持 Agent 知识库的更新和维护\n建立有效的质量监控和反馈机制\n\n\n","categories":["软件架构"],"tags":["技术文档","指南"]},{"title":"OpenSSL mTLS 指南","url":"/posts/f4106d49/","content":"OpenSSL mTLS 指南目录\n概述\n第一步：生成根证书 (CA)\n第二步：生成服务器证书\n第三步：生成客户端证书\n第四步：验证与打包\n附录A：完整自动化脚本\n附录B：在 Nginx 中配置双向认证\n附录C：生成 DH 参数 (可选)\n附录D：常用 OpenSSL 命令\n\n概述双向认证（Mutual TLS, mTLS）是一种高安全性的认证模式，它要求客户端和服务器双方都出示并验证对方的数字证书，从而确保通信双方的身份都是可信的。本指南将详细介绍如何使用 OpenSSL 创建一套完整的、用于双向认证的证书。\n证书体系我们将创建以下三类证书：\n\n根证书 (CA): 证书颁发机构，用于签发服务器和客户端证书。它是信任链的顶点。\n服务器证书: 用于向客户端证明服务器的身份。\n客户端证书: 用于向服务器证明客户端的身份。\n\n第一步：生成根证书 (CA)CA 是整个信任体系的基础，其私钥必须被严格保管。\n1. 创建 CA 私钥# OpenSSL mTLS 指南openssl genrsa -out ca.key 4096# OpenSSL mTLS 指南chmod 400 ca.key\n\n2. 创建自签名的 CA 证书使用上一步的私钥，创建一个有效期为10年的根证书。\n# OpenSSL mTLS 指南openssl req -new -x509 -days 3650 -key ca.key -out ca.crt \\  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=MyOrg CA/CN=MyRootCA&quot;\n\n第二步：生成服务器证书服务器证书用于向客户端证明其身份，其 CN (Common Name) 或 SAN (Subject Alternative Name) 必须与服务器的域名或 IP 地址匹配。\n1. 创建服务器私钥openssl genrsa -out server.key 2048chmod 400 server.key\n\n2. 创建服务器证书签名请求 (CSR)CSR 文件包含了服务器的公钥和身份信息，将用于向 CA 申请签名。\nopenssl req -new -key server.key -out server.csr \\  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=MyOrg/CN=server.your_domain.com&quot;\n\n3. 创建扩展配置文件 (v3.ext)为了让证书支持多域名或 IP 地址（SAN），并指定其用途为“服务器认证”，我们需要一个扩展配置文件。\nv3.ext:\nauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]DNS.1 = server.your_domain.comDNS.2 = api.your_domain.comIP.1 = 192.168.1.100\n\n4. 使用 CA 签发服务器证书# OpenSSL mTLS 指南# OpenSSL mTLS 指南openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\  -days 365 -sha256 -extfile v3.ext -out server.crt# OpenSSL mTLS 指南chmod 644 server.crtchmod 400 server.key\n\n第三步：生成客户端证书客户端证书用于向服务器证明客户端的身份。\n1. 创建客户端私钥openssl genrsa -out client.key 2048chmod 400 client.key\n\n2. 创建客户端 CSRopenssl req -new -key client.key -out client.csr \\  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=MyOrg/CN=my_client_id&quot;\n\n3. 修改扩展配置文件为了指定证书用于“客户端认证”，修改 v3.ext 文件中的 extendedKeyUsage。\n# OpenSSL mTLS 指南extendedKeyUsage = clientAuth# OpenSSL mTLS 指南\n\n4. 使用 CA 签发客户端证书# OpenSSL mTLS 指南openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\  -days 365 -sha256 -extfile v3.ext -out client.crt# OpenSSL mTLS 指南chmod 644 client.crtchmod 400 client.key\n\n第四步：验证与打包1. 验证证书链# OpenSSL mTLS 指南openssl verify -CAfile ca.crt server.crt# OpenSSL mTLS 指南# OpenSSL mTLS 指南openssl verify -CAfile ca.crt client.crt# OpenSSL mTLS 指南\n\n2. 打包为 PKCS#12 (.p12) 格式 (可选).p12 文件是一个加密的容器，可以同时包含证书和私钥，方便在各种应用（如浏览器、Java KeyStore）中导入。\n# OpenSSL mTLS 指南echo &quot;Creating PKCS#12 file...&quot;openssl pkcs12 -export -out client.p12 -inkey client.key -in client.crt -certfile ca.crt \\  -name &quot;My Client Certificate&quot;# OpenSSL mTLS 指南openssl pkcs12 -info -in client.p12 -nodes# OpenSSL mTLS 指南# OpenSSL mTLS 指南# OpenSSL mTLS 指南# OpenSSL mTLS 指南\n\n附录A：完整自动化脚本将以下内容保存为 generate_certs.sh，赋予执行权限 (chmod +x) 后运行即可一键生成所有证书。\n#!/bin/bashset -eecho &quot;=== Generating Mutual TLS Certificates ===&quot;# OpenSSL mTLS 指南COUNTRY=&quot;CN&quot;STATE=&quot;Beijing&quot;CITY=&quot;Beijing&quot;ORG=&quot;MyOrganization&quot;DOMAIN=&quot;your_domain.com&quot;CERT_DAYS=365KEY_SIZE=2048# OpenSSL mTLS 指南rm -f *.key *.crt *.csr *.p12 *.srl v3.ext# OpenSSL mTLS 指南echo &quot;[1/4] Generating CA certificate...&quot;openssl genrsa -out ca.key $KEY_SIZEchmod 400 ca.keyopenssl req -new -x509 -days 3650 -key ca.key -out ca.crt \\  -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORG CA/CN=MyRootCA&quot;# OpenSSL mTLS 指南echo &quot;[2/4] Generating Server certificate...&quot;openssl genrsa -out server.key $KEY_SIZEchmod 400 server.keyopenssl req -new -key server.key -out server.csr \\  -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORG/CN=server.$DOMAIN&quot;cat &gt; v3.ext &lt;&lt; EOFauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]DNS.1 = server.$DOMAINDNS.2 = localhostIP.1 = 127.0.0.1EOFopenssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\  -days $CERT_DAYS -sha256 -extfile v3.ext -out server.crt# OpenSSL mTLS 指南echo &quot;[3/4] Generating Client certificate...&quot;openssl genrsa -out client.key $KEY_SIZEchmod 400 client.keyopenssl req -new -key client.key -out client.csr \\  -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORG/CN=client1&quot;# OpenSSL mTLS 指南sed -i -e &#x27;s/serverAuth/clientAuth/g&#x27; v3.extopenssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\  -days $CERT_DAYS -sha256 -extfile v3.ext -out client.crt# OpenSSL mTLS 指南echo &quot;[4/4] Verifying and packaging certificates...&quot;openssl verify -CAfile ca.crt server.crtopenssl verify -CAfile ca.crt client.crt# OpenSSL mTLS 指南echo &quot;Please enter password for PKCS#12 export:&quot;openssl pkcs12 -export -out client.p12 -inkey client.key -in client.crt -certfile ca.crt \\  -name &quot;MyClientCert&quot;# OpenSSL mTLS 指南echo &quot;Cleaning up temporary files...&quot;rm -f *.csr *.srl v3.ext v3.ext-e# OpenSSL mTLS 指南chmod 400 *.keychmod 644 *.crtif [[ -f &quot;client.p12&quot; ]]; then    chmod 400 client.p12fiecho &quot;&quot;echo &quot;=== All certificates generated successfully! ===&quot;echo &quot;&quot;echo &quot;Files created:&quot;echo &quot;  ca.key    - CA private key (KEEP SECRET!)&quot;echo &quot;  ca.crt    - CA certificate&quot;echo &quot;  server.key - Server private key&quot;echo &quot;  server.crt - Server certificate&quot;echo &quot;  client.key - Client private key&quot;echo &quot;  client.crt - Client certificate&quot;echo &quot;  client.p12 - PKCS#12 bundle (if created)&quot;\n\n附录B：在 Nginx 中配置双向认证基础配置server &#123;    listen 443 ssl http2;    server_name server.your_domain.com;    # SSL 证书配置    ssl_certificate         /path/to/server.crt;    ssl_certificate_key     /path/to/server.key;    # mTLS 配置 - CA 证书用于验证客户端    ssl_client_certificate  /path/to/ca.crt;    ssl_verify_client       on;    ssl_verify_depth        2;  # 验证深度    # SSL 安全配置    ssl_protocols           TLSv1.2 TLSv1.3;    ssl_ciphers             ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384;    ssl_prefer_server_ciphers on;    location / &#123;        # 设置客户端证书信息到环境变量        proxy_set_header X-SSL-Client-S-DN $ssl_client_s_dn;        proxy_set_header X-SSL-Client-Verify $ssl_client_verify;        proxy_set_header X-SSL-Client-Cert $ssl_client_cert;        # 你的应用逻辑        proxy_pass http://backend;    &#125;&#125;\n\n可选验证级别# OpenSSL mTLS 指南ssl_verify_client on;# OpenSSL mTLS 指南ssl_verify_client optional;# OpenSSL mTLS 指南ssl_verify_client optional_no_ca;\n\n附录C：生成 DH 参数 (可选)Diffie-Hellman (DH) 参数用于密钥交换协议，以实现**完美前向保密 (Perfect Forward Secrecy, PFS)**。在 Nginx 等服务器上配置 DHE&#x2F;EDH 加密套件时，推荐使用自定义的、强度更高的 DH 参数文件。\n# OpenSSL mTLS 指南# OpenSSL mTLS 指南openssl dhparam -out dhparam.pem 2048# OpenSSL mTLS 指南# OpenSSL mTLS 指南\n\n在 Nginx 配置中，你可以这样使用它：\nserver &#123;    # ...    ssl_certificate         /path/to/server.crt;    ssl_certificate_key     /path/to/server.key;    # 添加 DH 参数文件路径    ssl_dhparam             /path/to/dhparam.pem;    # ...&#125;\n\n附录D：常用 OpenSSL 命令\n查看证书内容: openssl x509 -in mycert.crt -text -noout\n查看证书有效期: openssl x509 -in mycert.crt -dates -noout\n查看证书序列号: openssl x509 -in mycert.crt -noout -serial\n查看证书指纹: openssl x509 -in mycert.crt -noout -fingerprint -sha256\n查看私钥内容: openssl rsa -in mykey.key -text -noout\n查看私钥模数: openssl rsa -in mykey.key -noout -modulus\n移除私钥密码: openssl rsa -in encrypted.key -out decrypted.key\n加密私钥: openssl rsa -in decrypted.key -aes256 -out encrypted.key\n验证证书链: openssl verify -CAfile ca.crt -untrusted intermediate.crt server.crt\n验证私钥与证书是否匹配:# 方法1：比较模数openssl x509 -noout -modulus -in mycert.crt | openssl md5openssl rsa -noout -modulus -in mykey.key | openssl md5# 两个命令的输出应完全一致# 方法2：直接验证openssl x509 -noout -text -in mycert.crt | grep -A1 &quot;RSA Public Key&quot;openssl rsa -noout -text -in mykey.key | grep -A1 &quot;publicExponent&quot;\n\n其他常用命令# OpenSSL mTLS 指南openssl x509 -pubkey -noout -in mycert.crt &gt; pubkey.pem# OpenSSL mTLS 指南openssl rsa -pubout -in mykey.key -out pubkey.pem# OpenSSL mTLS 指南openssl x509 -checkend 0 -noout -in mycert.crt# OpenSSL mTLS 指南openssl x509 -checkend 2592000 -noout -in mycert.crt# OpenSSL mTLS 指南cat server.crt intermediate.crt ca.crt &gt; fullchain.pem","categories":["后端服务架构","安全与证书"],"tags":["SSL","OpenSSL","TLS","mTLS","双向认证","CA","证书","DH"]},{"title":"mTLS 证书生成指南","url":"/posts/cb45c274/","content":"mTLS 证书生成指南📑 目录\n生成 CA 证书\n生成 服务器证书\n生成客户端证书\n证书验证测试\n文件说明\n安全注意事项\n使用场景\n\n\n生成 CA 证书# mTLS 证书生成指南openssl genrsa -aes256 -out ca-key.pem 4096# mTLS 证书生成指南openssl genrsa -out ca-key.pem 4096# mTLS 证书生成指南openssl req -new -x509 -days 3650 -key ca-key.pem -out ca-crt.pem -sha256\n\nCA 证书生成注意事项：\n\nCommon Name: 输入 CA 名称，如 “My-CA”\nOrganization: 输入组织名称\nCountry: 输入国家代码，如 “CN”\n有效期建议设置为 10 年 (3650 天)\n\n生成服务器证书1. 生成服务器私钥openssl genrsa -out server-key.pem 2048\n\n2. 生成服务器证书签名请求openssl req -new -sha256 -key server-key.pem -out server-csr.pem\n\n在提示输入信息时：\n\nCountry Name: 与 CA 证书相同\nState or Province Name: 省份名称\nLocality Name: 城市名称\nOrganization Name: 服务器所属组织\nOrganizational Unit Name: 部门名称（可选）\nCommon Name: 重要！ 必须填写服务器的域名或 IP 地址\nEmail Address: 邮箱地址（可选）\n\n3. 创建服务器证书扩展配置文件创建 server_cert_ext.cnf 文件：\n[server_cert]basicConstraints = critical, CA:FALSEkeyUsage = critical, digitalSignature, keyEnciphermentextendedKeyUsage = serverAuthsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid,issuersubjectAltName = @alt_names[alt_names]DNS.1 = localhostDNS.2 = your-domain.comIP.1 = 127.0.0.1IP.2 = your-server-ip\n\n4. 生成服务器证书openssl x509 -req -in server-csr.pem -CA ca-crt.pem -CAkey ca-key.pem -CAcreateserial -out server-crt.pem -days 365 -sha256 -extfile server_cert_ext.cnf -extensions server_cert# mTLS 证书生成指南openssl verify -CAfile ca-crt.pem server-crt.pem\n\n5. 查看证书详情openssl x509 -in server-crt.pem -text -noout -purpose\n\n生成客户端证书1. 生成客户端私钥openssl genrsa -out client-key.pem 2048\n\n2. 生成客户端证书签名请求openssl req -new -sha256 -key client-key.pem -out client-csr.pem\n\n在提示输入信息时：\n\nCountry Name: 与 CA 证书相同\nState or Province Name: 省份名称\nLocality Name: 城市名称\nOrganization Name: 客户端所属组织\nOrganizational Unit Name: 部门名称（可选）\nCommon Name: 客户端标识名称（用于区分不同客户端）\nEmail Address: 邮箱地址（可选）\n\n3. 创建客户端证书扩展配置文件创建 client_cert_ext.cnf 文件：\n[client_cert]basicConstraints = critical, CA:FALSEkeyUsage = critical, digitalSignature, keyEnciphermentextendedKeyUsage = clientAuthsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid,issuersubjectAltName = @alt_names[alt_names]DNS.1 = clientDNS.2 = localhost\n\n4. 生成客户端证书openssl x509 -req -in client-csr.pem -CA ca-crt.pem -CAkey ca-key.pem -CAcreateserial -out client-crt.pem -days 365 -sha256 -extfile client_cert_ext.cnf -extensions client_cert# mTLS 证书生成指南openssl verify -CAfile ca-crt.pem client-crt.pem\n\n5. 查看证书详情openssl x509 -in client-crt.pem -text -noout -purpose\n\n证书验证测试# mTLS 证书生成指南openssl s_server -cert server-crt.pem -key server-key.pem -CAfile ca-crt.pem -Verify 1 -port 8443# mTLS 证书生成指南openssl s_client -connect localhost:8443 -cert client-crt.pem -key client-key.pem -CAfile ca-crt.pem\n\n文件说明\nca-key.pem: CA 私钥（妥善保管）\nca-crt.pem: CA 根证书（客户端需要信任此证书）\nca.srl: CA 序列号文件\nserver-key.pem: 服务器私钥\nserver-csr.pem: 服务器证书签名请求（可删除）\nserver-crt.pem: 服务器证书\nclient-key.pem: 客户端私钥\nclient-csr.pem: 客户端证书签名请求（可删除）\nclient-crt.pem: 客户端证书\n\n安全注意事项\n私钥保护: 所有 .pem 私钥文件必须严格保护，不要泄露\n证书有效期: 定期检查和更新即将过期的证书\nCommon Name: 服务器证书的 Common Name 必须与实际访问的域名匹配\nSAN 扩展: 现代浏览器要求使用 SAN (Subject Alternative Name) 而不是 CN\n密码保护: 生产环境中建议为私钥设置密码保护\n\n使用场景\n服务器端: 配置 web 服务器（Nginx、Apache 等）使用 server-crt.pem 和 server-key.pem\n客户端: 配置应用程序使用 client-crt.pem 和 client-key.pem 进行双向认证\n信任链: 客户端需要将 ca-crt.pem 添加到信任证书存储中\n\n","categories":["Web架构安全"],"tags":["技术文档","指南"]},{"title":"认证系统架构","url":"/posts/ab2eaca1/","content":"认证系统架构\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: authentication, authorization, jwt, oauth, security, api\n\n📑 目录\n1. 认证方式概述\n2. 本地认证流程\n2.1 注册流程\n2.2 登录流程\n2.3 Token 验证流程\n\n\n3. Google OAuth 认证流程\n3.1 配置\n3.2 认证流程\n3.3 会话管理\n\n\n4. 安全特性\n4.1 速率限制\n4.2 CORS 配置\n4.3 错误处理\n\n\n5. 中间件链\n6. 环境配置\n\n\n1. 认证方式概述系统支持两种主要的认证方式：\n\n🔑 本地用户名密码认证（JWT Token）\n🌐 Google OAuth 2.0 认证\n\ngraph LR    A[用户] --&gt; B[认证选择]    B --&gt; C[本地认证]    B --&gt; D[OAuth认证]    C --&gt; E[JWT Token]    D --&gt; F[Google授权]    E --&gt; G[访问API]    F --&gt; G\n\n\n2. 本地认证流程2.1 🔧 注册流程\n客户端发送 POST 请求到 /api/v1/auth/register\n请求经过速率限制中间件（Rate Limiter）检查\n通过注册验证器（registerValidator）验证请求数据\n控制器处理注册逻辑，创建新用户\n返回注册结果\n\nsequenceDiagram    participant C as Client    participant R as Rate Limiter    participant V as Validator    participant Ctrl as Controller    participant DB as Database    C-&gt;&gt;R: POST /api/v1/auth/register    R-&gt;&gt;V: 验证请求数据    V-&gt;&gt;Ctrl: 处理注册逻辑    Ctrl-&gt;&gt;DB: 创建新用户    DB--&gt;&gt;Ctrl: 返回用户信息    Ctrl--&gt;&gt;C: 返回注册结果\n\n2.2 🔐 登录流程\n客户端发送 POST 请求到 /api/v1/auth/login\n请求经过速率限制中间件检查\n通过登录验证器（loginValidator）验证请求数据\n控制器验证用户名和密码\n生成 JWT Token（有效期24小时）\n返回 Token 给客户端\n\nsequenceDiagram    participant C as Client    participant R as Rate Limiter    participant V as Validator    participant Ctrl as Controller    participant JWT as JWT Service    C-&gt;&gt;R: POST /api/v1/auth/login    R-&gt;&gt;V: 验证登录数据    V-&gt;&gt;Ctrl: 验证用户凭据    Ctrl-&gt;&gt;JWT: 生成Token    JWT--&gt;&gt;Ctrl: 返回JWT Token    Ctrl--&gt;&gt;C: 返回Token信息\n\n2.3 🛡️ Token 验证流程\n客户端在请求头中携带 Token：Authorization: Bearer &lt;token&gt;\nauthenticateToken 中间件验证 Token：\n检查 Token 是否存在\n验证 Token 有效性\n从 Token 中解析用户信息\n将用户信息附加到请求对象\n\n\n\n// Token 验证中间件示例const authenticateToken = (req, res, next) =&gt; &#123;  const authHeader = req.headers[&#x27;authorization&#x27;];  const token = authHeader &amp;&amp; authHeader.split(&#x27; &#x27;)[1];  if (!token) &#123;    return res.status(401).json(&#123; error: &#x27;Access token required&#x27; &#125;);  &#125;  jwt.verify(token, process.env.JWT_SECRET, (err, user) =&gt; &#123;    if (err) &#123;      return res.status(403).json(&#123; error: &#x27;Invalid or expired token&#x27; &#125;);    &#125;    req.user = user;    next();  &#125;);&#125;;\n\n\n3. Google OAuth 认证流程3.1 ⚙️ 配置\n使用 Passport.js 的 Google 策略\n配置了 Google Client ID 和 Secret\n设置了回调 URL\n\n// Google OAuth 配置示例const GoogleStrategy = require(&#x27;passport-google-oauth20&#x27;).Strategy;passport.use(new GoogleStrategy(&#123;  clientID: process.env.GOOGLE_CLIENT_ID,  clientSecret: process.env.GOOGLE_CLIENT_SECRET,  callbackURL: &quot;/api/v1/auth/google/callback&quot;&#125;, (accessToken, refreshToken, profile, done) =&gt; &#123;  // 用户验证逻辑&#125;));\n\n3.2 🔄 认证流程\n用户访问 /api/v1/auth/oauth/google\n重定向到 Google 登录页面\n用户授权后，Google 重定向回回调 URL\nPassport 处理回调：\n验证用户信息\n如果用户不存在，创建新用户\n生成会话\n\n\n\nsequenceDiagram    participant U as User    participant A as App    participant G as Google    participant DB as Database    U-&gt;&gt;A: 访问OAuth端点    A-&gt;&gt;G: 重定向到Google    U-&gt;&gt;G: 登录并授权    G-&gt;&gt;A: 回调授权码    A-&gt;&gt;G: 交换访问令牌    G-&gt;&gt;A: 返回用户信息    A-&gt;&gt;DB: 查找/创建用户    A-&gt;&gt;U: 建立会话\n\n3.3 📋 会话管理\n使用 express-session 管理会话\n配置了会话密钥和选项\n实现了用户序列化和反序列化\n\n// 会话配置示例app.use(session(&#123;  secret: process.env.SESSION_SECRET,  resave: false,  saveUninitialized: false,  cookie: &#123;    secure: process.env.NODE_ENV === &#x27;production&#x27;,    maxAge: 24 * 60 * 60 * 1000 // 24小时  &#125;&#125;));\n\n\n4. 安全特性4.1 🚦 速率限制\n使用 express-rate-limit 实现\n默认限制：15分钟内每个 IP 最多 100 个请求\n应用于登录和注册接口\n\n// 速率限制配置示例const rateLimiter = rateLimit(&#123;  windowMs: 15 * 60 * 1000, // 15分钟  max: 100, // 最大请求数  message: &#x27;Too many requests from this IP&#x27;&#125;);\n\n4.2 🌐 CORS 配置\n可配置允许的源（默认允许所有）\n限制允许的 HTTP 方法\n配置允许的请求头\n支持凭证（credentials）\n\n// CORS 配置示例app.use(cors(&#123;  origin: process.env.ALLOWED_ORIGINS?.split(&#x27;,&#x27;) || &#x27;*&#x27;,  methods: [&#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;],  allowedHeaders: [&#x27;Content-Type&#x27;, &#x27;Authorization&#x27;],  credentials: true&#125;));\n\n4.3 ⚠️ 错误处理\n统一的错误处理中间件\n区分开发环境和生产环境的错误响应\n详细的错误日志记录\n\n// 错误处理中间件示例app.use((err, req, res, next) =&gt; &#123;  console.error(err.stack);  if (process.env.NODE_ENV === &#x27;development&#x27;) &#123;    res.status(500).json(&#123;      error: err.message,      stack: err.stack    &#125;);  &#125; else &#123;    res.status(500).json(&#123;      error: &#x27;Internal Server Error&#x27;    &#125;);  &#125;&#125;);\n\n\n5. 🔗 中间件链请求处理流程：\ngraph TD    A[客户端请求] --&gt; B[日志中间件]    B --&gt; C[基础中间件]    C --&gt; D[CORS中间件]    D --&gt; E[会话中间件]    E --&gt; F[Passport初始化]    F --&gt; G[路由处理]    G --&gt; H[控制器逻辑]    H --&gt; I[响应返回]    I --&gt; J[错误处理中间件]\n\n\n日志中间件（请求记录）\n基础中间件（JSON解析、CORS等）\n会话中间件\nPassport 初始化\n路由处理\n错误处理中间件\n\n\n6. 🛠️ 环境配置关键配置项：\n# 认证系统架构JWT_SECRET=your-super-secret-jwt-keyJWT_EXPIRES_IN=24h# 认证系统架构SESSION_SECRET=your-session-secret# 认证系统架构GOOGLE_CLIENT_ID=your-google-client-idGOOGLE_CLIENT_SECRET=your-google-client-secret# 认证系统架构DB_HOST=localhostDB_PORT=3306DB_NAME=your-database-nameDB_USER=your-usernameDB_PASSWORD=your-password# 认证系统架构UPLOAD_DIR=./uploadsMAX_FILE_SIZE=10485760# 认证系统架构ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com# 认证系统架构RATE_LIMIT_WINDOW_MS=900000RATE_LIMIT_MAX_REQUESTS=100\n\n\n📊 总结这个认证系统采用了多重安全机制，包括：\n\n✅ JWT Token 认证\n✅ OAuth 2.0 第三方登录\n✅ 速率限制 防止暴力攻击\n✅ CORS 跨域保护\n✅ 统一错误处理 提升用户体验\n\n通过中间件链的方式，实现了灵活的认证流程控制，能够有效保护 API 接口的安全。\n\n\n💡 提示: 在生产环境中，请确保：\n\n使用强密码作为密钥\n启用 HTTPS\n定期轮换密钥\n监控异常访问行为\n\n\n","categories":["Web架构安全"],"tags":["技术文档","指南"]},{"title":"Qt 下载器需求规范","url":"/posts/6ee89f12/","content":"Qt 下载器需求规范\n文档创建时间: 2025-11-14最后更新: 2025-11-14版本: v1.0标签: qt, downloader, product-requirements, desktop-app, c++\n\n📑 目录\n1. 产品概述\n2. 用户角色\n3. 功能需求\n4. 非功能需求\n5. 界面设计\n6. 数据模型\n7. 技术规范\n8. 交付要求\n\n\n1. 🎯 产品概述1.1 产品定位基于 Qt 框架开发的桌面下载管理器，支持多线程并发下载，提供直观的任务管理界面和实时进度监控。\n1.2 核心价值\n✅ 批量下载 - 支持多任务并发下载\n✅ 进度监控 - 实时显示下载状态和进度\n✅ 断点续传 - 支持下载中断后继续\n✅ 跨平台 - 支持 Windows、macOS、Linux\n\n1.3 产品架构图graph TD    A[用户界面] --&gt; B[任务管理器]    B --&gt; C[下载引擎]    C --&gt; D[网络请求层]    B --&gt; E[数据持久化]    B --&gt; F[配置管理]    C --&gt; G[线程池]    G --&gt; H[任务队列]    D --&gt; I[HTTP/HTTPS]    D --&gt; J[重定向处理]    D --&gt; K[认证处理]    style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#e8f5e8    style D fill:#fff3e0\n\n\n2. 👥 用户角色2.1 目标用户终端用户 - 需要批量下载文件的个人用户\n\n技术背景：普通计算机用户\n使用场景：下载软件、文档、媒体文件\n操作习惯：图形界面操作\n\n2.2 用户场景graph LR    A[用户输入URL] --&gt; B[添加下载任务]    B --&gt; C[开始下载]    C --&gt; D[监控进度]    D --&gt; E&#123;完成下载?&#125;    E --&gt;|是| F[通知用户]    E --&gt;|否| D    F --&gt; G[任务完成]\n\n\n3. 📋 功能需求3.1 🎛️ 任务管理3.1.1 添加任务\nURL 输入: 支持单个或多个 URL（每行一个）\nURL 格式: 支持 HTTP&#x2F;HTTPS 协议\n认证支持: URL 中可包含用户名密码 (user:pass@host)\n批量导入: 支持从剪贴板粘贴多个 URL\n\n3.1.2 任务列表显示表格列必须包含:\n\n文件名: 从 URL 提取或 Content-Disposition 解析\n文件大小: 字节数，获取后显示 (-1 表示未知)\n已下载大小: 字节数，实时刷新\n进度百分比: 0-100%，实时计算\n下载速度: B&#x2F;s，实时刷新\n状态: 等待 &#x2F; 下载中 &#x2F; 已完成 &#x2F; 错误\n\ngantt    title 下载任务状态流转    dateFormat X    axisFormat %s    section 下载流程    等待中     :0, 10    下载中     :10, 100    已完成     :100, 110    错误处理   :a1, after a2, 20\n\n3.1.3 任务操作\n开始: 启动选中的下载任务\n暂停: 暂停正在下载的任务\n取消: 取消下载并删除未完成的文件\n删除: 从列表中删除已完成或失败的记录\n\n3.2 ⚙️ 下载引擎3.2.1 多线程下载// 单任务多线程配置const int DEFAULT_THREAD_COUNT = 4;  // 默认4线程const int MAX_THREAD_COUNT = 16;     // 最大16线程\n\n\n分段下载: 将文件分为多个片段并发下载\n线程管理: 每个任务可配置独立线程数\n负载均衡: 动态调整各线程下载速度\n\n3.2.2 网络支持\n协议支持: HTTP&#x2F;HTTPS\n重定向: 自动处理 3xx 重定向\n认证: 支持 Basic Authentication\n代理支持: 系统代理设置\n\n3.2.3 完整性校验\n大小校验: 下载完成后校验 Content-Length\nMD5校验: 服务器返回 MD5 头时进行校验\n断点续传: 支持从中断位置继续下载\n\n3.3 💾 设置与持久化3.3.1 配置管理\n下载目录: 默认系统”下载”文件夹，可自定义\n并发限制: 全局最大同时下载数\n线程数: 每任务默认线程数\n重试次数: 失败重试次数\n\n3.3.2 任务持久化\n自动保存: 任务状态自动保存\n启动恢复: 程序启动时恢复未完成任务\n设置保存: 用户配置持久化存储\n\n3.4 🚨 异常处理与反馈3.4.1 网络异常\n自动重试: 网络中断时自动重试3次\n指数退避: 重试间隔逐渐增加\n错误分类: 区分临时错误和永久错误\n\n3.4.2 用户反馈\n状态更新: 实时更新任务状态\n错误提示: 显示详细错误信息\n完成通知: 下载完成时系统托盘通知\n进度提示: 进度条和百分比显示\n\n\n4. 🚀 非功能需求4.1 🖥️ 平台兼容性\n\n\n平台\n最低版本\n架构\nQt 版本\n\n\n\nWindows\nWindows 10+\nx64\nQt 5.3-5.12\n\n\nmacOS\n10.15+\nx64\nQt 5.3-5.12\n\n\nLinux\nUbuntu 22.04+\nx64\nQt 5.3-5.12\n\n\n4.2 ⚡ 性能要求\n内存使用: 同时10个任务并发时，峰值内存 ≤ 200MB\nUI响应: 任何操作在 200ms 内给出视觉反馈\n下载速度: 充分利用可用带宽\n启动时间: 冷启动 &lt; 3秒\n\n4.3 🔒 安全性要求\nURL验证: 验证输入URL格式\n文件路径: 防止路径遍历攻击\n下载限制: 支持文件大小和类型限制\n用户数据: 本地数据加密存储\n\n\n5. 🎨 界面设计5.1 主界面布局┌─────────────────────────────────────────────────────────┐│ URL 输入框                                              ││ ┌─────────────────────────────────────────────────────┐ ││ │ https://example.com/file1.zip                       │ ││ │ https://example.com/file2.pdf                       │ ││ └─────────────────────────────────────────────────────┘ ││ [添加] [开始全部] [暂停全部] [删除选中]                 │├─────────────────────────────────────────────────────────┤│ 任务列表 (QTableView)                                  ││ 文件名      │ 大小     │ 已下载  │ 进度  │ 速度  │ 状态 ││ file1.zip   │ 100MB    │ 50MB    │ 50%   │ 1MB/s │下载中││ file2.pdf   │ 20MB     │ 20MB    │ 100%  │ 0     │完成 │├─────────────────────────────────────────────────────────┤│ 全局速度: 1.5MB/s  剩余时间: 2分钟  任务数: 2/10       ││ [设置] [关于] [退出]                                    │└─────────────────────────────────────────────────────────┘\n\n5.2 界面状态图stateDiagram-v2    [*] --&gt; 初始化界面    初始化界面 --&gt; 空闲状态    空闲状态 --&gt; 下载中: 添加任务并开始    下载中 --&gt; 暂停中: 用户暂停    暂停中 --&gt; 下载中: 用户继续    下载中 --&gt; 完成: 下载完成    下载中 --&gt; 错误: 下载失败    错误 --&gt; 下载中: 重试下载    完成 --&gt; 空闲状态: 清除任务\n\n\n6. 📊 数据模型6.1 核心数据结构// 下载任务数据模型struct DownloadTask &#123;    QString id;                    // 唯一标识    QUrl url;                     // 下载URL    QString fileName;             // 本地文件名    QString savePath;             // 保存路径    qint64 totalBytes;           // 总大小 (-1=未知)    qint64 downloadedBytes;      // 已下载大小    int progress;                 // 进度百分比 (0-100)    qint64 speed;                // 当前速度 (B/s)    qint64 averageSpeed;         // 平均速度 (B/s)    QDateTime startTime;         // 开始时间    QDateTime finishTime;        // 完成时间    enum State &#123;        Waiting,     // 等待开始        Running,     // 下载中        Paused,      // 已暂停        Completed,   // 已完成        Error,       // 错误        Cancelled    // 已取消    &#125; state;    enum Priority &#123;        Low = 1,        Normal = 2,        High = 3    &#125; priority;    QString errorMessage;        // 错误信息    int retryCount;             // 重试次数    int maxRetries;             // 最大重试次数    QStringList downloadThreads;  // 下载线程列表&#125;;\n\n6.2 配置数据结构struct DownloadSettings &#123;    QString defaultDownloadPath;    // 默认下载路径    int maxConcurrentTasks;         // 最大并发任务数    int defaultThreadCount;         // 默认线程数    int maxRetryCount;             // 最大重试次数    bool autoRetry;                // 自动重试    bool startOnStartup;           // 开机启动    bool showNotifications;        // 显示通知    bool verifyIntegrity;          // 验证文件完整性    qint64 maxFileSize;            // 最大文件大小限制    QStringList blockedExtensions;  // 禁止的文件扩展名&#125;;\n\n\n7. 🔧 技术规范7.1 技术栈\nUI框架: Qt Widgets (非QML)\n网络库: QNetworkRequest\n并发: QThread + QThreadPool\n持久化: QSettings + SQLite\n日志: QtMessageHandler\n\n7.2 代码结构FastDownloader/├── main.cpp                 # 程序入口├── MainWindow.h/.cpp         # 主窗口├── MainWindow.ui             # UI文件├── DownloadTask.h/.cpp       # 下载任务数据模型├── DownloadManager.h/.cpp    # 下载管理器├── Downloader.h/.cpp         # 下载引擎├── SettingsDialog.h/.cpp     # 设置对话框├── SettingsDialog.ui         # 设置UI└── resources/                # 资源文件    ├── icons/    └── translations/\n\n7.3 关键技术点7.3.1 多线程下载class DownloadThread : public QThread &#123;    Q_OBJECTpublic:    void run() override;    void pause();    void stop();signals:    void progressChanged(qint64 bytesReceived, qint64 bytesTotal);    void speedChanged(qint64 speed);    void finished(bool success, const QString&amp; error);private:    QNetworkReply* m_reply;    QUrl m_url;    QString m_filePath;    qint64 m_startPos;    qint64 m_endPos;    bool m_paused;    bool m_stopped;&#125;;\n\n7.3.2 断点续传// 获取文件已下载大小qint64 getDownloadedFileSize(const QString&amp; filePath) &#123;    QFile file(filePath);    if (file.exists()) &#123;        return file.size();    &#125;    return 0;&#125;// 设置Range请求头QNetworkRequest createRangeRequest(const QUrl&amp; url, qint64 startPos) &#123;    QNetworkRequest request(url);    QString range = QString(&quot;bytes=%1-&quot;).arg(startPos);    request.setRawHeader(&quot;Range&quot;, range.toLatin1());    return request;&#125;\n\n7.4 性能优化\n内存管理: 及时释放下载完成的数据\n网络优化: 连接池和Keep-Alive\nUI更新: 使用定时器减少UI刷新频率\n磁盘IO: 缓冲写入，减少磁盘IO次数\n\n\n8. 📦 交付要求8.1 交付物清单\n 源代码: 完整的C++源码实现\n 资源文件: 图标、UI文件等\n 构建脚本: CMakeLists.txt或.pro文件\n 测试用例: 单元测试和集成测试\n 部署文档: 编译和部署说明\n\n8.2 代码规范// 命名规范class DownloadManager : public QObject &#123;  // 类名：PascalCase    Q_OBJECTpublic:    explicit DownloadManager(QObject *parent = nullptr);  // 函数名：camelCaseprivate slots:    void onDownloadProgress(qint64 bytesReceived, qint64 bytesTotal);  // 槽函数命名private:    int m_maxConcurrentTasks;  // 成员变量：m_前缀，camelCase    QString m_defaultPath;&#125;;\n\n8.3 质量要求\n代码覆盖率: ≥80%\n内存泄漏: 无内存泄漏\n文档完整: 关键函数有注释\n异常处理: 完善的错误处理机制\n\n\n📊 项目里程碑Phase 1: 基础框架 (2周)\n 主界面设计\n 数据模型定义\n 基础下载功能\n\nPhase 2: 核心功能 (3周)\n 多线程下载实现\n 断点续传功能\n 任务管理界面\n\nPhase 3: 高级功能 (2周)\n 配置管理\n 异常处理\n 性能优化\n\nPhase 4: 测试发布 (1周)\n 功能测试\n 性能测试\n 代码审查\n\n\n📈 成功指标8.1 功能指标\n✅ 支持同时下载10个文件\n✅ 下载速度达到带宽的90%以上\n✅ 程序启动时间&lt;3秒\n✅ 内存使用&lt;200MB（10个并发任务）\n\n8.2 用户体验指标\n✅ 界面响应时间&lt;200ms\n✅ 支持断点续传\n✅ 错误恢复成功率&gt;95%\n✅ 用户操作流程简化\n\n\n📚 参考资料\nQt 官方文档\nQNetworkRequest 类文档\nQt 多线程编程指南\nHTTP 协议规范\n\n\n\n💡 开发建议:\n\n采用模块化设计，便于功能扩展\n重视用户体验，界面简洁直观\n完善错误处理，提高程序稳定性\n充分测试各种网络环境和异常情况\n\n\n","categories":["软件架构"],"tags":["技术文档","指南"]},{"title":"Docker 部署指南","url":"/posts/4beba163/","content":"Docker 部署指南概述Docker容器化部署是现代应用部署的标准方式，本文详细介绍如何使用Docker进行应用容器化部署。\nDocker基础概念什么是DockerDocker是一个开源的容器化平台，可以将应用和依赖打包成轻量级、可移植的容器。\n核心组件\nDocker Engine: 容器运行时\nDocker Compose: 多容器应用编排\nDocker Registry: 镜像仓库\n\n安装DockerUbuntu安装# Docker 部署指南sudo apt-get update# Docker 部署指南sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release# Docker 部署指南curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# Docker 部署指南echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# Docker 部署指南sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io\n\nCentOS安装# Docker 部署指南sudo yum install -y yum-utils# Docker 部署指南sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# Docker 部署指南sudo yum install docker-ce docker-ce-cli containerd.io\n\nDockerfile编写基础Dockerfile示例# Docker 部署指南FROM node:16-alpine# Docker 部署指南WORKDIR /app# Docker 部署指南COPY package*.json ./# Docker 部署指南RUN npm install# Docker 部署指南COPY . .# Docker 部署指南EXPOSE 3000# Docker 部署指南CMD [&quot;npm&quot;, &quot;start&quot;]\n\n多阶段构建# Docker 部署指南FROM node:16-alpine AS builderWORKDIR /appCOPY package*.json ./RUN npm installCOPY . .RUN npm run build# Docker 部署指南FROM nginx:alpineCOPY --from=builder /app/dist /usr/share/nginx/htmlEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]\n\nDocker Compose基本配置文件version: &#x27;3.8&#x27;services:  web:    build: .    ports:      - &quot;3000:3000&quot;    environment:      - NODE_ENV=production    depends_on:      - db  db:    image: postgres:13    environment:      - POSTGRES_DB=myapp      - POSTGRES_USER=user      - POSTGRES_PASSWORD=password    volumes:      - postgres_data:/var/lib/postgresql/data    ports:      - &quot;5432:5432&quot;  redis:    image: redis:6-alpine    ports:      - &quot;6379:6379&quot;volumes:  postgres_data:\n\n高级配置version: &#x27;3.8&#x27;services:  app:    build:      context: .      dockerfile: Dockerfile.prod    deploy:      replicas: 3      resources:        limits:          cpus: &#x27;0.5&#x27;          memory: 512M    environment:      - DATABASE_URL=postgresql://user:password@db:5432/myapp    networks:      - app-network  nginx:    image: nginx:alpine    ports:      - &quot;80:80&quot;      - &quot;443:443&quot;    volumes:      - ./nginx.conf:/etc/nginx/nginx.conf      - ./ssl:/etc/nginx/ssl    depends_on:      - app    networks:      - app-networknetworks:  app-network:    driver: bridge\n\n部署最佳实践1. 镜像优化\n使用轻量级基础镜像\n多阶段构建减少镜像大小\n.dockerignore文件排除不必要文件\n\n2. 安全配置\n使用非root用户运行容器\n定期更新基础镜像\n扫描镜像漏洞\n\n3. 资源管理\n设置内存和CPU限制\n配置健康检查\n实现优雅关闭\n\n生产环境部署环境变量配置# Docker 部署指南echo &quot;NODE_ENV=production&quot; &gt; .envecho &quot;DATABASE_URL=postgresql://...&quot; &gt;&gt; .envecho &quot;REDIS_URL=redis://...&quot; &gt;&gt; .env\n\n启动服务# Docker 部署指南docker-compose up -d --build# Docker 部署指南docker-compose ps# Docker 部署指南docker-compose logs -f app\n\n更新部署# Docker 部署指南git pull origin main# Docker 部署指南docker-compose up -d --build --force-recreate\n\n监控和日志日志管理# Docker 部署指南docker-compose logs# Docker 部署指南docker-compose logs app# Docker 部署指南docker-compose logs -f --tail=100\n\n性能监控# Docker 部署指南docker stats# Docker 部署指南docker inspect &lt;container_id&gt;\n\n故障排查常见问题解决\n容器启动失败\n# 查看容器日志docker logs &lt;container_id&gt;# 进入容器调试docker exec -it &lt;container_id&gt; /bin/sh\n\n网络连接问题\n# 检查网络配置docker network lsdocker network inspect &lt;network_name&gt;\n\n资源不足\n# 清理无用镜像docker image prune -a# 清理无用容器docker container prune\n\n总结Docker容器化部署提供了标准化的部署方式，大大简化了应用的部署和维护过程。通过合理配置Docker和Docker Compose，可以构建出高可用、可扩展的容器化应用架构。\n","categories":["开发工具与流程","构建与部署"],"tags":["Nginx","Linux","Git","Redis","Docker"]},{"title":"宝塔面板安装指南","url":"/posts/251711d2/","content":"宝塔面板安装指南目录\n重要：安全须知\n概述\n第一步：环境准备\n第二步：执行安装脚本\n第三步：初始配置\n核心功能使用\n常用命令\n问题排查\n\n重要：安全须知宝塔面板是一个拥有高权限的服务器管理工具，其安全性至关重要。请务必遵循以下基础安全实践：\n\n修改默认信息: 立即修改默认的 8888 端口、默认的用户名和密码。\n使用强密码: 为面板和数据库设置复杂的、无规律的密码。\n开启面板 SSL: 为你的面板访问地址开启 HTTPS，防止登录信息在传输过程中被窃取。\n定期更新: 及时将宝塔面板更新到最新版本，以获取最新的安全补丁。\n配置防火墙: 只开放必要的端口，关闭不使用的端口。\n定期备份: 养成定期备份网站文件和数据库的好习惯。\n\n概述宝塔面板（BT Panel）是一款简单易用的服务器运维管理面板，支持 Linux 和 Windows。它通过 Web 图形化界面，极大地简化了服务器的日常管理工作，如环境部署、网站创建、数据库管理、文件管理和安全监控等。\n国际版: 宝塔面板有对应的国际版，名为 aaPanel。对于非中文用户，推荐使用 aaPanel，其官网为 aapanel.com。本指南以中文版的宝塔面板为例。\n第一步：环境准备1. 系统要求\n操作系统: CentOS 7.1+, Ubuntu 16.04+, Debian 9.0+\n内存: 建议 1GB 以上。\n磁盘空间: 建议 10GB 以上可用空间。\n要求: 一个纯净的、未安装过其他 Web 服务器软件（如 Nginx, Apache）的操作系统。\n\n2. 开放端口在安装前，请确保你的服务器提供商的安全组（或防火墙）已开放以下端口：\n\n8888: 宝塔面板默认端口\n80: HTTP\n443: HTTPS\n22: SSH\n21: FTP (如果需要)\n3306: MySQL (如果需要远程访问)\n\n第二步：执行安装脚本使用 root 或 sudo 权限登录你的服务器终端。\nUbuntu&#x2F;Debian 安装命令wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec\n\nCentOS 安装命令yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec\n\n安装脚本会自动完成所有环境配置。安装成功后，终端会显示你的面板登录地址、用户名和密码。请务必立即复制并保存这些信息！\n第三步：初始配置\n登录面板: 使用上一步获取的地址、用户名和密码，在浏览器中打开并登录宝塔面板。\n安装套件: 首次登录时，面板会推荐你安装一个 Web 环境套件，最常见的是 LNMP (Linux + Nginx + MySQL + PHP) 或 LAMP (Linux + Apache + MySQL + PHP)。根据你的需求选择一个并一键安装。\n修改安全信息:\n进入左侧菜单的“面板设置”。\n修改面板端口: 将默认的 8888 修改为一个不常用的端口。\n修改面板用户和密码: 设置一个强密码。\n开启面板 SSL: 为你的面板域名（可以是 IP）申请一个 Let’s Encrypt 证书或粘贴你自己的证书，强制使用 HTTPS 访问。\n\n\n\n核心功能使用网站管理\n添加站点: 在“网站”菜单中，输入你的域名，选择 PHP 版本，创建数据库，即可快速创建一个网站。\n配置 SSL: 在站点的“设置”中，可以一键申请和部署 Let’s Encrypt 的免费 SSL 证书，并开启强制 HTTPS。\n\n数据库管理\n创建数据库: 在“数据库”菜单中，可以快速创建数据库和用户，并管理权限。\n备份与恢复: 支持对数据库进行手动或定时的备份，并可以从备份中恢复。\nphpMyAdmin: 面板内置了 phpMyAdmin，方便进行图形化的数据库管理。\n\n文件管理\n提供一个功能强大的在线文件管理器，可以进行上传、下载、压缩、解压、在线编辑等操作。\n\n监控\n在“监控”菜单中，可以直观地看到服务器的 CPU、内存、磁盘和网络负载的实时和历史图表。\n\n常用命令宝塔面板提供了一个方便的命令行工具 bt。\n# 宝塔面板安装指南sudo bt start       # 启动面板sudo bt stop        # 停止面板sudo bt restart     # 重启面板sudo bt status      # 查看面板状态# 宝塔面板安装指南sudo bt 1           # 修改面板端口sudo bt 5           # 修改面板密码sudo bt 6           # 修改面板用户名# 宝塔面板安装指南sudo bt default     # 查看默认登录信息sudo bt clean       # 清理面板缓存\n\n问题排查Q1: 安装完成后无法访问面板地址?A:\n\n检查服务状态: 运行 sudo bt status 或 sudo systemctl status bt 确认面板服务是否在运行。\n检查防火墙: 确认你的云服务器安全组和服务器内部的防火墙（如 ufw, firewalld）都已放行了你的面板端口。\n检查端口占用: 使用 sudo netstat -tlnp | grep &lt;你的端口号&gt; 检查端口是否被其他程序占用。\n\nQ2: 忘记了登录信息?A: 登录服务器终端，运行 sudo bt default 即可查看当前的登录地址、用户名和密码。\nQ3: 网站无法访问，提示 502 或其他错误?A:\n\n登录宝塔面板，检查“网站”-&gt;“设置”中的配置是否正确。\n检查对应的 Web 服务器（Nginx&#x2F;Apache）和 PHP 的服务状态是否正常。\n在“文件”中查看对应网站的日志文件，分析具体的错误原因。\n\n","categories":["云服务与DevOps","服务器管理面板"],"tags":["Linux","宝塔面板","aaPanel","服务器管理","Web面板","系统管理"]},{"title":"FileZilla 端口转发指南","url":"/posts/33eb4929/","content":"FileZilla 端口转发指南\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: filezilla, ftp, portforwarding, 花生壳, 内网穿透, 远程访问\n\n📑 目录\n1. 概述\n2. 配置流程图\n3. FileZilla Server 配置\n4. 花生壳内网穿透\n5. FTP 被动模式配置\n6. 防火墙设置\n7. 连接测试\n8. 故障排除\n\n\n1. 📖 概述本指南详细介绍如何使用 FileZilla Server 搭建 FTP 服务器，并通过花生壳实现外网访问内网文件的完整解决方案。\n🎯 配置目标\n✅ 搭建内网 FTP 服务器\n✅ 配置花生壳内网穿透\n✅ 实现外网安全访问\n✅ 支持文件上传下载\n\n🏗️ 系统架构图flowchart TD    A[外网客户端] --&gt; B[花生壳外网域名]    B --&gt; C[花生壳服务器]    C --&gt; D[内网服务器]    D --&gt; E[FileZilla Server]    E --&gt; F[共享文件夹]    G[FTP控制通道&lt;br/&gt;端口21] --&gt; C    H[FTP数据通道&lt;br/&gt;被动端口] --&gt; C    style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#e8f5e8    style D fill:#fff3e0\n\n\n2. 🔄 配置流程图flowchart TD    A[开始配置] --&gt; B[安装与配置FileZilla Server]    B --&gt; C[配置花生壳内网穿透]    C --&gt; D&#123;配置FTP被动模式&lt;br&gt;与数据传输端口&#125;    D --&gt; E[设置Windows防火墙]    E --&gt; F[外网连接测试]    F --&gt; G&#123;测试成功?&#125;    G -- 是 --&gt; H[配置完成]    G -- 否 --&gt; I[检查端口映射与被动模式设置]    I --&gt; F\n\n\n3. 🖥️ FileZilla Server 配置3.1 📥 下载与安装\n下载 FileZilla Server\n\n访问 FileZilla 官网\n下载 FileZilla Server 版本\n以管理员身份运行安装程序\n\n\n安装配置\n# 安装过程中的关键设置：- 管理端口: 14147 (默认)- 服务端口: 21 (FTP控制端口)- 启动为系统服务: 推荐\n\n3.2 👤 用户与权限配置创建用户\n打开管理界面\n\n双击系统托盘的 FileZilla Server 图标\n或访问 http://localhost:14147\n\n\n添加用户\nEdit → Users → Add- 用户名: user1 (自定义)- 密码: 设置强密码- 勾选 &quot;Password&quot; 并输入密码\n\n设置共享文件夹\n添加共享目录\nShared folders → Add- 选择要共享的内网目录- 例如: D:\\SharedFiles\n\n配置权限\nFiles权限:✓ Read (读取/下载)✓ Write (写入/上传) - 可选✓ Delete (删除) - 可选✓ Append (追加) - 可选Directories权限:✓ Create (创建目录)✓ Delete (删除目录)✓ List (列出目录)✓ Subdirs (子目录)\n\n3.3 🔧 基础配置graph LR    A[FileZilla设置] --&gt; B[常规设置]    A --&gt; C[被动模式]    A --&gt; D[安全设置]    B --&gt; B1[监听端口: 21]    B --&gt; B2[最大连接数: 10]    C --&gt; C1[启用被动模式]    C --&gt; C2[自定义端口范围]    D --&gt; D1[加密模式]    D --&gt; D2[IP过滤]\n\n\n4. 🌐 花生壳内网穿透4.1 📱 花生壳客户端设置\n下载安装花生壳\n\n访问 花生壳官网\n下载并安装花生壳客户端\n注册并登录花生壳账号\n\n\n添加内网穿透映射\n内网穿透 → + 添加映射第一个映射 (FTP控制通道):- 应用名称: FTP-Control- 应用类型: TCP- 内网主机IP: 192.168.x.x (服务器内网IP)- 内网端口: 21\n\n4.2 🔗 获取外网访问地址sequenceDiagram    participant U as 用户    participant P as 花生壳客户端    participant S as 花生壳服务器    participant F as FileZilla Server    U-&gt;&gt;P: 添加映射配置    P-&gt;&gt;S: 提交映射请求    S-&gt;&gt;S: 生成外网域名    S-&gt;&gt;P: 返回外网访问地址    P-&gt;&gt;U: 显示外网地址\n\n获取的信息:\n\n外网域名: xxxx.vicp.cc\n外网端口: 12345 (示例)\n\n\n5. 🔄 FTP 被动模式配置5.1 🎯 理解被动模式FTP 协议需要两个通道：\n\n控制通道: 端口 21，用于发送命令\n数据通道: 动态端口，用于传输数据\n\n5.2 📡 添加数据端口映射\n在花生壳中添加第二个映射\n第二个映射 (FTP数据通道):- 应用名称: FTP-Data- 应用类型: TCP- 内网主机IP: 192.168.x.x (同上)- 内网端口: 60000 (临时设置)\n\n记下外网端口\n\n假设生成的外网端口为 10418\n需要修改内网端口与之匹配\n\n\n修正端口映射\n编辑 FTP-Data 映射:- 将内网端口改为: 10418- 确保内外端口一致\n\n5.3 ⚙️ FileZilla 被动模式设置\n进入被动模式设置\nEdit → Settings → Passive mode settings\n\n配置被动模式参数\n✓ Use custom port range- Custom port range: 10418-10418✓ Use the following IP- IP: xxxx.vicp.cc (花生壳域名)\n\n4.4 🛡️ 安全配置建议graph TD    A[FTP安全配置] --&gt; B[启用SSL/TLS]    A --&gt; C[限制IP访问]    A --&gt; D[强密码策略]    A --&gt; E[日志监控]    B --&gt; B1[生成自签名证书]    B --&gt; B2[强制加密连接]    C --&gt; C1[IP白名单]    C --&gt; C2[地理位置限制]    D --&gt; D1[密码复杂度要求]    D --&gt; D2[定期更换密码]    E --&gt; E1[访问日志]    E --&gt; E2[异常告警]\n\n\n6. 🔥 Windows 防火墙设置6.1 🛡️ 添加防火墙规则\n打开 Windows 防火墙\n控制面板 → Windows Defender 防火墙 → 高级设置\n\n添加入站规则\n入站规则 → 新建规则规则1 (FTP控制):- 端口: TCP 21- 操作: 允许连接- 配置文件: 域、专用、公用规则2 (FTP数据):- 端口: TCP 10418- 操作: 允许连接- 配置文件: 域、专用、公用\n\n6.2 🔧 验证防火墙配置# FileZilla 端口转发指南telnet localhost 21telnet localhost 10418# FileZilla 端口转发指南netsh advfirewall show allprofiles\n\n\n7. 🧪 外网连接测试7.1 🔗 使用 FileZilla Client 测试\n下载 FileZilla Client\n\n访问 FileZilla 官网下载客户端\n安装并启动\n\n\n配置站点连接\n主机: xxxx.vicp.cc:21用户名: user1密码: [设置的密码]端口: 21传输模式: 被动模式\n\n连接测试\nsequenceDiagram    participant C as FileZilla Client    participant H as 花生壳    participant S as 内网服务器    participant F as FileZilla Server    C-&gt;&gt;H: 连接请求 (端口21)    H-&gt;&gt;S: 转发连接    S-&gt;&gt;F: FTP控制连接    F-&gt;&gt;S: 响应被动端口    S-&gt;&gt;H: 转发被动端口信息    H-&gt;&gt;C: 返回数据端口    C-&gt;&gt;H: 数据连接 (端口10418)    H-&gt;&gt;S: 转发数据连接    S-&gt;&gt;F: FTP数据连接\n\n7.2 📊 测试结果检查成功标志:\n✅ 状态: 连接成功✅ 目录列表: 显示共享文件夹内容✅ 文件下载: 可以正常下载文件✅ 文件上传: 可以正常上传文件 (如果权限允许)\n\n7.3 🌐 其他 FTP 客户端测试Windows 资源管理器地址栏输入: ftp://user1:password@xxxx.vicp.cc:21\n\n浏览器访问访问: ftp://xxxx.vicp.cc:21\n\n命令行测试ftp xxxx.vicp.cc:21user1passwordls\n\n\n8. 🔧 故障排除8.1 ❌ 常见问题及解决方案问题1: 连接超时症状: 连接时长时间无响应\ngraph TD    A[连接超时] --&gt; B&#123;问题排查&#125;    B --&gt; C[检查花生壳映射]    B --&gt; D[检查防火墙设置]    B --&gt; E[检查FTP服务状态]    C --&gt; C1[确认映射配置正确]    D --&gt; D1[确认端口已开放]    E --&gt; E1[确认服务正在运行]\n\n解决方案:\n# FileZilla 端口转发指南# FileZilla 端口转发指南# FileZilla 端口转发指南ftp localhost:21# FileZilla 端口转发指南services.msc → 查找 FileZilla Server\n\n问题2: 能连接但无法列出目录症状: 连接成功但看不到文件列表\n原因分析:\n主要原因: 被动模式配置错误- 数据端口映射不正确- FileZilla被动模式设置问题\n\n解决方案:\n\n重新配置被动模式端口\n确保 FileZilla 中设置的外网IP正确\n检查数据端口的防火墙规则\n\n问题3: 登录认证失败症状: 用户名或密码错误\n解决方案:\n# FileZilla 端口转发指南FileZilla Server管理界面 → Edit → Users→ 选择用户 → 重新设置密码# FileZilla 端口转发指南确认用户有至少一个共享文件夹确认用户有读取权限\n\n8.2 🔍 高级故障排除网络诊断工具# FileZilla 端口转发指南nmap -p 21,10418 localhost# FileZilla 端口转发指南telnet localhost 21telnet localhost 10418# FileZilla 端口转发指南tracert xxxx.vicp.cc\n\n日志分析\nFileZilla Server 日志\n编辑 → 设置 → 日志文件- 启用日志记录- 查看详细错误信息\n\nWindows 事件日志\n事件查看器 → Windows 日志 → 应用程序- 查找与 FileZilla 相关的错误\n\n8.3 📞 获取支持官方资源:\n\nFileZilla 官方文档\n花生壳技术支持\nFTP 协议文档\n\n社区支持:\n\nFileZilla 论坛\n花生壳用户社区\nStack Overflow 技术问答\n\n\n📊 性能优化建议9.1 ⚡ 服务器优化graph LR    A[性能优化] --&gt; B[网络优化]    A --&gt; C[硬件优化]    A --&gt; D[软件配置]    B --&gt; B1[提高带宽]    B --&gt; B2[优化MTU]    C --&gt; C1[升级CPU]    C --&gt; C2[增加内存]    C --&gt; C3[SSD硬盘]    D --&gt; D1[调整连接数]    D --&gt; D2[启用缓存]    D --&gt; D3[优化日志]\n\n9.2 🔒 安全加固\n定期更新 - 保持 FileZilla Server 为最新版本\n监控访问 - 设置异常访问告警\n备份配置 - 定期备份用户和配置信息\n访问限制 - 限制特定IP访问\n\n\n📚 总结✅ 配置完成清单\n FileZilla Server 安装配置\n 用户账户和权限设置\n 花生壳内网穿透配置\n FTP 被动模式设置\n 防火墙规则配置\n 外网连接测试通过\n\n🎯 使用场景\n个人文件分享 - 在外网访问家中文件\n团队协作 - 共享项目文件\n远程备份 - 外网备份重要数据\n网站维护 - 上传下载网站文件\n\n💡 维护建议\n定期检查花生壳映射状态\n监控服务器性能和连接数\n定期更新密码和安全配置\n备份重要文件和配置\n\n\n\n💡 提示:\n\n花生壳免费版本通常限制映射数量和带宽\n生产环境建议使用付费版本获得更好性能\n定期检查 FTP 服务状态确保可用性\n重要数据建议使用更安全的传输方式如 SFTP\n\n\n","categories":["云原生运维"],"tags":["技术文档","指南"]},{"title":"Web 服务器监控指南","url":"/posts/d7f169a4/","content":"Web 服务器监控指南目录\n概述\n第一部分：连接与健康检查\n第二部分：性能与负载测试\n第三部分：安全扫描与测试\n第四部分：实时系统监控\n第五部分：日志分析\n\n概述本指南提供了一系列常用的命令行工具，用于测试、诊断和监控任何 Web 服务器（如 Nginx, Apache 等）的健康状况、性能和安全性。\n第一部分：连接与健康检查这些工具用于快速验证服务器是否在线、端口是否开放以及服务是否正常响应。\ncurl一个强大的 URL 传输工具，用于发送各种网络请求。\n# Web 服务器监控指南curl -I http://your_domain.com# Web 服务器监控指南curl -I -L http://your_domain.com# Web 服务器监控指南curl -v https://your_domain.com\n\ntelnet &#x2F; nc (Netcat)用于测试特定端口是否可以建立 TCP 连接。\n# Web 服务器监控指南telnet your_domain.com 80# Web 服务器监控指南nc -zv your_domain.com 80nc -zv your_domain.com 443\n\nnmap一个网络扫描工具，用于发现主机和开放的端口。\n# Web 服务器监控指南nmap your_domain.com# Web 服务器监控指南nmap -p 80,443 your_domain.com\n\n第二部分：性能与负载测试这些工具用于向服务器施加压力，以评估其在负载下的性能表现。\nab (Apache Bench)Apache 自带的轻量级压力测试工具。\n# Web 服务器监控指南# Web 服务器监控指南ab -n 1000 -c 100 https://your_domain.com/# Web 服务器监控指南ab -k -n 10000 -c 200 https://your_domain.com/\n\nwrk &#x2F; wrk2一个现代、高性能的 HTTP 压测工具，能产生极高的负载。\n# Web 服务器监控指南# Web 服务器监控指南wrk -t12 -c400 -d30s https://your_domain.com/# Web 服务器监控指南# Web 服务器监控指南# Web 服务器监控指南\n\nsiege一款功能丰富的压力测试工具，可以模拟大量用户并发访问。\n# Web 服务器监控指南siege -c 100 -t1M https://your_domain.com/# Web 服务器监控指南siege -c 50 -f urls.txt\n\n第三部分：安全扫描与测试openssl s_client用于调试 SSL&#x2F;TLS 连接和检查证书信息。\n# Web 服务器监控指南openssl s_client -connect your_domain.com:443 -showcerts# Web 服务器监控指南openssl s_client -connect your_domain.com:443 -tls1_3\n\n在线扫描工具\nSSL Labs SSL Test: 全面分析你网站的 SSL&#x2F;TLS 配置，并给出评分和改进建议。\nhttps://www.ssllabs.com/ssltest/\n\n\nSecurity Headers: 检查你网站的 HTTP 安全头配置。\nhttps://securityheaders.com/\n\n\n\n第四部分：实时系统监控这些是排查服务器性能问题时最常用的 Linux 命令。\nCPU 监控\ntop: 实时显示系统中各个进程的资源占用状况。\nhtop: top 的增强版，界面更友好，操作更方便。\nvmstat 1: 每秒报告一次虚拟内存、进程、CPU 活动等信息。\n\n内存监控\nfree -h: 以人类可读的格式显示内存使用情况（总量、已用、可用、缓存等）。\ncat /proc/meminfo: 显示内核追踪到的详细内存信息。\n\n磁盘 I&#x2F;O 监控\ndf -h: 查看磁盘空间使用情况。\niostat -x 1: 每秒显示一次磁盘的读写性能指标（如 await, %util）。\n\n网络监控\nnetstat -tlnp: 显示所有正在监听的 TCP 和 UDP 端口及其对应的程序。\niftop: 实时监控网络接口的流量。\nnethogs: 按进程分组显示网络带宽占用情况。\n\n第五部分：日志分析日志是排查问题的金矿。tail, grep, awk 是最强大的组合。\n实时查看日志# Web 服务器监控指南sudo tail -f /var/log/nginx/access.log# Web 服务器监控指南sudo tail -f /var/log/apache2/error.log\n\n常用分析命令# Web 服务器监控指南awk &#x27;&#123;print $1&#125;&#x27; /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -10# Web 服务器监控指南awk &#x27;&#123;print $9&#125;&#x27; /var/log/apache2/access.log | sort | uniq -c | sort -nr# Web 服务器监控指南grep &#x27; 404 &#x27; /var/log/nginx/access.log\n","categories":["系统运维管理","监控与诊断"],"tags":["Nginx","Apache","性能测试","负载测试","监控","诊断","ab","wrk"]},{"title":"Linux CLI 参考手册","url":"/posts/d7364a6b/","content":"Linux CLI 参考手册目录\n文件和目录操作\n文本处理\n系统管理\n网络操作\n用户与权限\n进程管理\n包管理\n文件压缩与归档\n系统监控与性能分析\n\n文件和目录操作导航与查看\npwd: 显示当前工作目录。\nls -la: 列出所有文件和目录（包括隐藏的），显示详细信息。\nls -lh: 以人类可读的格式显示文件大小 (K, M, G)。\ncd /path/to/dir: 切换到指定目录。\ncd ..: 切换到上一级目录。\ncd ~ 或 cd: 切换到当前用户的主目录。\ncd -: 切换到上一个工作目录。\n\n创建与删除\ntouch file.txt: 创建一个空文件或更新文件的时间戳。\nmkdir new_dir: 创建一个新目录。\nmkdir -p path/to/new_dir: 递归创建多级目录。\nrm file.txt: 删除一个文件（会提示）。\nrm -f file.txt: 强制删除一个文件。\nrm -r my_dir: 递归删除一个目录及其所有内容。\nrm -rf my_dir: 强制递归删除一个目录（危险命令，请谨慎使用）。\n\n复制与移动\ncp source.txt destination.txt: 复制文件。\ncp -r source_dir/ destination_dir/: 递归复制目录。\nmv old_name.txt new_name.txt: 重命名文件或目录。\nmv source.txt /path/to/destination/: 移动文件或目录。\n\n查找\nfind /path -name &quot;*.log&quot;: 在指定路径下按名称查找文件。\nfind /path -type f -size +100M: 查找大于 100MB 的文件。\nfind /path -name &quot;*.log&quot; -mtime +7: 查找7天前修改的日志文件。\ngrep &quot;pattern&quot; file.txt: 在文件中搜索包含特定模式的行。\ngrep -r &quot;pattern&quot; /path/to/dir: 在目录中递归搜索。\ngrep -i &quot;pattern&quot; file.txt: 忽略大小写搜索。\ngrep -n &quot;pattern&quot; file.txt: 显示匹配行的行号。\ngrep -v &quot;pattern&quot; file.txt: 显示不包含匹配模式的行。\n\n文本处理查看内容\ncat file.txt: 一次性显示整个文件的内容。\nless file.txt: 分页查看文件内容（功能比 more 更强大）。\nhead -n 20 file.txt: 显示文件的前 20 行。\ntail -n 20 file.txt: 显示文件的后 20 行。\ntail -f /var/log/syslog: 实时跟踪文件的新增内容，常用于看日志。\ntail -F /var/log/syslog: 跟踪文件，如果文件被轮转会自动跟踪新文件。\nless +F file.txt: 在 less 中打开文件并进入跟踪模式（按 Ctrl+C 退出跟踪，按 F 重新进入）。\n\n文本工具\nwc -l file.txt: 统计文件的行数。\nwc -w file.txt: 统计文件的单词数。\nsort file.txt: 对文件的行进行排序。\nuniq file.txt: 移除文件中的连续重复行（通常与 sort 配合使用：sort file.txt | uniq）。\ncut -d&#39;,&#39; -f1 data.csv: 以逗号为分隔符，提取第一列。\ntr &#39;a-z&#39; &#39;A-Z&#39; &lt; file.txt: 将文本转换为大写。\ntr -d &#39;\\n&#39; &lt; file.txt: 删除所有换行符。\n\nsed 与 awk\nsed &#39;s/old/new/g&#39; file.txt: 使用 sed 替换文件中的文本。\nsed -i &#39;s/old/new/g&#39; file.txt: 直接修改文件内容（注意备份）。\nawk &#39;{print $1}&#39; file.txt: 使用 awk 打印每一行的第一列（默认以空格分隔）。\nawk -F&#39;,&#39; &#39;{print $2}&#39; data.csv: 以逗号为分隔符，打印第二列。\nawk &#39;{sum+=$1} END {print sum}&#39; numbers.txt: 计算第一列的总和。\n\n系统管理系统信息\nuname -a: 显示详细的内核和系统信息。\nlsb_release -a 或 cat /etc/os-release: 查看 Linux 发行版信息。\nlscpu: 显示 CPU 信息。\nfree -h: 以人类可读格式显示内存使用情况。\ndf -h: 以人类可读格式显示磁盘空间使用情况。\ndu -sh /path/to/dir: 估算目录的总大小。\ndu -h --max-depth=1 /path/to/dir: 显示目录下各子目录的大小。\ndf -i: 显示磁盘 inode 使用情况。\n\n时间与日期\ndate: 显示当前日期和时间。\ntimedatectl: 查看和设置系统时间与时区。\nsudo timedatectl set-timezone Asia/Shanghai: 设置时区为上海。\nsudo timedatectl set-ntp true: (推荐) 启用网络时间同步。\n\n关机与重启\nsudo shutdown -h now 或 sudo poweroff: 立即关机。\nsudo shutdown -r now 或 sudo reboot: 立即重启。\nsudo shutdown -c: 取消一个已计划的关机或重启。\nsudo shutdown -h +60 &quot;System will shutdown in 60 minutes&quot;: 60分钟后关机并提示消息。\nsudo init 0: 关机（另一种方式）。\nsudo init 6: 重启（另一种方式）。\n\n网络操作\nip addr show 或 ip a: 显示所有网络接口的 IP 地址。\nping -c 4 google.com: 发送4个ICMP包测试网络连通性。\nnetstat -tlnp: 显示所有正在监听的 TCP 端口（注意：netstat 已被 ss 替代）。\nss -tuln: 显示所有正在监听的 TCP 和 UDP 端口（netstat 的现代替代品）。\nss -tulpn: 显示监听端口及对应的进程。\nwget https://example.com/file.zip: 下载文件。\nwget -c https://example.com/largefile.zip: 断点续传下载。\ncurl -I http://example.com: 获取一个 URL 的 HTTP 头部信息。\ncurl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;key&quot;:&quot;value&quot;}&#39; https://api.example.com: 发送 POST 请求。\ndig example.com: DNS 查询工具，显示域名解析信息。\nnslookup example.com: 另一个 DNS 查询工具。\n\n用户与权限用户和组\nwhoami: 显示当前登录的用户名。\nsudo adduser newuser: 创建一个新用户（交互式）。\nsudo userdel -r olduser: 删除一个用户及其主目录。\nsudo usermod -aG sudo myuser: 将用户 myuser 添加到 sudo 组。\nsudo usermod -aG docker username: 将用户添加到 docker 组。\ngroups username: 查看用户所属的所有组。\npasswd: 修改当前用户的密码。\nsudo passwd username: 修改其他用户的密码（需要 root 权限）。\n\n文件权限\nchmod 755 script.sh: 设置文件权限为 rwxr-xr-x。\nchmod +x script.sh: 为文件添加可执行权限。\nchmod -R 755 /path/to/dir: 递归设置目录权限。\nchown user:group file.txt: 更改文件的所有者和所属组。\nchown -R user:group /path/to/dir: 递归更改目录的所有权。\nchmod u=rwx,g=rx,o=r file.txt: 使用符号模式设置权限。\numask 022: 设置新创建文件的默认权限掩码。\n\n进程管理\nps aux: 显示当前所有进程的快照。\nps -ef: 显示所有进程的完整格式列表。\ntop 或 htop: 实时、交互式地显示进程和系统资源。\nkill &lt;PID&gt;: 终止一个指定 PID 的进程。\nkill -9 &lt;PID&gt;: 强制终止一个进程（最后的手段）。\nkill -15 &lt;PID&gt;: 发送 SIGTERM 信号，优雅地终止进程。\npkill process_name: 按名称终止进程。\npgrep process_name: 查找进程的 PID。\ncommand &amp;: 在后台运行一个命令。\nnohup command &amp;: 后台运行命令，即使退出终端也继续运行。\njobs: 显示在后台运行的作业。\nbg %1: 将作业1放到后台运行。\nfg %1: 将作业1调到前台运行。\n\n包管理Debian&#x2F;Ubuntu (apt)\nsudo apt update: 刷新可用的软件包列表。\nsudo apt upgrade: 升级所有已安装的软件包。\nsudo apt full-upgrade: 升级所有软件包（可能删除软件包）。\nsudo apt install &lt;package_name&gt;: 安装一个软件包。\nsudo apt install --no-install-recommends &lt;package_name&gt;: 只安装必要的依赖。\nsudo apt remove &lt;package_name&gt;: 卸载一个软件包（保留配置文件）。\nsudo apt purge &lt;package_name&gt;: 完全卸载软件包（包括配置文件）。\nsudo apt autoremove: 自动移除不需要的依赖包。\napt search &lt;keyword&gt;: 搜索软件包。\napt show &lt;package_name&gt;: 显示软件包的详细信息。\n\nRed Hat&#x2F;CentOS&#x2F;Fedora (dnf&#x2F;yum)\nsudo dnf update: 升级所有已安装的软件包。\nsudo dnf upgrade: 升级软件包（不更新内核）。\nsudo dnf install &lt;package_name&gt;: 安装一个软件包。\nsudo dnf remove &lt;package_name&gt;: 卸载一个软件包。\nsudo dnf autoremove: 自动移除不需要的依赖包。\ndnf search &lt;keyword&gt;: 搜索软件包。\ndnf info &lt;package_name&gt;: 显示软件包信息。\n\nArch Linux (pacman)\nsudo pacman -Syu: 同步仓库并升级系统。\nsudo pacman -S &lt;package_name&gt;: 安装软件包。\nsudo pacman -R &lt;package_name&gt;: 删除软件包。\nsudo pacman -Rs &lt;package_name&gt;: 删除软件包及其不需要的依赖。\npacman -Ss &lt;keyword&gt;: 搜索软件包。\npacman -Qi &lt;package_name&gt;: 查看软件包信息。\n\n文件压缩与归档tar 归档\ntar -czf archive.tar.gz files/: 创建 gzip 压缩的 tar 归档。\ntar -xzf archive.tar.gz: 解压 gzip 压缩的 tar 归档。\ntar -cjf archive.tar.bz2 files/: 创建 bzip2 压缩的 tar 归档。\ntar -xjf archive.tar.bz2: 解压 bzip2 压缩的 tar 归档。\ntar -czf archive.tar.gz --exclude=&#39;*.log&#39; directory/: 创建归档但排除日志文件。\ntar -tzf archive.tar.gz: 查看归档内容但不解压。\n\nzip 压缩\nzip -r archive.zip files/: 创建 zip 压缩包。\nunzip archive.zip: 解压 zip 文件。\nunzip -l archive.zip: 查看 zip 文件内容。\nzip -r archive.zip files/ -x &quot;*.log&quot;: 创建 zip 压缩包但排除日志文件。\n\n其他压缩格式\ngzip file.txt: 压缩文件（原文件会被替换为 .gz）。\ngzip -d file.txt.gz: 解压 gzip 文件。\nbzip2 file.txt: 使用 bzip2 压缩（更高的压缩率）。\nbzip2 -d file.txt.bz2: 解压 bzip2 文件。\nxz file.txt: 使用 xz 压缩（现代高效率压缩）。\nxz -d file.txt.xz: 解压 xz 文件。\n\n系统监控与性能分析系统负载\nuptime: 显示系统运行时间、用户数和平均负载。\nw: 显示当前登录用户和系统负载。\nload average: 通过 uptime 或 top 查看 1、5、15分钟的平均负载。\n\n内存使用分析\nfree -h: 以人类可读格式显示内存使用情况。\nfree -m: 以 MB 为单位显示内存使用。\nvmstat 5: 每5秒显示一次虚拟内存统计信息。\n\nCPU 使用分析\ntop: 实时显示进程和 CPU 使用情况。\nhtop: 更友好的交互式进程查看器（需要安装）。\nmpstat 1: 每秒显示一次 CPU 统计信息。\n\n磁盘 I&#x2F;O 监控\niostat: 显示 CPU 和 I&#x2F;O 统计信息。\niotop: 显示进程的 I&#x2F;O 使用情况（需要安装）。\ndf -h: 查看磁盘空间使用情况。\n\n网络监控\niftop: 实时显示网络带宽使用（需要安装）。\nnethogs: 按进程显示网络使用（需要安装）。\ntcpdump -i eth0: 捕获网络包（需要 root 权限）。\n\n日志查看\njournalctl -xe: 查看系统日志（systemd 系统）。\njournalctl -u nginx: 查看特定服务的日志。\ntail -f /var/log/syslog: 实时查看系统日志。\ntail -100f /var/log/nginx/access.log: 查看最后100行并实时跟踪。\n\n","categories":["系统运维管理","Linux系统管理"],"tags":["Linux","系统管理","Bash","命令行","Shell","Cheatsheet"]},{"title":"服务器认证 API 规范","url":"/posts/ec4e5506/","content":"服务器认证 API 规范\n文档创建时间: 2025-11-14最后更新: 2025-11-14标签: authentication, api, security, jwt, express, nodejs, middleware\n\n📑 目录\n1. 概述\n2. 认证中间件\n3. 认证流程\n3.1 注册流程\n3.2 登录流程\n3.3 Token 验证流程\n\n\n4. 安全措施\n4.1 输入验证\n4.2 请求频率限制\n4.3 CORS 配置\n\n\n5. 用户模型\n6. 受保护的路由\n7. 客户端使用\n8. 高级特性\n9. 测试与调试\n\n\n1. 📖 概述本指南详细说明如何实现服务器端的用户认证系统，包括注册、登录、Token 验证以及相关安全措施。\n🎯 认证系统特性\n✅ JWT Token 认证\n✅ 密码加密存储\n✅ 请求频率限制\n✅ 输入验证和清理\n✅ CORS 跨域保护\n✅ 错误处理和安全日志\n\n🏗️ 系统架构graph TD    A[Client Request] --&gt; B[Rate Limiting]    B --&gt; C[Input Validation]    C --&gt; D[Auth Middleware]    D --&gt; E&#123;Public Route?&#125;    E --&gt;|Yes| F[Business Logic]    E --&gt;|No| G[JWT Verification]    G --&gt; H[User Extraction]    H --&gt; F    F --&gt; I[Response]\n\n\n2. 🔐 认证中间件2.1 📄 中间件实现 (src/middleware/auth.js)const jwt = require(&#x27;jsonwebtoken&#x27;);const rateLimit = require(&#x27;express-rate-limit&#x27;);const helmet = require(&#x27;helmet&#x27;);/** * JWT Token 认证中间件 * @param &#123;Object&#125; req - Express 请求对象 * @param &#123;Object&#125; res - Express 响应对象 * @param &#123;Function&#125; next - Express 下一个中间件函数 */const authenticateToken = (req, res, next) =&gt; &#123;    try &#123;        // 从请求头获取 Bearer Token        const authHeader = req.headers[&#x27;authorization&#x27;];        const token = authHeader &amp;&amp; authHeader.split(&#x27; &#x27;)[1];        // 验证 Token 格式        if (!token) &#123;            return res.status(401).json(&#123;                success: false,                message: &#x27;Access token is required&#x27;,                code: &#x27;TOKEN_MISSING&#x27;            &#125;);        &#125;        if (!authHeader.startsWith(&#x27;Bearer &#x27;)) &#123;            return res.status(401).json(&#123;                success: false,                message: &#x27;Invalid token format. Expected: Bearer &lt;token&gt;&#x27;,                code: &#x27;TOKEN_FORMAT_INVALID&#x27;            &#125;);        &#125;        // 验证 JWT Token        jwt.verify(token, process.env.JWT_SECRET, &#123;            algorithms: [&#x27;HS256&#x27;],            clockTolerance: 30 // 允许30秒时钟偏差        &#125;, (err, decoded) =&gt; &#123;            if (err) &#123;                console.warn(`JWT Verification failed: $&#123;err.message&#125;`);                return res.status(403).json(&#123;                    success: false,                    message: &#x27;Invalid or expired token&#x27;,                    code: &#x27;TOKEN_INVALID&#x27;,                    details: err.name // 可选：生产环境可能要隐藏                &#125;);            &#125;            // 将用户信息附加到请求对象            req.user = &#123;                id: decoded.userId,                iat: decoded.iat,                exp: decoded.exp            &#125;;            next();        &#125;);    &#125; catch (error) &#123;        console.error(&#x27;Authentication middleware error:&#x27;, error);        return res.status(500).json(&#123;            success: false,            message: &#x27;Internal server error during authentication&#x27;,            code: &#x27;AUTH_ERROR&#x27;        &#125;);    &#125;&#125;;/** * 可选的认证中间件 - Token 可选的路由 */const optionalAuth = (req, res, next) =&gt; &#123;    const authHeader = req.headers[&#x27;authorization&#x27;];    const token = authHeader &amp;&amp; authHeader.split(&#x27; &#x27;)[1];    if (token) &#123;        authenticateToken(req, res, next);    &#125; else &#123;        next(); // 没有 Token 时继续执行    &#125;&#125;;module.exports = &#123;    authenticateToken,    optionalAuth&#125;;\n\n2.2 🚦 请求频率限制/** * 认证相关的频率限制 */const authLimiter = rateLimit(&#123;    windowMs: 15 * 60 * 1000,  // 15分钟窗口期    max: 5,                    // 最多5次尝试    message: &#123;        success: false,        message: &#x27;Too many authentication attempts, please try again later&#x27;,        code: &#x27;RATE_LIMIT_EXCEEDED&#x27;,        retryAfter: &#x27;15 minutes&#x27;    &#125;,    standardHeaders: true,      // 返回速率限制信息在 headers    legacyHeaders: false,      // 禁用 `X-RateLimit-*` headers    handler: (req, res) =&gt; &#123;        res.status(429).json(&#123;            success: false,            message: &#x27;Too many authentication attempts, please try again later&#x27;,            code: &#x27;RATE_LIMIT_EXCEEDED&#x27;,            retryAfter: &#x27;15 minutes&#x27;        &#125;);    &#125;&#125;);/** * 一般 API 的频率限制 */const apiLimiter = rateLimit(&#123;    windowMs: 15 * 60 * 1000,  // 15分钟    max: 100,                  // 最多100次请求    message: &#123;        success: false,        message: &#x27;API rate limit exceeded&#x27;,        code: &#x27;API_RATE_LIMIT_EXCEEDED&#x27;    &#125;&#125;);module.exports = &#123;    authLimiter,    apiLimiter&#125;;\n\n\n3. 🔑 认证流程3.1 📝 注册流程 (/auth/register)const express = require(&#x27;express&#x27;);const &#123; body, validationResult &#125; = require(&#x27;express-validator&#x27;);const bcrypt = require(&#x27;bcrypt&#x27;);const router = express.Router();// 注册验证规则const registerValidation = [    body(&#x27;username&#x27;)        .trim()        .isLength(&#123; min: 3, max: 20 &#125;)        .withMessage(&#x27;Username must be 3-20 characters long&#x27;)        .matches(/^[a-zA-Z0-9_]+$/)        .withMessage(&#x27;Username can only contain letters, numbers and underscores&#x27;),    body(&#x27;email&#x27;)        .isEmail()        .normalizeEmail()        .withMessage(&#x27;Valid email address is required&#x27;),    body(&#x27;password&#x27;)        .isLength(&#123; min: 6 &#125;)        .withMessage(&#x27;Password must be at least 6 characters long&#x27;)        .matches(/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).*$/)        .withMessage(&#x27;Password must contain at least one uppercase letter, one lowercase letter, and one number&#x27;)];/** * 用户注册路由 * POST /auth/register */router.post(&#x27;/register&#x27;,    registerValidation,  // 输入验证    validate,            // 验证结果处理    authLimiter,        // 请求频率限制    async (req, res) =&gt; &#123;        const transaction = await pool.beginTransaction();        try &#123;            const &#123; username, password, email &#125; = req.body;            console.info(`Registration attempt: username=$&#123;username&#125;, email=$&#123;email&#125;`);            // 1. 检查用户名是否已存在            const [existingUser] = await pool.execute(                &#x27;SELECT id FROM users WHERE username = ? OR email = ?&#x27;,                [username, email]            );            if (existingUser.length &gt; 0) &#123;                await transaction.rollback();                return res.status(400).json(&#123;                    success: false,                    message: existingUser[0].username === username                        ? &#x27;Username is already taken&#x27;                        : &#x27;Email is already registered&#x27;,                    code: &#x27;USER_EXISTS&#x27;                &#125;);            &#125;            // 2. 密码加密            const saltRounds = 12;            const hashedPassword = await bcrypt.hash(password, saltRounds);            // 3. 创建新用户            const [result] = await pool.execute(                &#x27;INSERT INTO users (username, password, email, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW())&#x27;,                [username, hashedPassword, email]            );            const userId = result.insertId;            // 4. 生成 JWT Token            const token = jwt.sign(                &#123;                    userId,                    username,                    type: &#x27;access&#x27;                &#125;,                process.env.JWT_SECRET,                &#123;                    expiresIn: &#x27;24h&#x27;,                    algorithm: &#x27;HS256&#x27;,                    issuer: &#x27;your-app-name&#x27;,                    audience: &#x27;your-app-users&#x27;                &#125;            );            // 5. 生成 Refresh Token (可选)            const refreshToken = jwt.sign(                &#123;                    userId,                    type: &#x27;refresh&#x27;                &#125;,                process.env.JWT_REFRESH_SECRET,                &#123;                    expiresIn: &#x27;7d&#x27;,                    algorithm: &#x27;HS256&#x27;                &#125;            );            // 6. 保存 Refresh Token 到数据库 (可选)            await pool.execute(                &#x27;UPDATE users SET refresh_token = ? WHERE id = ?&#x27;,                [refreshToken, userId]            );            await transaction.commit();            console.info(`User registered successfully: userId=$&#123;userId&#125;, username=$&#123;username&#125;`);            // 7. 返回成功响应 (不包含敏感信息)            res.status(201).json(&#123;                success: true,                message: &#x27;Registration successful&#x27;,                data: &#123;                    user: &#123;                        id: userId,                        username: username,                        email: email,                        created_at: new Date().toISOString()                    &#125;,                    tokens: &#123;                        access_token: token,                        refresh_token: refreshToken,                        token_type: &#x27;Bearer&#x27;,                        expires_in: 86400 // 24小时                    &#125;                &#125;            &#125;);        &#125; catch (error) &#123;            await transaction.rollback();            console.error(&#x27;Registration error:&#x27;, error);            res.status(500).json(&#123;                success: false,                message: &#x27;Registration failed due to server error&#x27;,                code: &#x27;REGISTRATION_ERROR&#x27;            &#125;);        &#125;    &#125;);\n\n3.2 🔐 登录流程 (/auth/login)/** * 用户登录路由 * POST /auth/login */router.post(&#x27;/login&#x27;,    authLimiter,      // 请求频率限制    [        body(&#x27;username&#x27;)            .trim()            .notEmpty()            .withMessage(&#x27;Username or email is required&#x27;),        body(&#x27;password&#x27;)            .notEmpty()            .withMessage(&#x27;Password is required&#x27;)    ],    validate,         // 验证结果处理    async (req, res) =&gt; &#123;        try &#123;            const &#123; username, password &#125; = req.body;            console.info(`Login attempt: username=$&#123;username&#125;`);            // 1. 查找用户 (支持用户名或邮箱登录)            const [users] = await pool.execute(                &#x27;SELECT id, username, email, password, refresh_token, failed_login_attempts, locked_until FROM users WHERE username = ? OR email = ?&#x27;,                [username, username]            );            if (users.length === 0) &#123;                return res.status(401).json(&#123;                    success: false,                    message: &#x27;Invalid username or password&#x27;,                    code: &#x27;INVALID_CREDENTIALS&#x27;                &#125;);            &#125;            const user = users[0];            // 2. 检查账户是否被锁定            if (user.locked_until &amp;&amp; new Date() &lt; new Date(user.locked_until)) &#123;                return res.status(423).json(&#123;                    success: false,                    message: &#x27;Account is temporarily locked due to too many failed login attempts&#x27;,                    code: &#x27;ACCOUNT_LOCKED&#x27;,                    locked_until: user.locked_until                &#125;);            &#125;            // 3. 验证密码            const isValidPassword = await bcrypt.compare(password, user.password);            if (!isValidPassword) &#123;                // 增加失败次数                const newFailedAttempts = user.failed_login_attempts + 1;                const lockAccount = newFailedAttempts &gt;= 5;                await pool.execute(                    `UPDATE users SET                     failed_login_attempts = ?,                     locked_until = ?                     WHERE id = ?`,                    [                        lockAccount ? 0 : newFailedAttempts,                        lockAccount ? new Date(Date.now() + 30 * 60 * 1000) : null, // 30分钟锁定                        user.id                    ]                );                console.warn(`Failed login attempt: username=$&#123;username&#125;, attempts=$&#123;newFailedAttempts&#125;`);                return res.status(401).json(&#123;                    success: false,                    message: &#x27;Invalid username or password&#x27;,                    code: &#x27;INVALID_CREDENTIALS&#x27;,                    remaining_attempts: Math.max(0, 5 - newFailedAttempts)                &#125;);            &#125;            // 4. 登录成功 - 重置失败次数            await pool.execute(                &#x27;UPDATE users SET failed_login_attempts = 0, locked_until = NULL, last_login = NOW() WHERE id = ?&#x27;,                [user.id]            );            // 5. 生成 JWT Token            const token = jwt.sign(                &#123;                    userId: user.id,                    username: user.username,                    type: &#x27;access&#x27;                &#125;,                process.env.JWT_SECRET,                &#123;                    expiresIn: &#x27;24h&#x27;,                    algorithm: &#x27;HS256&#x27;,                    issuer: &#x27;your-app-name&#x27;,                    audience: &#x27;your-app-users&#x27;                &#125;            );            // 6. 生成新的 Refresh Token            const refreshToken = jwt.sign(                &#123;                    userId: user.id,                    type: &#x27;refresh&#x27;                &#125;,                process.env.JWT_REFRESH_SECRET,                &#123;                    expiresIn: &#x27;7d&#x27;,                    algorithm: &#x27;HS256&#x27;                &#125;            );            // 7. 更新 Refresh Token            await pool.execute(                &#x27;UPDATE users SET refresh_token = ? WHERE id = ?&#x27;,                [refreshToken, user.id]            );            console.info(`User logged in successfully: userId=$&#123;user.id&#125;, username=$&#123;user.username&#125;`);            res.json(&#123;                success: true,                message: &#x27;Login successful&#x27;,                data: &#123;                    user: &#123;                        id: user.id,                        username: user.username,                        email: user.email,                        last_login: new Date().toISOString()                    &#125;,                    tokens: &#123;                        access_token: token,                        refresh_token: refreshToken,                        token_type: &#x27;Bearer&#x27;,                        expires_in: 86400 // 24小时                    &#125;                &#125;            &#125;);        &#125; catch (error) &#123;            console.error(&#x27;Login error:&#x27;, error);            res.status(500).json(&#123;                success: false,                message: &#x27;Login failed due to server error&#x27;,                code: &#x27;LOGIN_ERROR&#x27;            &#125;);        &#125;    &#125;);\n\n3.3 🔄 Token 刷新流程/** * 刷新访问令牌 * POST /auth/refresh */router.post(&#x27;/refresh&#x27;,    async (req, res) =&gt; &#123;        try &#123;            const &#123; refresh_token &#125; = req.body;            if (!refresh_token) &#123;                return res.status(401).json(&#123;                    success: false,                    message: &#x27;Refresh token is required&#x27;,                    code: &#x27;REFRESH_TOKEN_MISSING&#x27;                &#125;);            &#125;            // 验证 Refresh Token            jwt.verify(refresh_token, process.env.JWT_REFRESH_SECRET, async (err, decoded) =&gt; &#123;                if (err) &#123;                    return res.status(403).json(&#123;                        success: false,                        message: &#x27;Invalid refresh token&#x27;,                        code: &#x27;REFRESH_TOKEN_INVALID&#x27;                    &#125;);                &#125;                // 检查数据库中的 Refresh Token                const [users] = await pool.execute(                    &#x27;SELECT id, username, refresh_token FROM users WHERE id = ?&#x27;,                    [decoded.userId]                );                if (users.length === 0 || users[0].refresh_token !== refresh_token) &#123;                    return res.status(403).json(&#123;                        success: false,                        message: &#x27;Invalid refresh token&#x27;,                        code: &#x27;REFRESH_TOKEN_MISMATCH&#x27;                    &#125;);                &#125;                // 生成新的 Access Token                const newAccessToken = jwt.sign(                    &#123;                        userId: decoded.userId,                        username: users[0].username,                        type: &#x27;access&#x27;                    &#125;,                    process.env.JWT_SECRET,                    &#123;                        expiresIn: &#x27;24h&#x27;,                        algorithm: &#x27;HS256&#x27;                    &#125;                );                res.json(&#123;                    success: true,                    message: &#x27;Token refreshed successfully&#x27;,                    data: &#123;                        access_token: newAccessToken,                        token_type: &#x27;Bearer&#x27;,                        expires_in: 86400                    &#125;                &#125;);            &#125;);        &#125; catch (error) &#123;            console.error(&#x27;Token refresh error:&#x27;, error);            res.status(500).json(&#123;                success: false,                message: &#x27;Token refresh failed&#x27;,                code: &#x27;REFRESH_ERROR&#x27;            &#125;);        &#125;    &#125;);\n\n\n4. 🛡️ 安全措施4.1 ✅ 输入验证const &#123; body, validationResult &#125; = require(&#x27;express-validator&#x27;);// 验证结果处理中间件const validate = (req, res, next) =&gt; &#123;    const errors = validationResult(req);    if (!errors.isEmpty()) &#123;        return res.status(400).json(&#123;            success: false,            message: &#x27;Validation failed&#x27;,            code: &#x27;VALIDATION_ERROR&#x27;,            errors: errors.array()        &#125;);    &#125;    next();&#125;;// 通用验证规则const commonValidation = &#123;    username: [        body(&#x27;username&#x27;)            .trim()            .isLength(&#123; min: 3, max: 20 &#125;)            .matches(/^[a-zA-Z0-9_]+$/)    ],    email: [        body(&#x27;email&#x27;)            .isEmail()            .normalizeEmail()    ],    password: [        body(&#x27;password&#x27;)            .isLength(&#123; min: 8 &#125;)            .matches(/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@$!%*?&amp;]).*$/)            .withMessage(&#x27;Password must be at least 8 characters long and contain uppercase, lowercase, number, and special character&#x27;)    ]&#125;;\n\n4.2 🚦 CORS 配置const cors = require(&#x27;cors&#x27;);const corsOptions = &#123;    origin: function (origin, callback) &#123;        const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(&#x27;,&#x27;) || [&#x27;http://localhost:3000&#x27;];        // 允许没有 origin 的请求 (如移动应用)        if (!origin) return callback(null, true);        if (allowedOrigins.includes(origin)) &#123;            callback(null, true);        &#125; else &#123;            callback(new Error(&#x27;Not allowed by CORS&#x27;));        &#125;    &#125;,    methods: [&#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;, &#x27;OPTIONS&#x27;],    allowedHeaders: [&#x27;Content-Type&#x27;, &#x27;Authorization&#x27;, &#x27;X-Requested-With&#x27;],    credentials: true,    optionsSuccessStatus: 200,    maxAge: 86400 // 24小时&#125;;app.use(cors(corsOptions));\n\n4.3 🔒 安全头部const helmet = require(&#x27;helmet&#x27;);app.use(helmet(&#123;    contentSecurityPolicy: &#123;        directives: &#123;            defaultSrc: [&quot;&#x27;self&#x27;&quot;],            styleSrc: [&quot;&#x27;self&#x27;&quot;, &quot;&#x27;unsafe-inline&#x27;&quot;],            scriptSrc: [&quot;&#x27;self&#x27;&quot;],            imgSrc: [&quot;&#x27;self&#x27;&quot;, &quot;data:&quot;, &quot;https:&quot;],        &#125;,    &#125;,    hsts: &#123;        maxAge: 31536000,        includeSubDomains: true,        preload: true    &#125;&#125;));\n\n\n5. 👤 用户模型const bcrypt = require(&#x27;bcrypt&#x27;);const pool = require(&#x27;../database/connection&#x27;);class User &#123;    /**     * 创建用户     * @param &#123;string&#125; username - 用户名     * @param &#123;string&#125; password - 明文密码     * @param &#123;string&#125; email - 邮箱     * @returns &#123;Promise&lt;number&gt;&#125; 用户ID     */    static async createUser(username, password, email) &#123;        const hashedPassword = await bcrypt.hash(password, 12);        const [result] = await pool.execute(            &#x27;INSERT INTO users (username, password, email, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW())&#x27;,            [username, hashedPassword, email]        );        return result.insertId;    &#125;    /**     * 根据用户名查找用户     * @param &#123;string&#125; username - 用户名     * @returns &#123;Promise&lt;Object|null&gt;&#125; 用户对象     */    static async findUserByUsername(username) &#123;        const [users] = await pool.execute(            &#x27;SELECT id, username, email, password, created_at, updated_at FROM users WHERE username = ?&#x27;,            [username]        );        return users[0] || null;    &#125;    /**     * 根据邮箱查找用户     * @param &#123;string&#125; email - 邮箱     * @returns &#123;Promise&lt;Object|null&gt;&#125; 用户对象     */    static async findUserByEmail(email) &#123;        const [users] = await pool.execute(            &#x27;SELECT id, username, email, password, created_at, updated_at FROM users WHERE email = ?&#x27;,            [email]        );        return users[0] || null;    &#125;    /**     * 验证密码     * @param &#123;string&#125; password - 明文密码     * @param &#123;string&#125; hashedPassword - 哈希密码     * @returns &#123;Promise&lt;boolean&gt;&#125; 验证结果     */    static async verifyPassword(password, hashedPassword) &#123;        return await bcrypt.compare(password, hashedPassword);    &#125;    /**     * 更新用户最后登录时间     * @param &#123;number&#125; userId - 用户ID     * @returns &#123;Promise&lt;void&gt;&#125;     */    static async updateLastLogin(userId) &#123;        await pool.execute(            &#x27;UPDATE users SET last_login = NOW() WHERE id = ?&#x27;,            [userId]        );    &#125;    /**     * 检查用户是否存在     * @param &#123;string&#125; username - 用户名     * @param &#123;string&#125; email - 邮箱     * @returns &#123;Promise&lt;boolean&gt;&#125; 是否存在     */    static async userExists(username, email) &#123;        const [users] = await pool.execute(            &#x27;SELECT id FROM users WHERE username = ? OR email = ?&#x27;,            [username, email]        );        return users.length &gt; 0;    &#125;&#125;module.exports = User;\n\n\n6. 🛡️ 受保护的路由const &#123; authenticateToken &#125; = require(&#x27;../middleware/auth&#x27;);const router = express.Router();/** * 获取用户信息 * GET /api/user/profile */router.get(&#x27;/profile&#x27;, authenticateToken, async (req, res) =&gt; &#123;    try &#123;        const userId = req.user.id;        const [users] = await pool.execute(            &#x27;SELECT id, username, email, created_at, last_login FROM users WHERE id = ?&#x27;,            [userId]        );        if (users.length === 0) &#123;            return res.status(404).json(&#123;                success: false,                message: &#x27;User not found&#x27;,                code: &#x27;USER_NOT_FOUND&#x27;            &#125;);        &#125;        res.json(&#123;            success: true,            data: &#123;                user: users[0]            &#125;        &#125;);    &#125; catch (error) &#123;        console.error(&#x27;Profile fetch error:&#x27;, error);        res.status(500).json(&#123;            success: false,            message: &#x27;Failed to fetch profile&#x27;,            code: &#x27;PROFILE_ERROR&#x27;        &#125;);    &#125;&#125;);/** * 文件上传路由 * POST /api/files/upload */router.post(&#x27;/upload&#x27;,    authenticateToken,    upload.single(&#x27;file&#x27;),    async (req, res) =&gt; &#123;        try &#123;            if (!req.file) &#123;                return res.status(400).json(&#123;                    success: false,                    message: &#x27;No file uploaded&#x27;,                    code: &#x27;NO_FILE_UPLOADED&#x27;                &#125;);            &#125;            // 文件处理逻辑...            res.json(&#123;                success: true,                message: &#x27;File uploaded successfully&#x27;,                data: &#123;                    filename: req.file.filename,                    size: req.file.size,                    mimetype: req.file.mimetype                &#125;            &#125;);        &#125; catch (error) &#123;            console.error(&#x27;File upload error:&#x27;, error);            res.status(500).json(&#123;                success: false,                message: &#x27;File upload failed&#x27;,                code: &#x27;UPLOAD_ERROR&#x27;            &#125;);        &#125;    &#125;);\n\n\n7. 💻 客户端使用7.1 🔐 登录示例class AuthClient &#123;    constructor(baseURL) &#123;        this.baseURL = baseURL;        this.token = null;    &#125;    /**     * 用户登录     * @param &#123;string&#125; username - 用户名或邮箱     * @param &#123;string&#125; password - 密码     * @returns &#123;Promise&lt;Object&gt;&#125; 登录结果     */    async login(username, password) &#123;        try &#123;            const response = await fetch(`$&#123;this.baseURL&#125;/auth/login`, &#123;                method: &#x27;POST&#x27;,                headers: &#123;                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,                &#125;,                body: JSON.stringify(&#123; username, password &#125;)            &#125;);            const data = await response.json();            if (data.success) &#123;                this.token = data.data.tokens.access_token;                this.refreshToken = data.data.tokens.refresh_token;                // 存储到 localStorage                localStorage.setItem(&#x27;access_token&#x27;, this.token);                localStorage.setItem(&#x27;refresh_token&#x27;, this.refreshToken);            &#125;            return data;        &#125; catch (error) &#123;            console.error(&#x27;Login error:&#x27;, error);            throw error;        &#125;    &#125;    /**     * 带认证的请求     * @param &#123;string&#125; url - 请求URL     * @param &#123;Object&#125; options - 请求选项     * @returns &#123;Promise&lt;Response&gt;&#125; 响应对象     */    async authenticatedRequest(url, options = &#123;&#125;) &#123;        if (!this.token) &#123;            throw new Error(&#x27;No authentication token available&#x27;);        &#125;        const defaultOptions = &#123;            headers: &#123;                &#x27;Authorization&#x27;: `Bearer $&#123;this.token&#125;`,                &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,            &#125;,            ...options        &#125;;        let response = await fetch(url, defaultOptions);        // Token 过期时自动刷新        if (response.status === 403) &#123;            await this.refreshAccessToken();            defaultOptions.headers.Authorization = `Bearer $&#123;this.token&#125;`;            response = await fetch(url, defaultOptions);        &#125;        return response;    &#125;    /**     * 刷新访问令牌     */    async refreshAccessToken() &#123;        try &#123;            const response = await fetch(`$&#123;this.baseURL&#125;/auth/refresh`, &#123;                method: &#x27;POST&#x27;,                headers: &#123;                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,                &#125;,                body: JSON.stringify(&#123;                    refresh_token: this.refreshToken                &#125;)            &#125;);            const data = await response.json();            if (data.success) &#123;                this.token = data.data.access_token;                localStorage.setItem(&#x27;access_token&#x27;, this.token);            &#125; else &#123;                throw new Error(&#x27;Token refresh failed&#x27;);            &#125;        &#125; catch (error) &#123;            console.error(&#x27;Token refresh error:&#x27;, error);            this.logout();            throw error;        &#125;    &#125;    /**     * 用户登出     */    logout() &#123;        this.token = null;        this.refreshToken = null;        localStorage.removeItem(&#x27;access_token&#x27;);        localStorage.removeItem(&#x27;refresh_token&#x27;);    &#125;&#125;// 使用示例const authClient = new AuthClient(&#x27;http://localhost:3000/api&#x27;);// 登录const loginResult = await authClient.login(&#x27;username&#x27;, &#x27;password&#x27;);// 发送认证请求const profileResponse = await authClient.authenticatedRequest(&#x27;/user/profile&#x27;);const profileData = await profileResponse.json();\n\n\n8. 🚀 高级特性8.1 🔄 双因素认证 (2FA)const speakeasy = require(&#x27;speakeasy&#x27;);const qrcode = require(&#x27;qrcode&#x27;);/** * 启用双因素认证 */router.post(&#x27;/2fa/enable&#x27;, authenticateToken, async (req, res) =&gt; &#123;    try &#123;        const userId = req.user.id;        // 生成密钥        const secret = speakeasy.generateSecret(&#123;            name: `YourApp ($&#123;req.user.username&#125;)`,            issuer: &#x27;YourApp&#x27;,            length: 32        &#125;);        // 保存密钥到数据库 (未验证状态)        await pool.execute(            &#x27;UPDATE users SET two_factor_secret = ?, two_factor_enabled = FALSE WHERE id = ?&#x27;,            [secret.base32, userId]        );        // 生成二维码        const qrCodeUrl = await qrcode.toDataURL(secret.otpauth_url);        res.json(&#123;            success: true,            message: &#x27;2FA setup initiated&#x27;,            data: &#123;                secret: secret.base32,                qr_code: qrCodeUrl,                backup_codes: generateBackupCodes()            &#125;        &#125;);    &#125; catch (error) &#123;        console.error(&#x27;2FA enable error:&#x27;, error);        res.status(500).json(&#123;            success: false,            message: &#x27;Failed to enable 2FA&#x27;,            code: &#x27;TWO_FA_ENABLE_ERROR&#x27;        &#125;);    &#125;&#125;);/** * 验证双因素认证 */router.post(&#x27;/2fa/verify&#x27;, authenticateToken, async (req, res) =&gt; &#123;    try &#123;        const &#123; token &#125; = req.body;        const userId = req.user.id;        // 获取用户的密钥        const [users] = await pool.execute(            &#x27;SELECT two_factor_secret FROM users WHERE id = ?&#x27;,            [userId]        );        if (users.length === 0 || !users[0].two_factor_secret) &#123;            return res.status(400).json(&#123;                success: false,                message: &#x27;2FA not set up for this user&#x27;,                code: &#x27;TWO_FA_NOT_SETUP&#x27;            &#125;);        &#125;        // 验证令牌        const verified = speakeasy.totp.verify(&#123;            secret: users[0].two_factor_secret,            encoding: &#x27;base32&#x27;,            token: token,            window: 2 // 允许2个时间窗口的偏差        &#125;);        if (!verified) &#123;            return res.status(400).json(&#123;                success: false,                message: &#x27;Invalid 2FA token&#x27;,                code: &#x27;TWO_FA_INVALID_TOKEN&#x27;            &#125;);        &#125;        // 启用双因素认证        await pool.execute(            &#x27;UPDATE users SET two_factor_enabled = TRUE WHERE id = ?&#x27;,            [userId]        );        res.json(&#123;            success: true,            message: &#x27;2FA enabled successfully&#x27;        &#125;);    &#125; catch (error) &#123;        console.error(&#x27;2FA verification error:&#x27;, error);        res.status(500).json(&#123;            success: false,            message: &#x27;Failed to verify 2FA&#x27;,            code: &#x27;TWO_FA_VERIFY_ERROR&#x27;        &#125;);    &#125;&#125;);\n\n8.2 📝 审计日志/** * 记录安全事件 */async function logSecurityEvent(userId, eventType, details, ipAddress, userAgent) &#123;    try &#123;        await pool.execute(            `INSERT INTO security_logs             (user_id, event_type, details, ip_address, user_agent, created_at)             VALUES (?, ?, ?, ?, ?, NOW())`,            [userId, eventType, JSON.stringify(details), ipAddress, userAgent]        );    &#125; catch (error) &#123;        console.error(&#x27;Failed to log security event:&#x27;, error);    &#125;&#125;// 在认证路由中使用router.post(&#x27;/login&#x27;, authLimiter, async (req, res) =&gt; &#123;    const ipAddress = req.ip;    const userAgent = req.get(&#x27;User-Agent&#x27;);    // ... 登录逻辑 ...    if (loginSuccessful) &#123;        await logSecurityEvent(            user.id,            &#x27;LOGIN_SUCCESS&#x27;,            &#123; username &#125;,            ipAddress,            userAgent        );    &#125; else &#123;        await logSecurityEvent(            null, // 未知用户            &#x27;LOGIN_FAILED&#x27;,            &#123; username, reason: &#x27;invalid_credentials&#x27; &#125;,            ipAddress,            userAgent        );    &#125;&#125;);\n\n\n9. 🧪 测试与调试9.1 🧪 单元测试const request = require(&#x27;supertest&#x27;);const app = require(&#x27;../app&#x27;);const pool = require(&#x27;../database/connection&#x27;);describe(&#x27;Authentication API&#x27;, () =&gt; &#123;    beforeEach(async () =&gt; &#123;        // 清理测试数据        await pool.execute(&#x27;DELETE FROM users WHERE username LIKE &quot;test_%&quot;&#x27;);    &#125;);    afterAll(async () =&gt; &#123;        // 关闭数据库连接        await pool.end();    &#125;);    describe(&#x27;POST /auth/register&#x27;, () =&gt; &#123;        it(&#x27;should register a new user successfully&#x27;, async () =&gt; &#123;            const userData = &#123;                username: &#x27;test_user&#x27;,                email: &#x27;test@example.com&#x27;,                password: &#x27;TestPass123!&#x27;            &#125;;            const response = await request(app)                .post(&#x27;/auth/register&#x27;)                .send(userData)                .expect(201);            expect(response.body.success).toBe(true);            expect(response.body.data.user.username).toBe(userData.username);            expect(response.body.data.tokens.access_token).toBeDefined();        &#125;);        it(&#x27;should reject duplicate username&#x27;, async () =&gt; &#123;            const userData = &#123;                username: &#x27;test_user&#x27;,                email: &#x27;test@example.com&#x27;,                password: &#x27;TestPass123!&#x27;            &#125;;            // 第一次注册成功            await request(app)                .post(&#x27;/auth/register&#x27;)                .send(userData)                .expect(201);            // 第二次注册失败            const response = await request(app)                .post(&#x27;/auth/register&#x27;)                .send(userData)                .expect(400);            expect(response.body.success).toBe(false);            expect(response.body.code).toBe(&#x27;USER_EXISTS&#x27;);        &#125;);    &#125;);    describe(&#x27;POST /auth/login&#x27;, () =&gt; &#123;        beforeEach(async () =&gt; &#123;            // 创建测试用户            await request(app)                .post(&#x27;/auth/register&#x27;)                .send(&#123;                    username: &#x27;test_user&#x27;,                    email: &#x27;test@example.com&#x27;,                    password: &#x27;TestPass123!&#x27;                &#125;);        &#125;);        it(&#x27;should login with valid credentials&#x27;, async () =&gt; &#123;            const response = await request(app)                .post(&#x27;/auth/login&#x27;)                .send(&#123;                    username: &#x27;test_user&#x27;,                    password: &#x27;TestPass123!&#x27;                &#125;)                .expect(200);            expect(response.body.success).toBe(true);            expect(response.body.data.tokens.access_token).toBeDefined();        &#125;);        it(&#x27;should reject invalid credentials&#x27;, async () =&gt; &#123;            const response = await request(app)                .post(&#x27;/auth/login&#x27;)                .send(&#123;                    username: &#x27;test_user&#x27;,                    password: &#x27;wrongpassword&#x27;                &#125;)                .expect(401);            expect(response.body.success).toBe(false);            expect(response.body.code).toBe(&#x27;INVALID_CREDENTIALS&#x27;);        &#125;);    &#125;);&#125;);\n\n9.2 🔍 调试工具// Token 调试工具const jwt = require(&#x27;jsonwebtoken&#x27;);function debugToken(token) &#123;    try &#123;        const decoded = jwt.decode(token, &#123; complete: true &#125;);        console.log(&#x27;Token Debug Info:&#x27;);        console.log(&#x27;Header:&#x27;, decoded.header);        console.log(&#x27;Payload:&#x27;, decoded.payload);        console.log(&#x27;Signature:&#x27;, decoded.signature);        // 验证 token        const verified = jwt.verify(token, process.env.JWT_SECRET);        console.log(&#x27;Verification:&#x27;, &#x27;✅ Valid&#x27;);        console.log(&#x27;Expiration:&#x27;, new Date(verified.exp * 1000));    &#125; catch (error) &#123;        console.log(&#x27;Verification:&#x27;, &#x27;❌ Invalid&#x27;);        console.log(&#x27;Error:&#x27;, error.message);    &#125;&#125;// 使用方式debugToken(&#x27;your.jwt.token.here&#x27;);\n\n\n📊 总结✅ 认证系统特性\n✅ 安全的密码存储 (bcrypt)\n✅ JWT Token 认证\n✅ 请求频率限制\n✅ 输入验证和清理\n✅ CORS 跨域保护\n✅ 错误处理和安全日志\n✅ 双因素认证支持\n✅ 审计日志记录\n\n🎯 安全最佳实践\n使用 HTTPS - 所有认证请求必须通过 HTTPS\n密码策略 - 强制使用复杂密码\nToken 管理 - 合理设置过期时间\n监控日志 - 记录所有安全相关事件\n定期更新 - 保持依赖库最新版本\n\n📚 扩展建议\n实现密码重置功能\n添加账户邮箱验证\n实现社交登录集成\n添加设备管理功能\n实现细粒度权限控制\n\n\n\n💡 提示: 在生产环境中，请确保：\n\n使用强密钥和定期轮换\n启用详细的日志记录\n实施监控和告警机制\n定期进行安全审计\n\n\n","categories":["Web架构安全"],"tags":["技术文档","指南"]},{"title":"Qt libcurl 集成指南","url":"/posts/31cbd6c5/","content":"Qt libcurl 集成指南目录\n概述\n方法一：使用vcpkg (强烈推荐)\n方法二：手动从源码编译 (高级)\n在Qt项目中使用libcurl\n常见问题\n\n概述本指南详细介绍如何在现代 Windows 开发环境 (Visual Studio 2022) 中，为 Qt 项目集成 libcurl 库。首选方法是使用 vcpkg 包管理器，因为它极大地简化了流程。\n为什么使用 libcurl?\n功能强大: 支持 HTTP&#x2F;2, HTTPS, FTP(S), a多种认证机制等。\n稳定可靠: 经过长期和广泛使用的考验。\n补充 Qt Network: 在处理复杂的 HTTP 头部、代理或特定认证时，比 QNetworkAccessManager 更灵活。\n\n方法一：使用vcpkg (强烈推荐)vcpkg 是微软官方的 C++ 库管理器，它可以自动处理库的下载、编译和集成。\n1. 安装 vcpkg如果尚未安装 vcpkg，请在命令行中执行以下步骤：\n# Qt libcurl 集成指南git clone https://github.com/microsoft/vcpkg.gitcd vcpkg# Qt libcurl 集成指南.\\bootstrap-vcpkg.bat# Qt libcurl 集成指南.\\vcpkg integrate install\n\n2. 使用 vcpkg 安装 libcurlvcpkg 可以轻松地安装 libcurl 及其所有依赖（如 OpenSSL, zlib）。\n# Qt libcurl 集成指南# Qt libcurl 集成指南.\\vcpkg.exe install curl:x64-windows-static\n安装完成后，vcpkg 会提示你如何与 CMake 或 MSBuild 项目集成。\n3. 在 Qt 项目中集成 (CMake)当使用 CMake 构建 Qt 项目时，集成 vcpkg 非常简单。\nCMakeLists.txt:\ncmake_minimum_required(VERSION 3.18)project(MyQtCurlApp)# Qt libcurl 集成指南set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)# Qt libcurl 集成指南find_package(Qt6 REQUIRED COMPONENTS Core Gui Widgets)# Qt libcurl 集成指南find_package(CURL REQUIRED)# Qt libcurl 集成指南add_executable(my_app main.cpp HttpClient.cpp)# Qt libcurl 集成指南target_link_libraries(my_app PRIVATE    Qt6::Core    Qt6::Gui    Qt6::Widgets    CURL::libcurl # vcpkg 提供的 CMake target)\n\n配置项目:在首次运行 CMake 时，通过 CMAKE_TOOLCHAIN_FILE 参数指向 vcpkg 的脚本。\n# Qt libcurl 集成指南cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=C:/dev/vcpkg/scripts/buildsystems/vcpkg.cmake\n之后，CMake 就能自动找到 libcurl 的所有头文件和库。\n方法二：手动从源码编译 (高级)仅当你需要一个 vcpkg 无法提供的、高度定制化的 libcurl 版本时，才推荐此方法。\n1. 环境准备\nVisual Studio 2022: 确保已安装 “使用 C++ 的桌面开发” 工作负载。\nPerl: 用于运行部分构建脚本。推荐 Strawberry Perl。\n启动开发者命令提示符: 从开始菜单启动 x64 Native Tools Command Prompt for VS 2022。\n\n2. 获取源码和依赖\nlibcurl: 从 curl 官网 下载最新源码。\nOpenSSL: 从 slproweb.com 下载预编译的 OpenSSL，或使用 vcpkg 单独安装 openssl。\n\n3. 编译libcurl 的 Windows 版本源码中包含一个 winbuild 目录，使用 nmake 进行编译。\n# Qt libcurl 集成指南cd curl-8.4.0\\winbuild# Qt libcurl 集成指南# Qt libcurl 集成指南# Qt libcurl 集成指南# Qt libcurl 集成指南# Qt libcurl 集成指南nmake /f Makefile.vc mode=static MACHINE=x64 ENABLE_SSL=yes WITH_SSL=C:\\vcpkg\\installed\\x64-windows-static\n\n在Qt项目中使用libcurl1. 封装 HttpClient (推荐)直接使用 C-API 风格的 libcurl 比较繁琐。建议将其封装在一个 C++ 类中。\n重要提示: curl_global_init() 和 curl_global_cleanup() 必须在程序生命周期中只调用一次，而不是在每个对象的构造&#x2F;析构函数中调用。最佳实践是在 main 函数的开头和结尾调用。\nmain.cpp:\n#include &lt;QApplication&gt;#include &lt;curl/curl.h&gt;#include &quot;mainwindow.h&quot; // 你的主窗口int main(int argc, char *argv[]) &#123;    // 在程序启动时初始化 libcurl    curl_global_init(CURL_GLOBAL_ALL);    QApplication a(argc, argv);    MainWindow w;    w.show();    int result = a.exec();    // 在程序退出时清理 libcurl    curl_global_cleanup();    return result;&#125;\n\nhttp_client.h:\n#ifndef HTTPCLIENT_H#define HTTPCLIENT_H#include &lt;string&gt;#include &lt;curl/curl.h&gt;class HttpClient &#123;public:    HttpClient();    ~HttpClient();    std::string get(const std::string&amp; url);private:    CURL* curl_handle;    static size_t write_callback(void* contents, size_t size, size_t nmemb, void* userp);&#125;;#endif // HTTPCLIENT_H\n\nhttp_client.cpp:\n#include &quot;http_client.h&quot;HttpClient::HttpClient() &#123;    // 只在构造函数中初始化 handle    curl_handle = curl_easy_init();&#125;HttpClient::~HttpClient() &#123;    // 只在析构函数中清理 handle    if (curl_handle) &#123;        curl_easy_cleanup(curl_handle);    &#125;&#125;size_t HttpClient::write_callback(void* contents, size_t size, size_t nmemb, void* userp) &#123;    ((std::string*)userp)-&gt;append((char*)contents, size * nmemb);    return size * nmemb;&#125;std::string HttpClient::get(const std::string&amp; url) &#123;    if (!curl_handle) &#123;        return &quot;Error: curl handle not initialized.&quot;;    &#125;    std::string read_buffer;    curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, write_callback);    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, &amp;read_buffer);    // 更多选项...    // curl_easy_setopt(curl_handle, CURLOPT_CAINFO, &quot;cacert.pem&quot;); // 设置CA证书    CURLcode res = curl_easy_perform(curl_handle);    if (res != CURLE_OK) &#123;        return &quot;curl_easy_perform() failed: &quot; + std::string(curl_easy_strerror(res));    &#125;    return read_buffer;&#125;\n\n2. Qt .pro 文件配置 (qmake)如果你不使用 CMake，可以在 .pro 文件中这样配置：\n# Qt libcurl 集成指南# Qt libcurl 集成指南# Qt libcurl 集成指南DEFINES += CURL_STATICLIB# Qt libcurl 集成指南INCLUDEPATH += C:/dev/vcpkg/installed/x64-windows-static/include# Qt libcurl 集成指南LIBS += -LC:/dev/vcpkg/installed/x64-windows-static/libLIBS += -lcurl -lcrypt32 -lws2_32 -lwldap32# Qt libcurl 集成指南CONFIG(debug, debug|release) &#123;    LIBS += -lcurld&#125; else &#123;    LIBS += -lcurl&#125;\n\n常见问题Q1: 使用 vcpkg 后，CMake find_package(CURL) 失败?A: 你在运行 CMake 时没有指定 CMAKE_TOOLCHAIN_FILE。确保你的 CMake 配置命令包含了 -DCMAKE_TOOLCHAIN_FILE=&lt;path-to-vcpkg&gt;/scripts/buildsystems/vcpkg.cmake。\nQ2: 链接时出现 unresolved external symbol 错误?A:\n\nCURL_STATICLIB 未定义: 如果你链接的是静态库，必须在项目中定义 CURL_STATICLIB 预处理器宏。\n缺少系统库: libcurl 依赖一些 Windows 系统库。确保你链接了 ws2_32.lib, crypt32.lib, wldap32.lib。\n运行时库不匹配: 确保你的项目和 libcurl 使用了相同的运行时库设置（例如，都是 /MD 或 /MT）。vcpkg 默认使用动态运行时 (/MD)。\n\nQ3: 运行时出现 SSL&#x2F;TLS 错误，例如 SSL certificate problem?A: libcurl 需要 CA 证书来验证 HTTPS 服务器的身份。\n\nvcpkg: vcpkg 安装的 curl 通常会自动处理这个问题，因为它依赖的 openssl 会设置一个默认的证书路径。\n手动处理: 你可以从 curl 官网 下载 cacert.pem 文件，并通过 curl_easy_setopt(curl, CURLOPT_CAINFO, &quot;path/to/cacert.pem&quot;); 来指定它的路径。\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","CMake","Qt","Windows","libcurl","vcpkg","Visual Studio","网络库"]},{"title":"Qt QPainter 绘图指南","url":"/posts/38ea5a46/","content":"Qt QPainter 绘图指南目录\n概述\nQPainter 核心概念\n示例1：绘制基础图形\n示例2：绘制高级路径与形状\n示例3：渲染文本\n示例4：绘制与变换图像\n示例5：应用渐变和特效\n示例6：自定义控件 (圆形进度条)\n性能优化\n常见问题\n\n概述本指南详细介绍如何使用 Qt 的 QPainter 类实现各种 2D 绘图功能。与原文将所有功能塞入一个类不同，本指南将功能拆分为多个独立的示例控件，以展示更清晰的编程实践。\nQPainter 核心概念\nPaint Engine: QPainter 是一个高级 API，它可以在不同的“绘图引擎”上进行绘制，例如在 QWidget、QPixmap 或 QImage 上。\nPaint Event: 在自定义 QWidget 中，所有的绘制代码都应在 paintEvent() 这个虚函数中完成。\nState Machine: QPainter 是一个状态机。你设置的 QPen（画笔）、QBrush（画刷）、QFont（字体）等会一直保持，直到你再次修改它们。可以使用 painter.save() 和 painter.restore() 来保存和恢复状态。\nRender Hints: 通过 painter.setRenderHint() 可以开启抗锯齿等功能，提升绘图质量。\n\n示例1：绘制基础图形这个控件演示如何绘制直线、矩形、圆形等基本形状。\nbasic_shapes_widget.h:\n#ifndef BASICSHAPESWIDGET_H#define BASICSHAPESWIDGET_H#include &lt;QWidget&gt;class BasicShapesWidget : public QWidget &#123;    Q_OBJECTpublic:    explicit BasicShapesWidget(QWidget *parent = nullptr);protected:    void paintEvent(QPaintEvent *event) override;&#125;;#endif // BASICSHAPESWIDGET_H\n\nbasic_shapes_widget.cpp:\n#include &quot;basic_shapes_widget.h&quot;#include &lt;QPainter&gt;#include &lt;QPaintEvent&gt;BasicShapesWidget::BasicShapesWidget(QWidget *parent) : QWidget(parent) &#123;    setMinimumSize(400, 250);    setWindowTitle(&quot;Basic Shapes&quot;);&#125;void BasicShapesWidget::paintEvent(QPaintEvent *event) &#123;    Q_UNUSED(event);    QPainter painter(this);    painter.setRenderHint(QPainter::Antialiasing, true);    // 1. 设置画笔 (用于轮廓)    QPen pen(Qt::blue, 2, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);    painter.setPen(pen);    // 2. 设置画刷 (用于填充)    QBrush brush(QColor(150, 200, 255, 128)); // 半透明蓝色    painter.setBrush(brush);    // 3. 绘制图形    painter.drawRect(10, 10, 100, 80); // 矩形    painter.drawEllipse(130, 10, 100, 80); // 椭圆    painter.drawRoundedRect(10, 110, 100, 80, 15, 15); // 圆角矩形    painter.drawEllipse(QPoint(180, 150), 50, 50); // 圆形    // 4. 只用画笔，不用画刷    painter.setBrush(Qt::NoBrush);    painter.setPen(Qt::red);    painter.drawLine(250, 10, 350, 110);&#125;\n\n示例2：绘制高级路径与形状QPainterPath 允许你组合多个图元，创建复杂的形状，例如贝塞尔曲线、多边形等。\nadvanced_shapes_widget.h:\n#ifndef ADVANCEDSHAPESWIDGET_H#define ADVANCEDSHAPESWIDGET_H#include &lt;QWidget&gt;class AdvancedShapesWidget : public QWidget &#123;    Q_OBJECTpublic:    explicit AdvancedShapesWidget(QWidget *parent = nullptr);protected:    void paintEvent(QPaintEvent *event) override;&#125;;#endif // ADVANCEDSHAPESWIDGET_H\n\nadvanced_shapes_widget.cpp:\n#include &quot;advanced_shapes_widget.h&quot;#include &lt;QPainter&gt;#include &lt;QPainterPath&gt;#include &lt;cmath&gt; // For M_PIAdvancedShapesWidget::AdvancedShapesWidget(QWidget *parent) : QWidget(parent) &#123;    setMinimumSize(400, 300);    setWindowTitle(&quot;Advanced Shapes&quot;);&#125;void AdvancedShapesWidget::paintEvent(QPaintEvent *event) &#123;    QPainter painter(this);    painter.setRenderHint(QPainter::Antialiasing, true);    painter.setPen(QPen(Qt::darkGreen, 2));    // 1. 绘制多边形    QPolygonF polygon;    polygon &lt;&lt; QPointF(10, 10) &lt;&lt; QPointF(10, 90) &lt;&lt; QPointF(110, 70) &lt;&lt; QPointF(90, 20);    painter.drawPolygon(polygon);    // 2. 绘制贝塞尔曲线    QPainterPath bezierPath;    bezierPath.moveTo(150, 50);    bezierPath.cubicTo(200, 10, 250, 100, 300, 60);    painter.drawPath(bezierPath);    // 3. 绘制一个复杂的路径（例如心形）    QPainterPath heartPath;    heartPath.moveTo(200, 150);    heartPath.cubicTo(250, 120, 280, 180, 200, 250);    heartPath.cubicTo(120, 180, 150, 120, 200, 150);    painter.setBrush(Qt::red);    painter.drawPath(heartPath);&#125;\n\n示例3：渲染文本QPainter 提供了强大的文本渲染功能。\ntext_rendering_widget.h &#x2F; .cpp (结构同上):\n// In paintEvent of TextRenderingWidgetvoid TextRenderingWidget::paintEvent(QPaintEvent *event) &#123;    QPainter painter(this);    painter.setRenderHint(QPainter::TextAntialiasing, true);    // 1. 基础文本    painter.setFont(QFont(&quot;Arial&quot;, 12));    painter.setPen(Qt::black);    painter.drawText(10, 20, &quot;Hello, QPainter!&quot;);    // 2. 带样式的文本    painter.setFont(QFont(&quot;Times New Roman&quot;, 20, QFont::Bold, true));    painter.setPen(Qt::darkBlue);    painter.drawText(10, 60, &quot;Styled Text&quot;);    // 3. 旋转文本    painter.save(); // 保存当前状态    painter.translate(100, 150);    painter.rotate(-45);    painter.drawText(0, 0, &quot;Rotated Text&quot;);    painter.restore(); // 恢复之前状态    // 4. 在矩形内换行    QRectF textRect(200, 10, 180, 100);    painter.drawRect(textRect); // 画出边界方便观察    QString longText = &quot;This is a long text that will wrap inside the specified rectangle.&quot;;    painter.drawText(textRect, Qt::TextWordWrap, longText);&#125;\n\n示例4：绘制与变换图像QPainter 可以绘制 QPixmap 和 QImage，并对其进行实时变换。\nimage_drawing_widget.h &#x2F; .cpp (结构同上):\n// In paintEvent of ImageDrawingWidgetvoid ImageDrawingWidget::paintEvent(QPaintEvent *event) &#123;    QPainter painter(this);    painter.setRenderHint(QPainter::SmoothPixmapTransform, true);    // 准备一张测试图片 (也可以从文件加载: QPixmap(&quot;:/images/logo.png&quot;))    QPixmap pixmap(100, 100);    pixmap.fill(Qt::cyan);    QPainter p(&amp;pixmap);    p.drawText(pixmap.rect(), Qt::AlignCenter, &quot;Qt&quot;);    p.end();    // 1. 正常绘制    painter.drawPixmap(10, 10, pixmap);    // 2. 缩放绘制    painter.drawPixmap(120, 10, 150, 150, pixmap);    // 3. 旋转绘制    painter.save();    painter.translate(100, 200); // 移动坐标系    painter.rotate(45); // 旋转    painter.drawPixmap(-50, -50, 100, 100, pixmap); // 在新坐标系原点绘制    painter.restore();    // 4. 透明度绘制    painter.setOpacity(0.5);    painter.drawPixmap(200, 180, pixmap);    painter.setOpacity(1.0); // 恢复不透明&#125;\n\n示例5：应用渐变和特效使用 QGradient 系列类可以创建漂亮的渐变效果。\ngradients_widget.h &#x2F; .cpp (结构同上):\n// In paintEvent of GradientsWidgetvoid GradientsWidget::paintEvent(QPaintEvent *event) &#123;    QPainter painter(this);    painter.setRenderHint(QPainter::Antialiasing, true);    painter.setPen(Qt::NoPen);    // 1. 线性渐变    QLinearGradient linearGrad(0, 0, 100, 100);    linearGrad.setColorAt(0, Qt::red);    linearGrad.setColorAt(1, Qt::yellow);    painter.setBrush(linearGrad);    painter.drawRect(10, 10, 100, 100);    // 2. 径向渐变    QRadialGradient radialGrad(180, 60, 50);    radialGrad.setColorAt(0, Qt::white);    radialGrad.setColorAt(1, Qt::blue);    painter.setBrush(radialGrad);    painter.drawEllipse(130, 10, 100, 100);    // 3. 锥形渐变    QConicalGradient conicalGrad(60, 170, 0);    conicalGrad.setColorAt(0, Qt::cyan);    conicalGrad.setColorAt(0.5, Qt::magenta);    conicalGrad.setColorAt(1, Qt::cyan);    painter.setBrush(conicalGrad);    painter.drawEllipse(10, 120, 100, 100);&#125;\n\n示例6：自定义控件 (圆形进度条)这是将 QPainter 用于实践的最好例子：创建一个标准库中没有的、完全自定义的控件。\ncircular_progress_bar.h:\n#ifndef CIRCULARPROGRESSBAR_H#define CIRCULARPROGRESSBAR_H#include &lt;QWidget&gt;#include &lt;QColor&gt;class CircularProgressBar : public QWidget &#123;    Q_OBJECT    Q_PROPERTY(int value READ value WRITE setValue)public:    explicit CircularProgressBar(QWidget *parent = nullptr);    int value() const &#123; return m_value; &#125;public slots:    void setValue(int value);protected:    void paintEvent(QPaintEvent *event) override;private:    int m_value = 0;    QColor m_backgroundColor = QColor(220, 220, 220);    QColor m_progressColor = QColor(30, 144, 255);&#125;;#endif // CIRCULARPROGRESSBAR_H\n\ncircular_progress_bar.cpp:\n#include &quot;circular_progress_bar.h&quot;#include &lt;QPainter&gt;CircularProgressBar::CircularProgressBar(QWidget *parent) : QWidget(parent) &#123;    setMinimumSize(100, 100);&#125;void CircularProgressBar::setValue(int value) &#123;    if (m_value != value) &#123;        m_value = qBound(0, value, 100);        update(); // 请求重绘    &#125;&#125;void CircularProgressBar::paintEvent(QPaintEvent *event) &#123;    QPainter painter(this);    painter.setRenderHint(QPainter::Antialiasing, true);    QRectF rect = this-&gt;rect().adjusted(5, 5, -5, -5);    int startAngle = 90 * 16; // 12点钟方向    int spanAngle = -static_cast&lt;int&gt;((m_value / 100.0) * 360.0 * 16.0);    // 绘制背景环    painter.setPen(QPen(m_backgroundColor, 8, Qt::SolidLine, Qt::FlatCap));    painter.drawArc(rect, 0, 360 * 16);    // 绘制进度环    painter.setPen(QPen(m_progressColor, 8, Qt::SolidLine, Qt::RoundCap));    painter.drawArc(rect, startAngle, spanAngle);    // 绘制中心文本    painter.setPen(m_progressColor);    painter.setFont(QFont(&quot;Arial&quot;, 16, QFont::Bold));    painter.drawText(rect, Qt::AlignCenter, QString::number(m_value) + &quot;%&quot;);&#125;\n\n性能优化\n双缓冲: QWidget 默认开启双缓冲，一般无需手动处理。对于非 QWidget 的绘图表面（如 QPixmap），双缓冲是隐式的。\n减少重绘区域: 在 paintEvent 中，只重绘 event-&gt;rect() 或 event-&gt;region() 提供的“脏区域”，而不是整个控件。\n缓存: 对于复杂且不常变化的背景或元素，可以将其预先绘制到一个 QPixmap 缓存上，在 paintEvent 中直接绘制该 QPixmap 即可。\n避免在 paintEvent 中进行耗时操作: 不要在 paintEvent 中创建复杂的对象或执行计算。所有数据都应提前准备好。\n\n常见问题Q1: 绘图有锯齿，不平滑?A: 开启抗锯齿。painter.setRenderHint(QPainter::Antialiasing, true);\nQ2: 控件缩放时，内容会闪烁?A: QWidget 默认的双缓冲能处理大部分情况。如果问题依然存在，确保没有在 resizeEvent 中调用 update()，而应让系统自动触发 paintEvent。\nQ3: 如何在高DPI屏幕上保证清晰度?A: 在 main.cpp 中启用高DPI支持：\nQApplication::setAttribute(Qt::AA_EnableHighDpiScaling);QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);\nQt 会自动处理大部分DPI缩放。对于手动加载的 QPixmap，可能需要使用 @2x 后缀的资源或手动设置其 devicePixelRatio。\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","QPainter","绘图","自定义控件","2D图形"]},{"title":"Qt 媒体播放器指南","url":"/posts/2d1c3806/","content":"Qt 媒体播放器指南目录\n概述\n第一步：项目设置与UI设计\n第二步：实现基础播放功能\n第三步：添加播放列表\n第四步：高级功能展望 (文字说明)\n完整代码参考\n常见问题\n\n概述本教程将循序渐进地指导你如何使用 Qt 的 QMediaPlayer 和 QMediaPlaylist 类来构建一个功能性的桌面音乐播放器。我们将从一个能播放单个文件的最简播放器开始，逐步为其添加播放列表等功能。\n核心组件\nQMediaPlayer: 用于控制媒体（音频&#x2F;视频）播放的核心类，提供播放、暂停、停止、设置音量、跳转进度等功能。\nQMediaPlaylist: 用于管理一个媒体项目列表，支持顺序播放、循环、随机等模式。\n\n第一步：项目设置与UI设计1. 项目配置 (.pro 文件)创建一个新的 Qt Widgets Application 项目，并确保 .pro 文件中包含了 multimedia 模块。\nQT += core gui multimediaGREATER_THAN_QT_5 &#123;    QT += widgets&#125;TARGET = MusicPlayerTEMPLATE = appSOURCES += main.cpp mainwindow.cppHEADERS += mainwindow.hFORMS   += mainwindow.ui\n\n2. UI 设计 (mainwindow.ui)在 Qt Designer 中，设计一个简单的主窗口界面，包含以下控件：\n\nQPushButton (openButton): 用于打开文件。\nQPushButton (playPauseButton): 用于播放&#x2F;暂停。\nQPushButton (stopButton): 用于停止。\nQSlider (positionSlider): 水平滑块，用于显示和控制播放进度。\nQLabel (timeLabel): 用于显示 当前时间 / 总时间。\nQListView (playlistView): 用于显示播放列表。\n\n第二步：实现基础播放功能我们先实现一个能打开并播放单个音频文件的播放器。\n1. 添加成员变量在 mainwindow.h 中，添加 QMediaPlayer 的指针。\n// mainwindow.h#include &lt;QMediaPlayer&gt;class MainWindow : public QMainWindow &#123;    // ...private:    Ui::MainWindow *ui;    QMediaPlayer *m_player;&#125;;\n\n2. 初始化播放器在 mainwindow.cpp 的构造函数中，初始化播放器并连接必要的信号和槽。\n// mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent), ui(new Ui::MainWindow) &#123;    ui-&gt;setupUi(this);    // 1. 创建播放器实例    m_player = new QMediaPlayer(this);    // 2. 信号槽连接    connect(ui-&gt;openButton, &amp;QPushButton::clicked, this, &amp;MainWindow::openFile);    connect(ui-&gt;playPauseButton, &amp;QPushButton::clicked, this, &amp;MainWindow::togglePlayback);    connect(ui-&gt;stopButton, &amp;QPushButton::clicked, m_player, &amp;QMediaPlayer::stop);    // 当播放进度变化时，更新滑块    connect(m_player, &amp;QMediaPlayer::positionChanged, this, &amp;MainWindow::updatePosition);    // 当媒体总时长变化时，设置滑块范围    connect(m_player, &amp;QMediaPlayer::durationChanged, this, &amp;MainWindow::updateDuration);    // 当播放状态变化时，更新按钮文本    connect(m_player, &amp;QMediaPlayer::stateChanged, this, &amp;MainWindow::updateState);    // 拖动滑块以改变播放进度    connect(ui-&gt;positionSlider, &amp;QSlider::sliderMoved, m_player, &amp;QMediaPlayer::setPosition);&#125;\n\n3. 实现槽函数// mainwindow.cppvoid MainWindow::openFile() &#123;    QString filePath = QFileDialog::getOpenFileName(this, &quot;打开音频文件&quot;, &quot;&quot;, &quot;音频文件 (*.mp3 *.wav *.flac)&quot;);    if (!filePath.isEmpty()) &#123;        m_player-&gt;setMedia(QUrl::fromLocalFile(filePath));        m_player-&gt;play();    &#125;&#125;void MainWindow::togglePlayback() &#123;    if (m_player-&gt;state() == QMediaPlayer::PlayingState) &#123;        m_player-&gt;pause();    &#125; else &#123;        m_player-&gt;play();    &#125;&#125;void MainWindow::updatePosition(qint64 position) &#123;    ui-&gt;positionSlider-&gt;setValue(position);    // 更新时间标签    qint64 duration = m_player-&gt;duration();    QString timeStr = QString(&quot;%1:%2 / %3:%4&quot;)                        .arg(position / 60000, 2, 10, QChar(&#x27;0&#x27;))                        .arg((position / 1000) % 60, 2, 10, QChar(&#x27;0&#x27;))                        .arg(duration / 60000, 2, 10, QChar(&#x27;0&#x27;))                        .arg((duration / 1000) % 60, 2, 10, QChar(&#x27;0&#x27;));    ui-&gt;timeLabel-&gt;setText(timeStr);&#125;void MainWindow::updateDuration(qint64 duration) &#123;    ui-&gt;positionSlider-&gt;setRange(0, duration);&#125;void MainWindow::updateState(QMediaPlayer::State state) &#123;    if (state == QMediaPlayer::PlayingState) &#123;        ui-&gt;playPauseButton-&gt;setText(&quot;暂停&quot;);    &#125; else &#123;        ui-&gt;playPauseButton-&gt;setText(&quot;播放&quot;);    &#125;&#125;\n至此，一个可以播放单个文件的基础播放器就完成了！\n第三步：添加播放列表现在，我们引入 QMediaPlaylist 来管理多个文件。\n1. 添加成员变量在 mainwindow.h 中，添加 QMediaPlaylist 的指针和一个用于显示列表的模型。\n// mainwindow.h#include &lt;QMediaPlaylist&gt;#include &lt;QStringListModel&gt;class MainWindow : public QMainWindow &#123;    // ...private:    // ...    QMediaPlaylist *m_playlist;    QStringListModel *m_playlistModel;    QStringList m_filePaths; // 保存文件路径&#125;;\n\n2. 修改构造函数// mainwindow.cppMainWindow::MainWindow(QWidget *parent) /* ... */ &#123;    // ... (之前的代码)    // 1. 创建播放列表实例    m_playlist = new QMediaPlaylist(this);    m_player-&gt;setPlaylist(m_playlist);    // 2. 设置模型和视图    m_playlistModel = new QStringListModel(this);    ui-&gt;playlistView-&gt;setModel(m_playlistModel);    // 3. 连接播放列表相关的信号槽    connect(ui-&gt;playlistView, &amp;QListView::doubleClicked, this, &amp;MainWindow::playFromPlaylist);&#125;\n\n3. 修改文件打开逻辑让“打开”按钮支持选择多个文件，并将其添加到播放列表。\n// mainwindow.cppvoid MainWindow::openFile() &#123;    QStringList filePaths = QFileDialog::getOpenFileNames(this, &quot;打开音频文件&quot;, &quot;&quot;, &quot;音频文件 (*.mp3 *.wav *.flac)&quot;);    if (!filePaths.isEmpty()) &#123;        m_filePaths = filePaths;        m_playlist-&gt;clear();        for (const QString &amp;filePath : filePaths) &#123;            m_playlist-&gt;addMedia(QUrl::fromLocalFile(filePath));        &#125;                // 更新 UI 上的列表        QStringList fileNames;        for (const QString &amp;filePath : filePaths) &#123;            fileNames.append(QFileInfo(filePath).fileName());        &#125;        m_playlistModel-&gt;setStringList(fileNames);        m_playlist-&gt;setCurrentIndex(0);        m_player-&gt;play();    &#125;&#125;void MainWindow::playFromPlaylist(const QModelIndex &amp;index) &#123;    m_playlist-&gt;setCurrentIndex(index.row());    m_player-&gt;play();&#125;\n现在，你的播放器已经支持播放列表了！你可以添加“上一首”和“下一首”按钮，并分别连接到 m_playlist-&gt;previous() 和 m_playlist-&gt;next()。\n第四步：高级功能展望 (文字说明)\n音量控制: 添加一个 QSlider，将其 valueChanged(int) 信号连接到 m_player 的 setVolume(int) 槽。\n播放模式: 使用 m_playlist-&gt;setPlaybackMode() 可以设置不同的播放模式，如 QMediaPlaylist::Loop (列表循环), QMediaPlaylist::CurrentItemInLoop (单曲循环), QMediaPlaylist::Random (随机播放)。\n保存&#x2F;加载播放列表: QMediaPlaylist 支持 .m3u 格式。使用 m_playlist-&gt;save(QUrl::fromLocalFile(path), &quot;m3u&quot;) 保存，使用 m_playlist-&gt;load(QUrl::fromLocalFile(path)) 加载。\n音频可视化: 要实现频谱效果，你需要使用 QAudioProbe 附加到 QMediaPlayer 上，它会发出 audioBufferProbed(QAudioBuffer) 信号。你需要对这个 buffer 中的原始音频数据进行 FFT (快速傅里叶变换) 计算，然后使用 QPainter 在一个自定义控件上将频谱绘制出来。这是一个高级的数字信号处理话题。\n均衡器: Qt 提供了 QAudioEqualizer 类。你可以创建一个实例，然后通过 m_player-&gt;setAudioEqualizer(myEqualizer) 将其应用到播放器上。\n\n完整代码参考(为简洁起见，此处省略了完整的 main.cpp 和 mainwindow.h 文件，上文已包含所有核心逻辑。)\n常见问题Q1: MP3 文件在 Windows 上能播放，但在 Linux 上不能?A: 这是最常见的问题，原因是缺少解码器。Qt Multimedia 依赖操作系统的后端（如 Windows 上的 DirectShow，Linux 上的 GStreamer）。请确保在 Linux 上安装了 gstreamer1.0-plugins-good, gstreamer1.0-plugins-bad, gstreamer1.0-plugins-ugly 等插件包。\nQ2: 视频可以播放，但没有声音?A: 同样是解码器问题，或者音频输出设备没有正确选择。检查系统音量和音频设备设置。\nQ3: 如何获取歌曲的元数据（歌手、专辑等）?A: QMediaPlayer 提供了 metaDataChanged() 信号和 metaData(const QString &amp;key) 方法。当媒体加载完成后，你可以通过 player-&gt;metaData(QMediaMetaData::Title) 等来获取信息。\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","QMediaPlayer","QMediaPlaylist","MP3播放器","音频"]},{"title":"Qt QSS 样式表指南","url":"/posts/35f89acf/","content":"Qt QSS 样式表指南目录\n概述\n基础语法与应用\n选择器 (Selectors)\n盒子模型 (Box Model)\n伪状态 (Pseudo-States)\n子控件 (Sub-Controls)\n常用属性参考\n高级技巧与最佳实践\n\n概述Qt 样式表 (Qt Style Sheets, QSS) 是一种强大的机制，允许开发者使用类似 CSS 的语法来定制 Qt 控件的外观。通过 QSS，可以轻松实现界面美化、主题切换和品牌定制，而无需修改 C++ 代码。\n基础语法与应用1. 语法结构QSS 的基本语法与 CSS 非常相似：selector { property: value; }\n/* 这是一个注释 *//* 类型选择器: 应用于所有 QPushButton 实例 */QPushButton &#123;    color: white;    background-color: #5cb85c;    border-radius: 4px;    padding: 8px 16px;&#125;/* 对象名称选择器 (ID选择器): 只应用于 objectName 为 &#x27;loginButton&#x27; 的控件 */QPushButton#loginButton &#123;    font-weight: bold;&#125;\n\n2. 在代码中应用样式应用于单个控件#include &lt;QPushButton&gt;// ...auto myButton = new QPushButton(&quot;Click Me&quot;);myButton-&gt;setStyleSheet(&quot;background-color: #f0ad4e; color: white;&quot;);\n\n应用于整个应用程序这是最常见的方式，用于设置全局主题。\n#include &lt;QApplication&gt;int main(int argc, char *argv[]) &#123;    QApplication a(argc, argv);    a.setStyleSheet(&quot;QPushButton &#123; background-color: #5bc0de; &#125;&quot;);    // ...    return a.exec();&#125;\n\n从文件加载样式 (推荐)将 QSS 放在单独的 .qss 文件中是最佳实践。\nstyles/dark_theme.qss:\nQWidget &#123;    background-color: #2d2d2d;    color: #f0f0f0;&#125;QPushButton &#123;    background-color: #4a4a4a;    border: 1px solid #666;&#125;\n\nmain.cpp:\n#include &lt;QApplication&gt;#include &lt;QFile&gt;void loadStyleSheet(const QString&amp; path) &#123;    QFile file(path);    if (file.open(QFile::ReadOnly | QFile::Text)) &#123;        QString style = QLatin1String(file.readAll());        qApp-&gt;setStyleSheet(style);        file.close();    &#125;&#125;int main(int argc, char *argv[]) &#123;    QApplication a(argc, argv);    loadStyleSheet(&quot;:/styles/dark_theme.qss&quot;); // 从 Qt 资源系统加载    // ...    return a.exec();&#125;\n\n选择器 (Selectors)选择器用于指定样式规则应用到哪些控件。\n\n\n\n选择器类型\n示例\n说明\n\n\n\n类型选择器\nQPushButton\n匹配所有 QPushButton 及其子类的实例。\n\n\n对象名称选择器\nQPushButton#myButton\n匹配 objectName 为 myButton 的 QPushButton。\n\n\n类选择器\n.MyCustomButton\n匹配 MyCustomButton 类的实例 (及其子类)。\n\n\n属性选择器\nQPushButton[flat=&quot;true&quot;]\n匹配 flat 属性为 true 的 QPushButton。\n\n\n后代选择器\nQDialog QPushButton\n匹配 QDialog 内的所有 QPushButton。\n\n\n子选择器\nQGroupBox &gt; QCheckBox\n只匹配作为 QGroupBox 直接子元素的 QCheckBox。\n\n\n通用选择器\n*\n匹配所有控件 (性能开销大，慎用)。\n\n\n盒子模型 (Box Model)QSS 的盒子模型与 CSS 类似，定义了控件的尺寸和间距。\n\nQPushButton &#123;    /* 边框 (border) */    border: 2px solid #1e90ff;    border-radius: 5px;    /* 内边距 (padding) */    padding: 10px;    /* 外边距 (margin) */    margin: 5px;    /* 背景从 padding 区域开始绘制 */    background-origin: padding;&#125;\n\nmargin: 边框以外的区域，是透明的。\nborder: 围绕在 padding 和内容区的边界。\npadding: border 和内容之间的空白区域。\ncontent: 控件实际内容的区域 (例如，按钮的文本和图标)。\n\n伪状态 (Pseudo-States)伪状态允许你根据控件的不同状态（如鼠标悬停、被按下）应用不同的样式。\n/* 鼠标悬停时 */QPushButton:hover &#123;    background-color: #70ad47;&#125;/* 被按下时 */QPushButton:pressed &#123;    background-color: #3c883c;&#125;/* 禁用时 */QPushButton:disabled &#123;    background-color: #d3d3d3;    color: #808080;&#125;/* 输入框获得焦点时 */QLineEdit:focus &#123;    border: 1px solid #55aaff;&#125;/* 复选框被选中时 */QCheckBox:checked &#123;    color: #55aaff;&#125;/* 多个伪状态组合 */QCheckBox:checked:hover &#123;    color: #77aaff;&#125;/* 否定伪状态 */QPushButton:!hover &#123;    /* ... */&#125;\n\n子控件 (Sub-Controls)复杂的控件由多个子部分组成，QSS 允许对这些子控件进行单独的样式设置。\n/* --- QComboBox (下拉框) --- */QComboBox &#123;    border: 1px solid #ccc;    padding-left: 10px;&#125;/* 设置下拉箭头部分 */QComboBox::drop-down &#123;    subcontrol-origin: padding;    subcontrol-position: top right;    width: 20px;    border-left: 1px solid #ccc;&#125;/* 设置下拉箭头图标 */QComboBox::down-arrow &#123;    image: url(:/icons/down_arrow.png);&#125;/* --- QSlider (滑块) --- *//* 设置滑块的凹槽 */QSlider::groove:horizontal &#123;    height: 8px;    background: #f0f0f0;    border-radius: 4px;&#125;/* 设置滑块的滑块手柄 */QSlider::handle:horizontal &#123;    background: #55aaff;    width: 16px;    margin: -4px 0; /* 垂直居中 */    border-radius: 8px;&#125;/* --- QScrollBar (滚动条) --- */QScrollBar:vertical &#123;    border: none;    background: #e0e0e0;    width: 12px;    margin: 0;&#125;QScrollBar::handle:vertical &#123;    background: #a0a0a0;    min-height: 20px;    border-radius: 6px;&#125;QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical &#123;    height: 0px;&#125;\n\n常用属性参考\n\n\n类别\n属性\n示例值\n\n\n\n背景\nbackground-color\n#ffffff, rgb(255, 255, 255), transparent\n\n\n\nbackground-image\nurl(:/images/bg.png)\n\n\n\nbackground-repeat\nrepeat-x, no-repeat\n\n\n\nbackground-position\ncenter\n\n\n颜色\ncolor\n#333333\n\n\n字体\nfont-family\n&quot;Segoe UI&quot;\n\n\n\nfont-size\n12pt, 16px\n\n\n\nfont-weight\nbold, normal\n\n\n\nfont-style\nitalic\n\n\n边框\nborder\n1px solid #cccccc\n\n\n\nborder-radius\n5px\n\n\n\nborder-color\n#ff0000\n\n\n尺寸\nwidth, height\n100px\n\n\n\nmin-width, max-height\n50px\n\n\n间距\npadding, margin\n10px, 5px 10px\n\n\n高级技巧与最佳实践\n使用动态属性: 在 QSS 中使用 qproperty-&lt;propertyname&gt; 可以设置控件的 Qt 属性。\nMyCustomButton &#123;    qproperty-iconSize: 24px; /* 设置 iconSize 属性 */    qproperty-text: &quot;Hello&quot;; /* 设置 text 属性 */&#125;\n\n主题化: 将颜色、字体等定义为常量，通过加载不同的 QSS 文件来实现主题切换。这是最简单有效的“换肤”方法。\n\n性能: \n\n**避免使用通用选择器 ***，它的性能开销最大。\n选择器越具体，性能越好。QPushButton#myButton 比 QPushButton 快。\n尽量将样式表应用在父控件上，而不是为成百上千个子控件单独设置样式，利用 QSS 的继承特性。\n\n\n动画: QSS 本身不直接支持 transition 或 animation 属性。Qt 中的动画是通过 C++ 的 QPropertyAnimation 类实现的。你可以用它来平滑地改变一个控件的几何属性（如 geometry）或样式相关的属性。\n\n布局: QSS 不负责控件的布局（位置和排列）。布局应由 C++ 中的 QLayout 类（QHBoxLayout, QVBoxLayout 等）或在 .ui 文件中完成。\n\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","QSS","样式表","UI设计","界面美化"]},{"title":"Qt 摄像头采集指南","url":"/posts/5d5b09a4/","content":"Qt 摄像头采集指南目录\n概述\n环境与项目配置\nUI 界面设计\n核心代码实现\n完整代码示例\n最佳实践与常见问题\n\n概述本指南详细介绍如何在 Qt 应用程序中，使用 QCamera 和 QVideoWidget 等核心多媒体类，实现摄像头预览和图像采集（截图）功能。本指南采用 Qt 推荐的标准实践，代码简洁且高效。\n核心组件\nQCamera: Qt 中代表物理摄像头的核心类。\nQCameraInfo: 用于查询系统上可用的摄像头及其信息。\nQVideoWidget: 用于在 UI 上显示摄像头预览画面的专用控件。\nQCameraImageCapture: 用于从摄像头捕获高质量静态图像的服务类。\n\n环境与项目配置1. .pro 文件配置确保你的 Qt 项目文件 (.pro) 中包含了 multimedia 和 multimediawidgets 模块。\n# Qt 摄像头采集指南QT += core gui multimedia multimediawidgetsTARGET = CameraAppTEMPLATE = appSOURCES += main.cpp mainwindow.cppHEADERS += mainwindow.hFORMS   += mainwindow.ui\n\n2. 系统依赖\nWindows: 通常无需额外依赖。\nLinux (Ubuntu&#x2F;Debian): 需要确保安装了 GStreamer 插件。sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good\nmacOS: 通常无需额外依赖。\n\nUI 界面设计在 Qt Designer 中，设计你的主窗口 (MainWindow.ui)，至少包含以下控件：\n\nQComboBox: 用于选择摄像头。对象名设为 cameraComboBox。\nQVideoWidget: 这是显示摄像头画面的关键。从控件列表中拖入一个 QVideoWidget。对象名设为 videoWidget。\nQPushButton: 用于触发拍照。对象名设为 captureButton。\nQLabel: 用于显示拍下的照片预览。对象名设为 capturePreviewLabel。\n\n核心代码实现我们将所有摄像头逻辑封装在 MainWindow 类中，以简化示例。\n1. 初始化摄像头在 MainWindow 的构造函数中，我们会查找可用摄像头，并设置默认摄像头。\n// mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QCameraInfo&gt;#include &lt;QMessageBox&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)    , m_camera(nullptr)    , m_imageCapture(nullptr)&#123;    ui-&gt;setupUi(this);        // 查找可用摄像头    const QList&lt;QCameraInfo&gt; availableCameras = QCameraInfo::availableCameras();    for (const QCameraInfo &amp;cameraInfo : availableCameras) &#123;        ui-&gt;cameraComboBox-&gt;addItem(cameraInfo.description());    &#125;    if (!availableCameras.isEmpty()) &#123;        // 默认选择第一个摄像头        setupCamera(availableCameras.first());    &#125; else &#123;        QMessageBox::warning(this, &quot;无摄像头&quot;, &quot;系统中未找到可用摄像头。&quot;);        ui-&gt;captureButton-&gt;setEnabled(false);    &#125;    connect(ui-&gt;captureButton, &amp;QPushButton::clicked, this, &amp;MainWindow::captureImage);    connect(ui-&gt;cameraComboBox, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this, &amp;MainWindow::changeCamera);&#125;\n\n2. 设置和启动摄像头我们创建一个 setupCamera 函数来处理摄像头的创建、配置和启动。\n// mainwindow.cppvoid MainWindow::setupCamera(const QCameraInfo &amp;cameraInfo) &#123;    // 清理旧的摄像头对象    if (m_camera) &#123;        m_camera-&gt;stop();        delete m_camera;        m_camera = nullptr;        delete m_imageCapture;        m_imageCapture = nullptr;    &#125;    // 创建新的摄像头和截图对象    m_camera = new QCamera(cameraInfo);    m_imageCapture = new QCameraImageCapture(m_camera);    // 将预览画面输出到 QVideoWidget    m_camera-&gt;setViewfinder(ui-&gt;videoWidget);    // 信号槽连接，处理截图和错误    connect(m_imageCapture, &amp;QCameraImageCapture::imageCaptured, this, &amp;MainWindow::displayCapturedImage);    connect(m_imageCapture, &amp;QCameraImageCapture::errorOccurred, this, &amp;MainWindow::handleCaptureError);    // 启动摄像头    m_camera-&gt;start();&#125;\n\n3. 实现截图功能当用户点击按钮时，调用 QCameraImageCapture 的 capture() 方法。\n// mainwindow.cppvoid MainWindow::captureImage() &#123;    if (!m_imageCapture || !m_imageCapture-&gt;isReadyForCapture()) &#123;        QMessageBox::warning(this, &quot;错误&quot;, &quot;摄像头未准备好，无法拍照。&quot;);        return;    &#125;    // 拍照，图像数据会通过 imageCaptured 信号返回    m_imageCapture-&gt;capture();&#125;void MainWindow::displayCapturedImage(int id, const QImage &amp;preview) &#123;    Q_UNUSED(id);    // 在 QLabel 上显示截图的预览    ui-&gt;capturePreviewLabel-&gt;setPixmap(QPixmap::fromImage(preview).scaled(        ui-&gt;capturePreviewLabel-&gt;size(),        Qt::KeepAspectRatio,        Qt::SmoothTransformation    ));&#125;void MainWindow::handleCaptureError(int id, QCameraImageCapture::Error error, const QString &amp;errorString) &#123;    Q_UNUSED(id);    Q_UNUSED(error);    QMessageBox::warning(this, &quot;拍照失败&quot;, errorString);&#125;\n\n完整代码示例mainwindow.h:\n#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QCamera&gt;#include &lt;QCameraImageCapture&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow &#123;    Q_OBJECTpublic:    MainWindow(QWidget *parent = nullptr);    ~MainWindow();private slots:    void captureImage();    void displayCapturedImage(int id, const QImage &amp;preview);    void handleCaptureError(int id, QCameraImageCapture::Error error, const QString &amp;errorString);    void changeCamera(int index);private:    void setupCamera(const QCameraInfo &amp;cameraInfo);    Ui::MainWindow *ui;    QCamera *m_camera;    QCameraImageCapture *m_imageCapture;&#125;;#endif // MAINWINDOW_H\n\nmainwindow.cpp (包含 changeCamera 的实现):\n#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QCameraInfo&gt;#include &lt;QMessageBox&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)    , m_camera(nullptr)    , m_imageCapture(nullptr)&#123;    ui-&gt;setupUi(this);        const QList&lt;QCameraInfo&gt; availableCameras = QCameraInfo::availableCameras();    for (const QCameraInfo &amp;cameraInfo : availableCameras) &#123;        ui-&gt;cameraComboBox-&gt;addItem(cameraInfo.description());    &#125;    if (!availableCameras.isEmpty()) &#123;        setupCamera(availableCameras.first());    &#125; else &#123;        QMessageBox::warning(this, &quot;无摄像头&quot;, &quot;系统中未找到可用摄像头。&quot;);        ui-&gt;captureButton-&gt;setEnabled(false);    &#125;    connect(ui-&gt;captureButton, &amp;QPushButton::clicked, this, &amp;MainWindow::captureImage);    connect(ui-&gt;cameraComboBox, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this, &amp;MainWindow::changeCamera);&#125;MainWindow::~MainWindow() &#123;    if (m_camera) &#123;        m_camera-&gt;stop();    &#125;    delete ui;&#125;void MainWindow::setupCamera(const QCameraInfo &amp;cameraInfo) &#123;    if (m_camera) &#123;        m_camera-&gt;stop();        delete m_camera;        m_camera = nullptr;        delete m_imageCapture;        m_imageCapture = nullptr;    &#125;    m_camera = new QCamera(cameraInfo);    m_imageCapture = new QCameraImageCapture(m_camera);    m_camera-&gt;setViewfinder(ui-&gt;videoWidget);    connect(m_imageCapture, &amp;QCameraImageCapture::imageCaptured, this, &amp;MainWindow::displayCapturedImage);    connect(m_imageCapture, QOverload&lt;int, QCameraImageCapture::Error, const QString &amp;&gt;::of(&amp;QCameraImageCapture::errorOccurred), this, &amp;MainWindow::handleCaptureError);    m_camera-&gt;start();&#125;void MainWindow::captureImage() &#123;    if (!m_imageCapture || !m_imageCapture-&gt;isReadyForCapture()) &#123;        QMessageBox::warning(this, &quot;错误&quot;, &quot;摄像头未准备好，无法拍照。&quot;);        return;    &#125;    m_imageCapture-&gt;capture();&#125;void MainWindow::displayCapturedImage(int id, const QImage &amp;preview) &#123;    Q_UNUSED(id);    ui-&gt;capturePreviewLabel-&gt;setPixmap(QPixmap::fromImage(preview).scaled(ui-&gt;capturePreviewLabel-&gt;size(), Qt::KeepAspectRatio, Qt::SmoothTransformation));&#125;void MainWindow::handleCaptureError(int id, QCameraImageCapture::Error error, const QString &amp;errorString) &#123;    Q_UNUSED(id);    Q_UNUSED(error);    QMessageBox::warning(this, &quot;拍照失败&quot;, errorString);&#125;void MainWindow::changeCamera(int index) &#123;    if (index == -1) return;    const QList&lt;QCameraInfo&gt; availableCameras = QCameraInfo::availableCameras();    if (index &lt; availableCameras.size()) &#123;        setupCamera(availableCameras[index]);    &#125;&#125;\n\n最佳实践与常见问题\n检查摄像头可用性: 在尝试使用摄像头前，务必通过 QCameraInfo::availableCameras() 检查列表是否为空。\n资源管理: QCamera 和 QCameraImageCapture 都是 QObject，将 MainWindow 设置为它们的 parent 可以利用 Qt 的父子对象树机制自动管理内存。\n错误处理: 始终连接 QCamera::errorOccurred 和 QCameraImageCapture::errorOccurred 信号，向用户提供清晰的错误反馈。\n平台差异: 摄像头后端在不同操作系统上（Windows, Linux, macOS）的实现不同。虽然 Qt 抹平了大部分差异，但在部署时仍需在目标平台上进行充分测试。\n预览卡顿: 如果预览画面卡顿，可以尝试查询并设置一个较低的预览分辨率。使用 camera-&gt;supportedViewfinderResolutions() 获取支持的分辨率列表。\n截图质量: 使用 QImageEncoderSettings 可以精细控制截图的分辨率和质量。在调用 capture() 之前，将其设置到 QCameraImageCapture 对象上。\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","QCamera","QVideoWidget","摄像头","截图","多媒体"]},{"title":"Qt 音频录制指南","url":"/posts/df73c2a8/","content":"Qt 音频录制指南目录\n概述\n第一步：项目设置与UI设计\n第二步：实现录音逻辑\n第三步：处理WAV文件头\n完整代码参考\n高级功能展望 (文字说明)\n常见问题\n\n概述本指南将以一个清晰、循序渐进的方式，介绍如何使用 Qt 的 QAudioInput 类来实现基础的音频录制功能，并将录制的原始音频数据保存为可播放的 .wav 文件。\n核心组件\nQAudioDeviceInfo: 用于查询和选择可用的音频输入设备（如麦克风）。\nQAudioFormat: 用于定义录音的参数，如采样率、声道数、采样位深等。\nQAudioInput: 核心类，用于从指定的设备以指定的格式捕获音频数据。\nQFile: 一个继承自 QIODevice 的类，我们可以直接让 QAudioInput 将音频数据写入一个 QFile 对象。\n\n第一步：项目设置与UI设计1. 项目配置 (.pro 文件)创建一个新的 Qt Widgets Application 项目，并确保 .pro 文件中包含了 multimedia 模块。\nQT += core gui multimediaGREATER_THAN_QT_5 &#123;    QT += widgets&#125;TARGET = AudioRecorderAppTEMPLATE = appSOURCES += main.cpp mainwindow.cppHEADERS += mainwindow.hFORMS   += mainwindow.ui\n\n2. UI 设计 (mainwindow.ui)在 Qt Designer 中，设计一个简单的主窗口界面，包含以下控件：\n\nQComboBox (deviceComboBox): 用于选择输入设备。\nQPushButton (recordButton): 用于开始录音。\nQPushButton (stopButton): 用于停止录音。\nQLabel (statusLabel): 用于显示当前状态（如“正在录音…”、“已停止”）。\n\n第二步：实现录音逻辑我们将所有录音逻辑都封装在 MainWindow 类中，以保持示例的简洁性。\n1. 添加成员变量在 mainwindow.h 中，添加 QAudioInput 和 QFile 的指针。\n// mainwindow.h#include &lt;QAudioInput&gt;#include &lt;QFile&gt;class MainWindow : public QMainWindow &#123;    // ...private:    Ui::MainWindow *ui;    QAudioInput *m_audioInput = nullptr;    QFile *m_outputFile = nullptr;    QAudioDeviceInfo m_selectedDevice;&#125;;\n\n2. 初始化设备列表在 mainwindow.cpp 的构造函数中，查找可用的音频输入设备并填充到 QComboBox 中。\n// mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QAudioDeviceInfo&gt;#include &lt;QMessageBox&gt;#include &lt;QFileDialog&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent), ui(new Ui::MainWindow) &#123;    ui-&gt;setupUi(this);    ui-&gt;stopButton-&gt;setEnabled(false);    // 1. 填充设备列表    const auto devices = QAudioDeviceInfo::availableDevices(QAudio::AudioInput);    for (const QAudioDeviceInfo &amp;deviceInfo : devices) &#123;        ui-&gt;deviceComboBox-&gt;addItem(deviceInfo.deviceName(), QVariant::fromValue(deviceInfo));    &#125;    // 2. 连接信号槽    connect(ui-&gt;recordButton, &amp;QPushButton::clicked, this, &amp;MainWindow::startRecording);    connect(ui-&gt;stopButton, &amp;QPushButton::clicked, this, &amp;MainWindow::stopRecording);&#125;\n\n3. 开始与停止录音// mainwindow.cppvoid MainWindow::startRecording() &#123;    // 1. 获取选中的设备    int selectedIndex = ui-&gt;deviceComboBox-&gt;currentIndex();    if (selectedIndex &lt; 0) &#123;        QMessageBox::warning(this, &quot;错误&quot;, &quot;没有选择有效的音频输入设备。&quot;);        return;    &#125;    m_selectedDevice = ui-&gt;deviceComboBox-&gt;itemData(selectedIndex).value&lt;QAudioDeviceInfo&gt;();    // 2. 设置音频格式 (例如: 44.1kHz, 16-bit, 立体声)    QAudioFormat format;    format.setSampleRate(44100);    format.setChannelCount(2);    format.setSampleSize(16);    format.setSampleType(QAudioFormat::SignedInt);    format.setByteOrder(QAudioFormat::LittleEndian);    format.setCodec(&quot;audio/pcm&quot;);    // 3. 检查设备是否支持此格式    if (!m_selectedDevice.isFormatSupported(format)) &#123;        QMessageBox::warning(this, &quot;错误&quot;, &quot;所选设备不支持当前音频格式。&quot;);        return;    &#125;    // 4. 设置输出文件    QString savePath = QFileDialog::getSaveFileName(this, &quot;保存录音&quot;, &quot;&quot;, &quot;WAV 文件 (*.wav)&quot;);    if (savePath.isEmpty()) return;    m_outputFile = new QFile(savePath, this);    if (!m_outputFile-&gt;open(QIODevice::WriteOnly | QIODevice::Truncate)) &#123;        QMessageBox::warning(this, &quot;错误&quot;, &quot;无法打开输出文件。&quot;);        return;    &#125;    // 5. 创建并启动 QAudioInput    m_audioInput = new QAudioInput(m_selectedDevice, format, this);    m_audioInput-&gt;start(m_outputFile); // 直接将音频数据写入文件    // 更新UI状态    ui-&gt;recordButton-&gt;setEnabled(false);    ui-&gt;stopButton-&gt;setEnabled(true);    ui-&gt;statusLabel-&gt;setText(&quot;正在录音...&quot;);&#125;void MainWindow::stopRecording() &#123;    if (!m_audioInput) return;    // 1. 停止录音    m_audioInput-&gt;stop();    // 2. 清理资源    m_outputFile-&gt;close();    delete m_audioInput;    m_audioInput = nullptr;    // 更新UI状态    ui-&gt;recordButton-&gt;setEnabled(true);    ui-&gt;stopButton-&gt;setEnabled(false);    ui-&gt;statusLabel-&gt;setText(&quot;录音已停止。&quot;);&#125;\n\n第三步：处理WAV文件头QAudioInput 录制的是纯净的 PCM 音频数据。为了让普通播放器能识别，我们需要在文件开头写入一个 WAV 格式的头部信息。由于录制前不知道文件总大小，我们采用“占位-回填”的方式。\n1. 录制前写入占位文件头修改 startRecording 函数，在 m_audioInput-&gt;start(m_outputFile) 之前加入写文件头的逻辑。\n// 在 startRecording() 中...if (!m_outputFile-&gt;open(QIODevice::WriteOnly | QIODevice::Truncate)) &#123; /*...*/ &#125;// 新增：写入一个44字节的占位WAV头writeWavHeader(m_outputFile, format, 0);m_audioInput = new QAudioInput(m_selectedDevice, format, this);m_audioInput-&gt;start(m_outputFile);// ...\n\n2. 录制后更新文件头修改 stopRecording 函数，在 m_outputFile-&gt;close() 之后，重新打开文件并更新文件头中的长度信息。\n// 在 stopRecording() 中...m_audioInput-&gt;stop();qint64 fileSize = m_outputFile-&gt;size();m_outputFile-&gt;close();// 新增：更新WAV头的长度信息updateWavHeader(m_outputFile-&gt;fileName(), fileSize);delete m_audioInput;// ...\n\n3. WAV 文件头辅助函数将这些函数添加到 mainwindow.cpp 或一个单独的工具类中。\n// mainwindow.cpp#include &lt;QDataStream&gt;// 写一个占位的WAV头void writeWavHeader(QFile *file, const QAudioFormat &amp;format, qint64 dataSize) &#123;    QDataStream out(file);    out.setByteOrder(QDataStream::LittleEndian);    out.writeRawData(&quot;RIFF&quot;, 4);    out &lt;&lt; quint32(dataSize + 36);    out.writeRawData(&quot;WAVE&quot;, 4);    out.writeRawData(&quot;fmt &quot;, 4);    out &lt;&lt; quint32(16);    out &lt;&lt; quint16(1); // PCM    out &lt;&lt; quint16(format.channelCount());    out &lt;&lt; quint32(format.sampleRate());    out &lt;&lt; quint32(format.sampleRate() * format.channelCount() * format.sampleSize() / 8); // byteRate    out &lt;&lt; quint16(format.channelCount() * format.sampleSize() / 8); // blockAlign    out &lt;&lt; quint16(format.sampleSize());    out.writeRawData(&quot;data&quot;, 4);    out &lt;&lt; quint32(dataSize);&#125;// 录制结束后更新WAV头的尺寸信息void updateWavHeader(const QString &amp;fileName, qint64 fileSize) &#123;    QFile file(fileName);    if (!file.open(QIODevice::ReadWrite)) return;    qint64 dataSize = fileSize - 44;    QDataStream out(&amp;file);    out.setByteOrder(QDataStream::LittleEndian);    file.seek(4);    out &lt;&lt; quint32(dataSize + 36);    file.seek(40);    out &lt;&lt; quint32(dataSize);    file.close();&#125;\n\n完整代码参考(为简洁起见，此处省略了完整的 main.cpp 和 mainwindow.h 文件，上文已包含所有核心逻辑。)\n高级功能展望 (文字说明)\n实时音频监控 (电平表): 不将 QFile 传递给 start()，而是调用 QIODevice *device = m_audioInput-&gt;start()。然后连接 device 的 readyRead 信号，从中实时读取音频数据块，计算其振幅（RMS或峰值），并更新 UI 上的 QProgressBar。\n编码为 MP3: QAudioInput 只产生原始的 PCM 数据。要录制为 MP3，你需要将实时读取的音频数据块传递给一个第三方的 MP3 编码库（如 LAME），然后将编码后的数据写入文件。\n暂停与恢复: QAudioInput 提供了 suspend() 和 resume() 方法，可以很方便地实现暂停和恢复功能。\n\n常见问题Q1: 录制的 .wav 文件无法播放或播放速度不正常?A: 这几乎总是因为 WAV 文件头信息不正确。请仔细检查 writeWavHeader 和 updateWavHeader 函数中的计算，特别是 dataSize 和 riffSize 是否正确。\nQ2: 程序提示“默认音频输入设备不支持该格式”?A: 你的麦克风可能不支持你设置的 QAudioFormat（例如，不支持 48000Hz 采样率或立体声录制）。可以尝试一个更通用的格式，如 44100Hz 采样率、16位、单声道。\nQ3: 录音时有杂音或噪音?A: 这可能是硬件问题，也可能是缓冲区大小不合适。可以尝试通过 m_audioInput-&gt;setBufferSize() 设置一个更大的缓冲区。\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","多媒体","QAudioInput","音频录制","WAV"]},{"title":"Qt 网络编程指南","url":"/posts/1653e33b/","content":"Qt 网络编程指南目录\n概述\nHTTP 编程 (QNetworkAccessManager)\nTCP 编程 (QTcpServer 和 QTcpSocket)\nUDP 编程 (QUdpSocket)\nWebSocket 编程 (QWebSocket)\n处理 SSL&#x2F;TLS\n\n概述Qt 的 Network 模块提供了一整套强大的类，用于处理从高层的 HTTP 请求到低层的 TCP&#x2F;UDP 套接字等各种网络通信任务。本指南将通过一系列独立的、最小化的示例，介绍如何使用这些核心类。\n项目配置 (.pro 文件)要使用本指南中的任何功能，请确保你的 .pro 文件中包含了 network 模块。\nQT += core gui network\n\nHTTP 编程 (QNetworkAccessManager)QNetworkAccessManager 是 Qt 中用于处理 HTTP&#x2F;HTTPS 请求的中心类。它是异步的，通过信号和槽来处理网络回复。\n1. 发送 GET 请求#include &lt;QCoreApplication&gt;#include &lt;QNetworkAccessManager&gt;#include &lt;QNetworkRequest&gt;#include &lt;QNetworkReply&gt;#include &lt;QDebug&gt;class HttpClient : public QObject &#123;    Q_OBJECTpublic:    HttpClient(QObject *parent = nullptr) : QObject(parent) &#123;        m_manager = new QNetworkAccessManager(this);        connect(m_manager, &amp;QNetworkAccessManager::finished, this, &amp;HttpClient::onFinished);    &#125;    void fetch(const QUrl &amp;url) &#123;        qDebug() &lt;&lt; &quot;Fetching URL:&quot; &lt;&lt; url;        m_manager-&gt;get(QNetworkRequest(url));    &#125;private slots:    void onFinished(QNetworkReply *reply) &#123;        if (reply-&gt;error() == QNetworkReply::NoError) &#123;            qDebug() &lt;&lt; &quot;Reply received:&quot;;            qDebug().noquote() &lt;&lt; reply-&gt;readAll();        &#125; else &#123;            qWarning() &lt;&lt; &quot;Error:&quot; &lt;&lt; reply-&gt;errorString();        &#125;        reply-&gt;deleteLater();    &#125;private:    QNetworkAccessManager *m_manager;&#125;;int main(int argc, char *argv[]) &#123;    QCoreApplication a(argc, argv);    HttpClient client;    client.fetch(QUrl(&quot;https://api.github.com/users/qt&quot;));    return a.exec();&#125;\n\n2. 发送 POST 请求 (JSON)#include &lt;QJsonObject&gt;#include &lt;QJsonDocument&gt;void HttpClient::postJson(const QUrl &amp;url, const QJsonObject &amp;jsonObject) &#123;    QNetworkRequest request(url);    request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/json&quot;);    QJsonDocument doc(jsonObject);    QByteArray data = doc.toJson();    qDebug() &lt;&lt; &quot;Posting JSON data to&quot; &lt;&lt; url;    m_manager-&gt;post(request, data);&#125;// 在 main 函数中调用// QJsonObject obj;// obj[&quot;name&quot;] = &quot;Qt User&quot;;// obj[&quot;job&quot;] = &quot;Developer&quot;;// client.postJson(QUrl(&quot;https://httpbin.org/post&quot;), obj);\n\nTCP 编程 (QTcpServer 和 QTcpSocket)TCP 提供了一种可靠的、面向连接的字节流服务。\n1. 简单的 TCP 回声服务器 (Echo Server)#include &lt;QTcpServer&gt;#include &lt;QTcpSocket&gt;class EchoServer : public QTcpServer &#123;    Q_OBJECTpublic:    EchoServer(QObject *parent = nullptr) : QTcpServer(parent) &#123;        connect(this, &amp;QTcpServer::newConnection, this, &amp;EchoServer::handleNewConnection);    &#125;    void start(quint16 port) &#123;        if (listen(QHostAddress::Any, port)) &#123;            qDebug() &lt;&lt; &quot;Server started on port&quot; &lt;&lt; port;        &#125; else &#123;            qWarning() &lt;&lt; &quot;Server failed to start:&quot; &lt;&lt; errorString();        &#125;    &#125;private slots:    void handleNewConnection() &#123;        QTcpSocket *socket = nextPendingConnection();        qDebug() &lt;&lt; &quot;New client connected:&quot; &lt;&lt; socket-&gt;peerAddress();        connect(socket, &amp;QTcpSocket::readyRead, this, [socket]() &#123;            QByteArray data = socket-&gt;readAll();            qDebug() &lt;&lt; &quot;Received:&quot; &lt;&lt; data;            socket-&gt;write(&quot;Echo: &quot; + data);        &#125;);        connect(socket, &amp;QTcpSocket::disconnected, this, [socket]() &#123;            qDebug() &lt;&lt; &quot;Client disconnected.&quot;;            socket-&gt;deleteLater();        &#125;);    &#125;&#125;;\n\n2. 简单的 TCP 客户端#include &lt;QTcpSocket&gt;class EchoClient : public QObject &#123;    Q_OBJECTpublic:    EchoClient(QObject *parent = nullptr) : QObject(parent) &#123;        m_socket = new QTcpSocket(this);        connect(m_socket, &amp;QTcpSocket::connected, []() &#123; qDebug() &lt;&lt; &quot;Connected to server.&quot;; &#125;);        connect(m_socket, &amp;QTcpSocket::readyRead, this, [this]() &#123;            qDebug() &lt;&lt; &quot;Server replied:&quot; &lt;&lt; m_socket-&gt;readAll();        &#125;);    &#125;    void connectToServer(const QString &amp;host, quint16 port) &#123;        m_socket-&gt;connectToHost(host, port);    &#125;    void sendMessage(const QByteArray &amp;message) &#123;        m_socket-&gt;write(message);    &#125;private:    QTcpSocket *m_socket;&#125;;\n\nUDP 编程 (QUdpSocket)UDP 是一种无连接的数据报协议，它速度快，但不保证消息的可靠性或顺序。\n#include &lt;QUdpSocket&gt;class UdpPeer : public QObject &#123;    Q_OBJECTpublic:    UdpPeer(QObject *parent = nullptr) : QObject(parent) &#123;        m_socket = new QUdpSocket(this);        connect(m_socket, &amp;QUdpSocket::readyRead, this, &amp;UdpPeer::onReadyRead);    &#125;    void bind(quint16 port) &#123;        if (m_socket-&gt;bind(QHostAddress::Any, port)) &#123;            qDebug() &lt;&lt; &quot;UDP socket bound to port&quot; &lt;&lt; port;        &#125; else &#123;            qWarning() &lt;&lt; &quot;Failed to bind UDP socket.&quot;;        &#125;    &#125;    void sendBroadcast(const QByteArray &amp;datagram, quint16 port) &#123;        m_socket-&gt;writeDatagram(datagram, QHostAddress::Broadcast, port);        qDebug() &lt;&lt; &quot;Broadcast sent:&quot; &lt;&lt; datagram;    &#125;private slots:    void onReadyRead() &#123;        while (m_socket-&gt;hasPendingDatagrams()) &#123;            QByteArray datagram;            datagram.resize(m_socket-&gt;pendingDatagramSize());            QHostAddress senderHost;            quint16 senderPort;            m_socket-&gt;readDatagram(datagram.data(), datagram.size(), &amp;senderHost, &amp;senderPort);            qDebug() &lt;&lt; &quot;Received datagram from&quot; &lt;&lt; senderHost.toString() &lt;&lt; &quot;:&quot; &lt;&lt; datagram;        &#125;    &#125;private:    QUdpSocket *m_socket;&#125;;\n\nWebSocket 编程 (QWebSocket)WebSocket 提供了在单个 TCP 连接上进行全双工通信的能力，非常适合实时 Web 应用。\n#include &lt;QWebSocket&gt;class WebSocketClient : public QObject &#123;    Q_OBJECTpublic:    WebSocketClient(QObject *parent = nullptr) : QObject(parent) &#123;        m_socket = new QWebSocket();        connect(m_socket, &amp;QWebSocket::connected, this, &amp;WebSocketClient::onConnected);        connect(m_socket, &amp;QWebSocket::textMessageReceived, this, &amp;WebSocketClient::onTextMessageReceived);    &#125;    void connectToServer(const QUrl &amp;url) &#123;        qDebug() &lt;&lt; &quot;Connecting to WebSocket server:&quot; &lt;&lt; url;        m_socket-&gt;open(url);    &#125;private slots:    void onConnected() &#123;        qDebug() &lt;&lt; &quot;WebSocket connected!&quot;;        m_socket-&gt;sendTextMessage(&quot;Hello from Qt WebSocket!&quot;);    &#125;    void onTextMessageReceived(const QString &amp;message) &#123;        qDebug() &lt;&lt; &quot;Message received:&quot; &lt;&lt; message;    &#125;private:    QWebSocket *m_socket;&#125;;// 在 main 中使用// WebSocketClient client;// client.connectToServer(QUrl(&quot;wss://echo.websocket.events&quot;)); // 一个公共的测试服务\n\n处理 SSL&#x2F;TLSQt 网络模块可以透明地处理 SSL&#x2F;TLS 加密（即 HTTPS 和 WSS）。\n\n依赖: 确保你的 Qt 发行版包含了 OpenSSL 库。通常 Windows 和 macOS 的安装包会自带，Linux 上可能需要手动安装 (sudo apt-get install libssl-dev)。\n自动处理: 当你请求一个 https:// 或 wss:// 的 URL 时，Qt 会自动启用 SSL&#x2F;TLS。\n错误处理: 如果证书验证失败，QNetworkReply 或 QWebSocket 会发出 sslErrors 信号。你可以连接这个信号来诊断问题。\n\n// 在 HttpClient 中// connect(m_manager, &amp;QNetworkAccessManager::sslErrors, this, &amp;HttpClient::onSslErrors);void HttpClient::onSslErrors(QNetworkReply *reply, const QList&lt;QSslError&gt; &amp;errors) &#123;    qWarning() &lt;&lt; &quot;SSL Errors Occurred:&quot;;    for (const QSslError &amp;error : errors) &#123;        qWarning() &lt;&lt; error.errorString();    &#125;    // 在开发和测试中，你可能想临时忽略这些错误，但这在生产环境中是不安全的！    // reply-&gt;ignoreSslErrors();&#125;\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","网络编程","QNetworkAccessManager","QTcpSocket","QUdpSocket","QWebSocket"]},{"title":"Qt SQL 数据库指南","url":"/posts/835264d4/","content":"Qt SQL 数据库指南目录\n概述：Qt SQL 模块\n第一步：配置与连接数据库\n第二步：使用 QSqlQuery 执行 SQL 命令\n第三步：使用模型&#x2F;视图显示数据\n第四步：使用事务\n最佳实践与常见问题\n\n概述：Qt SQL 模块Qt 的 SQL 模块提供了一套与平台和数据库无关的接口，用于访问 SQL 数据库。其核心是驱动程序架构，允许你使用相同的 Qt API 来操作多种不同的数据库，如 SQLite, MySQL, PostgreSQL 等。\n核心类\nQSqlDatabase: 代表一个数据库连接。它负责管理连接本身。\nQSqlQuery: 用于执行 SQL 语句，并遍历查询结果。\nQSqlQueryModel: 一个只读的数据模型，用于将一个 SQL 查询的结果直接展示在视图（如 QTableView）中。\nQSqlTableModel: 一个可读写的数据模型，它代表一个单一的数据库表，并允许在视图中直接编辑数据。\n\n第一步：配置与连接数据库1. 项目配置 (.pro 文件)确保你的项目文件包含了 sql 模块。\nQT += core gui sql\n\n2. 检查驱动在使用特定数据库前，应检查 Qt 是否有可用的驱动。\n#include &lt;QSqlDatabase&gt;#include &lt;QDebug&gt;qDebug() &lt;&lt; &quot;Available drivers:&quot; &lt;&lt; QSqlDatabase::drivers();// 输出应包含 &quot;QSQLITE&quot;, &quot;QMYSQL&quot;, &quot;QPSQL&quot; 等\n如果缺少驱动，你需要安装它（例如，在 Ubuntu 上 sudo apt-get install libqt5sql5-mysql）。\n3. 建立连接 (SQLite 示例)SQLite 是最简单的入门数据库，因为它是一个本地文件，无需服务器。\n#include &lt;QSqlDatabase&gt;#include &lt;QDebug&gt;#include &lt;QSqlError&gt;bool createConnection() &#123;    // 1. 添加一个数据库连接，使用默认连接名    QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);    // 2. 设置数据库文件名    db.setDatabaseName(&quot;mydatabase.db&quot;);    // 3. 打开连接    if (!db.open()) &#123;        qWarning() &lt;&lt; &quot;Connection failed:&quot; &lt;&lt; db.lastError().text();        return false;    &#125;    qDebug() &lt;&lt; &quot;Database connected successfully!&quot;;    return true;&#125;\n提示: QSqlDatabase::addDatabase 返回的是一个值，但它实际上创建了一个可被全局访问的静态实例。你可以通过 QSqlDatabase::database() 来随时获取这个连接的引用。\n第二步：使用 QSqlQuery 执行 SQL 命令QSqlQuery 是执行所有 SQL 操作的核心。\n1. 执行简单查询 (DDL 和 DML)#include &lt;QSqlQuery&gt;void setupDatabase() &#123;    QSqlQuery query; // 默认使用主连接    // 创建表    bool success = query.exec(&quot;CREATE TABLE IF NOT EXISTS contacts (&quot;                            &quot;id INTEGER PRIMARY KEY AUTOINCREMENT, &quot;                            &quot;name TEXT NOT NULL, &quot;                            &quot;phone TEXT)&quot;);    if (!success) &#123;        qWarning() &lt;&lt; &quot;Create table failed:&quot; &lt;&lt; query.lastError();    &#125;    // 插入数据    query.exec(&quot;INSERT INTO contacts (name, phone) VALUES (&#x27;Alice&#x27;, &#x27;+1-202-555-0173&#x27;)&quot;);&#125;\n\n2. 使用预处理查询 (防止 SQL 注入)当你的查询需要包含来自用户输入等外部来源的数据时，必须使用预处理查询来防止 SQL 注入攻击。\nvoid addContact(const QString &amp;name, const QString &amp;phone) &#123;    QSqlQuery query;        // 1. 准备一个带占位符的查询    query.prepare(&quot;INSERT INTO contacts (name, phone) VALUES (:name, :phone)&quot;);        // 2. 绑定值到占位符    query.bindValue(&quot;:name&quot;, name);    query.bindValue(&quot;:phone&quot;, phone);        // 3. 执行查询    if (!query.exec()) &#123;        qWarning() &lt;&lt; &quot;Add contact failed:&quot; &lt;&lt; query.lastError();    &#125;&#125;\n\n3. 遍历查询结果void printAllContacts() &#123;    QSqlQuery query(&quot;SELECT id, name, phone FROM contacts&quot;);        // query.next() 会将内部指针移动到下一条记录    while (query.next()) &#123;        int id = query.value(0).toInt();        QString name = query.value(1).toString();        QString phone = query.value(&quot;phone&quot;).toString(); // 也可以按列名获取        qDebug() &lt;&lt; &quot;ID:&quot; &lt;&lt; id &lt;&lt; &quot;Name:&quot; &lt;&lt; name &lt;&lt; &quot;Phone:&quot; &lt;&lt; phone;    &#125;&#125;\n\n第三步：使用模型&#x2F;视图显示数据Qt 的 SQL 模块与模型&#x2F;视图框架无缝集成，可以轻松地将数据库数据显示在 UI 上。\n1. QSqlQueryModel (只读模型)这个模型最适合用于显示复杂查询（如 JOIN）的结果。\n// 在 MainWindow 中#include &lt;QSqlQueryModel&gt;void MainWindow::setupQueryView() &#123;    auto *model = new QSqlQueryModel(this);    model-&gt;setQuery(&quot;SELECT name, phone FROM contacts ORDER BY name&quot;);    // 设置表头    model-&gt;setHeaderData(0, Qt::Horizontal, tr(&quot;Name&quot;));    model-&gt;setHeaderData(1, Qt::Horizontal, tr(&quot;Phone Number&quot;));    ui-&gt;tableView-&gt;setModel(model);&#125;\n\n2. QSqlTableModel (读写模型)这个模型代表一个单一的数据库表，并支持直接在视图中进行编辑。\n// 在 MainWindow 中#include &lt;QSqlTableModel&gt;void MainWindow::setupTableView() &#123;    auto *model = new QSqlTableModel(this); // db 参数默认为主连接    model-&gt;setTable(&quot;contacts&quot;);    // 设置编辑策略：OnManualSubmit 表示所有修改都将缓存，直到手动提交    model-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);    // 从数据库加载数据    model-&gt;select();    // 设置表头    model-&gt;setHeaderData(1, Qt::Horizontal, tr(&quot;Name&quot;));    model-&gt;setHeaderData(2, Qt::Horizontal, tr(&quot;Phone Number&quot;));    ui-&gt;tableView-&gt;setModel(model);    ui-&gt;tableView-&gt;hideColumn(0); // 隐藏 ID 列    // ... 在 UI 上添加 &quot;Submit&quot; 和 &quot;Revert&quot; 按钮    connect(ui-&gt;submitButton, &amp;QPushButton::clicked, model, &amp;QSqlTableModel::submitAll);    connect(ui-&gt;revertButton, &amp;QPushButton::clicked, model, &amp;QSqlTableModel::revertAll);&#125;\n\n第四步：使用事务当需要执行多个关联的 SQL 语句，并确保它们要么全部成功、要么全部失败时，应使用事务。\nvoid performTransaction() &#123;    QSqlDatabase db = QSqlDatabase::database(); // 获取默认连接    // 1. 开始事务    if (!db.transaction()) &#123;        qWarning() &lt;&lt; &quot;Failed to start transaction:&quot; &lt;&lt; db.lastError();        return;    &#125;    QSqlQuery query(db);    query.prepare(&quot;UPDATE accounts SET balance = balance - 100 WHERE id = 1&quot;);    bool success1 = query.exec();    query.prepare(&quot;UPDATE accounts SET balance = balance + 100 WHERE id = 2&quot;);    bool success2 = query.exec();    // 2. 如果所有操作都成功，则提交事务    if (success1 &amp;&amp; success2) &#123;        if (db.commit()) &#123;            qDebug() &lt;&lt; &quot;Transaction successful!&quot;;        &#125; else &#123;            qWarning() &lt;&lt; &quot;Commit failed:&quot; &lt;&lt; db.lastError();            db.rollback(); // 尝试回滚        &#125;    &#125; else &#123;        // 3. 如果有任何操作失败，则回滚事务        qWarning() &lt;&lt; &quot;One of the queries failed, rolling back.&quot;;        db.rollback();    &#125;&#125;\n\n最佳实践与常见问题\n防止 SQL 注入: 永远不要手动拼接 SQL 查询字符串。始终使用 QSqlQuery::prepare() 和 bindValue() 来处理用户输入。\n管理连接: 对于多线程应用，每个线程都应该有自己独立的数据库连接。可以通过 QSqlDatabase::addDatabase(&quot;QSQLITE&quot;, &quot;connection_name&quot;) 创建命名连接，并在需要时通过 QSqlDatabase::database(&quot;connection_name&quot;) 获取。\n错误处理: 每次数据库操作后，都应检查 QSqlDatabase::lastError() 或 QSqlQuery::lastError() 来确认操作是否成功。\n模型 vs. 手动查询: 优先使用 QSqlQueryModel 和 QSqlTableModel 来与 UI 交互，这比手动从查询结果中读取数据并填充 UI 要简单和高效得多。\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","数据库","QSqlDatabase","QSqlQuery","QSqlTableModel","SQL"]},{"title":"Qt SQLite 加密指南","url":"/posts/ee94e619/","content":"Qt SQLite 加密指南目录\n概述：为什么需要加密以及为什么是 SQLCipher\n核心挑战：编译自定义的 Qt 驱动\n第一步：准备编译环境\n第二步：编译 SQLCipher\n第三步：编译 Qt 的 QSQLITE 驱动\n第四步：部署和使用加密数据库\n密钥管理最佳实践\n\n概述：为什么需要加密以及为什么是 SQLCipher标准的 SQLite3 数据库是一个普通的磁盘文件，任何有权访问该文件的人都可以读取其全部内容。当你的应用需要存储敏感信息（如用户信息、密码、密钥等）时，对数据库进行加密就至关重要。\nSQLCipher 是一个开源的 SQLite 扩展，它在数据库页级别上进行 100% 的 AES-256 加密，是目前为 SQLite 提供加密支持最成熟、最广泛的解决方案。\n核心挑战：编译自定义的 Qt 驱动Qt 官方提供的 QSQLITE 驱动默认不包含加密功能。因此，为了让 Qt 能使用 SQLCipher，我们不能简单地在项目中链接库，而必须从 Qt 源码重新编译 QSQLITE 驱动插件，并让它链接到我们自己编译的 SQLCipher 库。这是整个过程中最关键的一步。\n第一步：准备编译环境你需要准备以下几样东西：\n\nC++ 编译器: 一个与你的 Qt 版本匹配的编译器（例如，在 Windows 上是 Visual Studio 2019&#x2F;2022，在 Linux 上是 GCC&#x2F;Clang）。\nQt 源码: 你安装的 Qt 版本的完整源码。如果你通过在线安装器安装 Qt，可以在“添加或移除组件”中勾选对应版本的“Sources”。确保源码版本与你正在使用的 Qt Kit 的版本完全一致。\nOpenSSL 开发库: SQLCipher 依赖 OpenSSL。在 Windows 上，可以从 slproweb.com 下载预编译的开发包。在 Linux 上，通过包管理器安装（sudo apt-get install libssl-dev）。\nSQLCipher 源码: 从 GitHub 克隆。git clone https://github.com/sqlcipher/sqlcipher.git\n\n第二步：编译 SQLCipher我们将 SQLCipher 编译为一个静态库，以便后续链接。\nWindows (使用 VS 开发者命令提示符)cd sqlcipher# Qt SQLite 加密指南nmake /f Makefile.msc# Qt SQLite 加密指南\n\nLinuxcd sqlcipher./configure --enable-tempstore=yes CFLAGS=&quot;-DSQLITE_HAS_CODEC&quot; LDFLAGS=&quot;-lcrypto&quot;makesudo make install# Qt SQLite 加密指南\n\n第三步：编译 Qt 的 QSQLITE 驱动这是最核心的步骤。\n\n找到驱动源码: 导航到你下载的 Qt 源码目录，找到 QSQLITE 驱动的源码。路径通常是：C:\\Qt\\6.x.x\\Src\\qtbase\\src\\plugins\\sqldrivers\\sqlite\n\n配置 qmake: 在该目录下，打开一个与你的 Qt 版本匹配的命令行工具（例如 x64 Native Tools Command Prompt for VS 2022 并确保 qmake.exe 在 PATH 中），然后运行 qmake 命令，并传入额外的参数来指定 SQLCipher 的位置和编译宏。\nWindows 示例:\nqmake -- &quot;LIBS+=-LC:/path/to/openssl/lib -llibcrypto&quot; &quot;LIBS+=-LC:/path/to/sqlcipher -lsqlcipher&quot; &quot;INCLUDEPATH+=C:/path/to/sqlcipher&quot; &quot;DEFINES+=SQLITE_HAS_CODEC&quot;\n\nLinux 示例:\nqmake -- &quot;LIBS+=-lsqlcipher -lcrypto&quot; &quot;DEFINES+=SQLITE_HAS_CODEC&quot;\n这个命令告诉 qmake 在链接时加入 sqlcipher 和 crypto 库，并定义 SQLITE_HAS_CODEC 宏，这是开启加密功能的关键。\n\n编译插件: 运行你的构建工具。\n\nWindows: nmake\nLinux&#x2F;macOS: make\n\n\n\n第四步：部署和使用加密数据库1. 部署插件编译成功后，在构建目录的 plugins/sqldrivers 子目录下，你会找到新的驱动文件（例如 qsqlite.dll 或 libqsqlite.so）。\n你需要将这个新生成的文件，覆盖你当前 Qt 安装目录中对应的旧文件。路径通常是：C:\\Qt\\6.x.x\\mingw_64\\plugins\\sqldrivers\\qsqlite.dll\n强烈建议先备份原始文件！\n2. 在代码中使用一旦你替换了驱动，使用加密数据库就变得非常简单。\n#include &lt;QSqlDatabase&gt;#include &lt;QSqlQuery&gt;#include &lt;QSqlError&gt;#include &lt;QDebug&gt;bool openEncryptedDb(const QString&amp; dbPath, const QString&amp; password) &#123;    QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);    db.setDatabaseName(dbPath);    // 必须在 open() 之前设置密码    db.setPassword(password);    if (!db.open()) &#123;        qWarning() &lt;&lt; &quot;Failed to open database:&quot; &lt;&lt; db.lastError().text();        return false;    &#125;    qDebug() &lt;&lt; &quot;Encrypted database opened successfully.&quot;;    // (可选) 为 SQLCipher 设置更强的加密参数    QSqlQuery query(db);    query.exec(&quot;PRAGMA cipher_page_size = 4096;&quot;);    query.exec(&quot;PRAGMA kdf_iter = 64000;&quot;);    query.exec(&quot;PRAGMA cipher_hmac_algorithm = HMAC_SHA256;&quot;);    query.exec(&quot;PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA256;&quot;);    return true;&#125;\n\n核心要点: 关键在于 db.setPassword(password) 这一步。在 db.open() 之前调用它，新编译的驱动就会识别这个密码，并用它来解密数据库。如果数据库文件不存在，它会自动用这个密码创建一个新的加密数据库。\n之后，所有 QSqlQuery 的操作都和操作普通数据库完全一样，加密和解密对你的代码是完全透明的。\n密钥管理最佳实践绝对不要将密码硬编码在你的源代码中！\n\n从用户输入派生: 最安全的方式是让用户在每次启动应用时输入密码，然后使用一个密钥派生函数（如 PBKDF2）来生成数据库的加密密钥。QCryptographicHash::pbkdf2() 可以用来实现这一点。\n使用系统密钥链: 对于需要自动登录的应用，可以将加密密钥存储在操作系统的安全密钥链中（如 Windows Credential Manager, macOS Keychain, Linux Secret Service）。有一些第三方 Qt 库（如 QKeychain）可以帮助你访问这些系统服务。\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","SQLite","SQLCipher","数据库加密","安全"]},{"title":"Qt Model-View 架构指南","url":"/posts/4f2fc4b2/","content":"Qt Model-View 架构指南目录\n概述：Model-View-Delegate 模式\n第一步：自定义数据模型 (Model)\n第二步：使用视图 (View) 展示数据\n第三步：自定义委托 (Delegate) 进行渲染\n第四步：使用代理模型 (Proxy Model) 实现排序与过滤\n第五步：组合应用\n性能优化与最佳实践\n\n概述：Model-View-Delegate 模式Qt 的 Model-View 架构是经典 MVC 模式的一种变体，它将 View（视图）和 Controller（控制器）的职责进一步划分：\n\nModel (模型): 负责存储和管理数据。它不知道数据将如何被展示。这是数据的唯一真实来源。\nView (视图): 负责以某种方式将模型中的数据展示给用户。它可以是列表 (QListView)、表格 (QTableView) 或树 (QTreeView)。\nDelegate (委托): 负责控制数据项的渲染方式和编辑方式。它允许你高度自定义数据在视图中的外观和交互行为。\n\n这种架构的核心优势在于数据与表现的分离，同一个数据模型可以被多个不同的视图以不同的方式展示，而无需复制数据。\n第一步：自定义数据模型 (Model)我们将创建一个联系人列表模型 ContactModel，它继承自 QAbstractListModel。\ncontact_model.h:\n#ifndef CONTACTMODEL_H#define CONTACTMODEL_H#include &lt;QAbstractListModel&gt;#include &lt;QStringList&gt;#include &lt;QVector&gt;struct Contact &#123;    QString name;    QString phone;&#125;;class ContactModel : public QAbstractListModel &#123;    Q_OBJECTpublic:    explicit ContactModel(QObject *parent = nullptr);    // --- 必须重写的核心虚函数 ---    int rowCount(const QModelIndex &amp;parent = QModelIndex()) const override;    QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const override;    // --- 用于 QML 或自定义 Delegate 的角色名称 ---    QHash&lt;int, QByteArray&gt; roleNames() const override;    // --- 自定义的数据操作方法 ---    void addContact(const Contact &amp;contact);    void removeContact(int row);private:    QVector&lt;Contact&gt; m_contacts;&#125;;#endif // CONTACTMODEL_H\n\ncontact_model.cpp:\n#include &quot;contact_model.h&quot;ContactModel::ContactModel(QObject *parent) : QAbstractListModel(parent) &#123;    // 添加一些初始数据    addContact(&#123;&quot;Alice&quot;, &quot;+1-202-555-0173&quot;&#125;);    addContact(&#123;&quot;Bob&quot;, &quot;+44-20-7946-0958&quot;&#125;);&#125;int ContactModel::rowCount(const QModelIndex &amp;parent) const &#123;    // 对于 List 模型，我们忽略 parent 参数    if (parent.isValid()) return 0;    return m_contacts.count();&#125;QVariant ContactModel::data(const QModelIndex &amp;index, int role) const &#123;    if (!index.isValid() || index.row() &gt;= m_contacts.count()) &#123;        return QVariant();    &#125;    const Contact &amp;contact = m_contacts.at(index.row());    // Qt::DisplayRole 是视图默认请求的文本角色    if (role == Qt::DisplayRole) &#123;        return contact.name + &quot; (&quot; + contact.phone + &quot;)&quot;;    &#125;    // 也可以为其他角色提供数据，例如工具提示    if (role == Qt::ToolTipRole) &#123;        return contact.name;    &#125;    return QVariant();&#125;void ContactModel::addContact(const Contact &amp;contact) &#123;    // 在插入数据前，必须调用 beginInsertRows    beginInsertRows(QModelIndex(), rowCount(), rowCount());    m_contacts.append(contact);    // 插入数据后，必须调用 endInsertRows，这会通知所有视图进行更新    endInsertRows();&#125;void ContactModel::removeContact(int row) &#123;    if (row &lt; 0 || row &gt;= m_contacts.count()) return;    beginRemoveRows(QModelIndex(), row, row);    m_contacts.removeAt(row);    endRemoveRows();&#125;// roleNames 的实现主要用于 QML 环境，此处省略QHash&lt;int, QByteArray&gt; ContactModel::roleNames() const &#123; return &#123;&#125;; &#125;\n\n第二步：使用视图 (View) 展示数据现在，我们可以将这个模型设置到一个标准的 QListView 中。\nmainwindow.cpp:\n#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &quot;contact_model.h&quot;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent), ui(new Ui::MainWindow) &#123;    ui-&gt;setupUi(this);    // 1. 创建模型实例    auto *model = new ContactModel(this);    // 2. 将模型设置到视图上    ui-&gt;listView-&gt;setModel(model);&#125;\n运行程序，你将看到一个简单的列表，显示了我们在模型中定义的联系人信息。这已经是一个可以工作的 Model-View 结构了。\n第三步：自定义委托 (Delegate) 进行渲染默认的视图只显示 Qt::DisplayRole 的文本。如果我们想创建一个更丰富的列表项（例如，左边是头像，右边是姓名和电话），就需要自定义委托。\ncontact_delegate.h:\n#ifndef CONTACTDELEGATE_H#define CONTACTDELEGATE_H#include &lt;QStyledItemDelegate&gt;class ContactDelegate : public QStyledItemDelegate &#123;    Q_OBJECTpublic:    explicit ContactDelegate(QObject *parent = nullptr);    // 重写 paint 来自定义绘制    void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override;    // 重写 sizeHint 来告诉视图每个项需要多大空间    QSize sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override;&#125;;#endif // CONTACTDELEGATE_H\n\ncontact_delegate.cpp:\n#include &quot;contact_delegate.h&quot;#include &lt;QPainter&gt;#include &quot;contact_model.h&quot; // 需要访问模型中的数据ContactDelegate::ContactDelegate(QObject *parent) : QStyledItemDelegate(parent) &#123;&#125;void ContactDelegate::paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const &#123;    if (!index.isValid()) return;    painter-&gt;save();    // 绘制背景 (例如，选中时高亮)    if (option.state &amp; QStyle::State_Selected) &#123;        painter-&gt;fillRect(option.rect, option.palette.highlight());    &#125;    // 获取数据 (这里我们假设模型返回一个 Contact 结构体)    // 为了简化，我们直接从模型获取，更好的方式是通过角色    Contact contact = index.data(Qt::UserRole).value&lt;Contact&gt;(); // 假设模型在 UserRole 中返回整个对象    // 绘制布局    QRect r = option.rect;    QRect nameRect = r.adjusted(10, 10, -10, -20);    QRect phoneRect = r.adjusted(10, 30, -10, 0);    // 绘制文本    painter-&gt;setPen(option.palette.windowText().color());    painter-&gt;setFont(QFont(&quot;Arial&quot;, 10, QFont::Bold));    painter-&gt;drawText(nameRect, Qt::AlignLeft, contact.name);    painter-&gt;setPen(Qt::gray);    painter-&gt;setFont(QFont(&quot;Arial&quot;, 9));    painter-&gt;drawText(phoneRect, Qt::AlignLeft, contact.phone);    painter-&gt;restore();&#125;QSize ContactDelegate::sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const &#123;    // 让每个列表项的高度为 60 像素    return QSize(200, 60);&#125;\n\n应用委托: 在 MainWindow 中，将委托设置给视图。\n// mainwindow.cpp#include &quot;contact_delegate.h&quot;MainWindow::MainWindow(QWidget *parent) /*...*/ &#123;    // ...    ui-&gt;listView-&gt;setModel(model);    // 设置自定义委托    ui-&gt;listView-&gt;setItemDelegate(new ContactDelegate(this));&#125;\n\n第四步：使用代理模型 (Proxy Model) 实现排序与过滤如果你想在不修改原始数据模型的情况下，对视图中的数据进行排序或过滤，QSortFilterProxyModel 是最佳选择。\nmainwindow.cpp:\n#include &lt;QSortFilterProxyModel&gt;#include &lt;QLineEdit&gt;MainWindow::MainWindow(QWidget *parent) /*...*/ &#123;    // ...    auto *model = new ContactModel(this);    // 1. 创建代理模型    auto *proxyModel = new QSortFilterProxyModel(this);    proxyModel-&gt;setSourceModel(model); // 设置源模型    proxyModel-&gt;setFilterCaseSensitivity(Qt::CaseInsensitive); // 设置过滤时忽略大小写    proxyModel-&gt;setFilterKeyColumn(0); // 按第一列（我们唯一的列）进行过滤    // 2. 将代理模型设置到视图上    ui-&gt;listView-&gt;setModel(proxyModel);    // 3. 添加一个搜索框    auto *filterLineEdit = new QLineEdit(this);    // ... 将 filterLineEdit 添加到布局中 ...    connect(filterLineEdit, &amp;QLineEdit::textChanged, proxyModel, &amp;QSortFilterProxyModel::setFilterFixedString);&#125;\n现在，当你在搜索框中输入文本时，列表视图会自动过滤，只显示匹配的项，而原始的 ContactModel 中的数据完全不受影响。\n第五步：组合应用将以上所有部分组合起来，就可以构建一个功能强大的应用。例如，一个联系人管理器，左边是 QListView 显示联系人列表，右边是 QDataWidgetMapper 将选中项的数据映射到 QLineEdit 等编辑控件上。\n性能优化与最佳实践\n批量操作: 当你要对模型进行大量修改（如添加或删除上百行）时，务必将操作包裹在 begin...Rows() 和 end...Rows() 或 beginResetModel() 和 endResetModel() 之间。这会将所有更新合并为一次，大大提高性能。\n懒加载 (Lazy Loading): 对于极大的数据集（如数据库或大型日志文件），不要一次性将所有数据加载到模型中。可以在模型中重写 canFetchMore() 和 fetchMore() 方法，当视图滚动到末尾时，模型会按需加载下一批数据。\n视图优化: 如果你的列表项大小是固定的，在视图上设置 view-&gt;setUniformItemSizes(true) 可以显著提高滚动性能。\n数据角色 (Roles): 充分利用 data() 函数的 role 参数。除了 Qt::DisplayRole，还可以为 Qt::ToolTipRole (工具提示), Qt::FontRole (字体), Qt::ForegroundRole (前景色) 等提供数据，让视图自动处理一些简单的样式，从而简化 Delegate。\n避免在 Model 中持有 Qt 控件: 模型应该只关心数据，不应包含任何与 UI 相关的对象。\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","MVC","Model-View","Delegate","架构设计"]},{"title":"Qt 单元测试指南","url":"/posts/75dde51b/","content":"Qt 单元测试指南目录\n概述\n第一步：项目配置\n第二步：编写基础测试\n第三步：数据驱动测试\n第四步：GUI 测试\n第五步：使用模拟对象 (Mocking)\n第六步：运行测试与生成报告\n附录：持续集成 (CI&#x2F;CD)\n\n概述单元测试是保证代码质量、方便重构、减少 Bug 的关键实践。Qt 提供了自家的测试框架 Qt Test，它轻量、快速，并与 Qt 的元对象系统和事件循环深度集成，尤其擅长进行 GUI 测试。\n第一步：项目配置要开始使用 Qt Test，首先需要配置你的 .pro 文件。\n# Qt 单元测试指南# Qt 单元测试指南QT += testlib# Qt 单元测试指南CONFIG += testcase# Qt 单元测试指南SOURCES += test_calculator.cppHEADERS += test_calculator.h# Qt 单元测试指南# Qt 单元测试指南\n\n第二步：编写基础测试一个测试用例通常是一个继承自 QObject 的类，其中包含一系列以 test 开头的私有槽函数 (private slots)。\n1. 测试类结构// test_calculator.h#include &lt;QObject&gt;class TestCalculator : public QObject &#123;    Q_OBJECTprivate slots:    void initTestCase();    // 在所有测试用例执行前调用    void cleanupTestCase(); // 在所有测试用例执行后调用    void init();            // 在每个测试函数执行前调用    void cleanup();         // 在每个测试函数执行后调用    // --- 测试函数 ---    void testAddition();    void testDivision();    void testDivisionByZero_expectedFailure();&#125;;\n\n2. 测试宏Qt Test 提供了丰富的宏来进行断言：\n\nQCOMPARE(actual, expected): 比较两个值是否相等。\nQVERIFY(condition): 验证条件是否为 true。\nQVERIFY2(condition, message): 同上，但失败时会输出自定义消息。\nQVERIFY_EXCEPTION_THROWN(expression, ExceptionType): 验证表达式是否会抛出指定类型的异常。\nQWARN(message): 输出一条警告信息。\nQBENCHMARK: 用于简单的性能基准测试。\n\n3. 完整示例// test_calculator.cpp#include &lt;QtTest&gt;#include &quot;calculator.h&quot; // 假设被测试的类在这里#include &lt;stdexcept&gt;// ... TestCalculator 类的声明 ...void TestCalculator::initTestCase() &#123;    qDebug() &lt;&lt; &quot;Starting calculator tests...&quot;;&#125;void TestCalculator::cleanupTestCase() &#123;    qDebug() &lt;&lt; &quot;Calculator tests finished.&quot;;&#125;void TestCalculator::init() &#123;    // 每个测试函数都会有一个新的 Calculator 实例    m_calculator = new Calculator();&#125;void TestCalculator::cleanup() &#123;    delete m_calculator;&#125;void TestCalculator::testAddition() &#123;    QCOMPARE(m_calculator-&gt;add(2, 3), 5);    QCOMPARE(m_calculator-&gt;add(-1, 1), 0);&#125;void TestCalculator::testDivision() &#123;    // 对于浮点数，使用 qFuzzyCompare    QVERIFY(qFuzzyCompare(m_calculator-&gt;divide(10, 3), 3.33333));&#125;void TestCalculator::testDivisionByZero_expectedFailure() &#123;    // 验证除以零是否会按预期抛出异常    QVERIFY_EXCEPTION_THROWN(m_calculator-&gt;divide(1, 0), std::runtime_error);&#125;// --- 启动测试 ---// QTEST_APPLESS_MAIN 用于非 GUI 测试，它不创建 QApplication 实例，更轻量QTEST_APPLESS_MAIN(TestCalculator)// 如果你的测试需要事件循环或测试GUI组件，应使用 QTEST_MAIN// QTEST_MAIN(TestCalculator)#include &quot;test_calculator.moc&quot; // 必须包含 moc 文件\n\n第三步：数据驱动测试当你想用多组不同的数据测试同一个逻辑时，数据驱动测试非常有用。测试函数会为每一行数据独立运行一次。\n// test_string_utils.cpp#include &lt;QtTest&gt;#include &lt;algorithm&gt; // for std::reverseclass TestStringUtils : public QObject &#123;    Q_OBJECTprivate slots:    void testToUpperCase_data(); // 函数名必须是 &quot;测试函数名_data&quot;    void testToUpperCase();    void testReverse_data();    void testReverse();&#125;;void TestStringUtils::testToUpperCase_data() &#123;    // 1. 定义数据列    QTest::addColumn&lt;QString&gt;(&quot;input&quot;);    QTest::addColumn&lt;QString&gt;(&quot;expected&quot;);    // 2. 添加数据行    QTest::newRow(&quot;all_lower&quot;) &lt;&lt; &quot;hello&quot; &lt;&lt; &quot;HELLO&quot;;    QTest::newRow(&quot;mixed&quot;)     &lt;&lt; &quot;World&quot; &lt;&lt; &quot;WORLD&quot;;    QTest::newRow(&quot;empty&quot;)      &lt;&lt; &quot;&quot;      &lt;&lt; &quot;&quot;;&#125;void TestStringUtils::testToUpperCase() &#123;    // 3. 在测试函数中获取数据    QFETCH(QString, input);    QFETCH(QString, expected);    QCOMPARE(input.toUpper(), expected);&#125;void TestStringUtils::testReverse_data() &#123;    QTest::addColumn&lt;QString&gt;(&quot;input&quot;);    QTest::addColumn&lt;QString&gt;(&quot;expected&quot;);    QTest::newRow(&quot;simple&quot;) &lt;&lt; &quot;abc&quot; &lt;&lt; &quot;cba&quot;;    QTest::newRow(&quot;palindrome&quot;) &lt;&lt; &quot;madam&quot; &lt;&lt; &quot;madam&quot;;&#125;void TestStringUtils::testReverse() &#123;    QFETCH(QString, input);    QFETCH(QString, expected);    // 修正：QString 没有 reverse() 方法，需要使用 std::reverse    std::reverse(input.begin(), input.end());    QCOMPARE(input, expected);&#125;QTEST_APPLESS_MAIN(TestStringUtils)#include &quot;test_string_utils.moc&quot;\n\n第四步：GUI 测试Qt Test 框架最强大的功能之一就是测试 GUI 交互。\n\nQTest::mouseClick(widget, button, modifiers, delay): 模拟鼠标点击。\nQTest::keyClicks(widget, sequence): 模拟键盘输入字符串。\nQTest::keyClick(widget, key): 模拟单个按键。\nQSignalSpy: 一个非常强大的工具，用于监视信号的发射情况。\n\n// test_login_dialog.cpp#include &lt;QtTest&gt;#include &lt;QPushButton&gt;#include &lt;QLineEdit&gt;#include &quot;logindialog.h&quot; // 假设这是你的登录对话框UI类class TestLoginDialog : public QObject &#123;    Q_OBJECTprivate slots:    void testLogin() &#123;        LoginDialog dialog;        // 1. 查找子控件        QLineEdit *usernameEdit = dialog.findChild&lt;QLineEdit*&gt;(&quot;usernameEdit&quot;);        QLineEdit *passwordEdit = dialog.findChild&lt;QLineEdit*&gt;(&quot;passwordEdit&quot;);        QPushButton *loginButton = dialog.findChild&lt;QPushButton*&gt;(&quot;loginButton&quot;);        QVERIFY(usernameEdit);        QVERIFY(passwordEdit);        QVERIFY(loginButton);        // 2. 创建信号监视器        QSignalSpy loginSpy(&amp;dialog, &amp;LoginDialog::accepted);        // 3. 模拟用户输入        QTest::keyClicks(usernameEdit, &quot;testuser&quot;);        QTest::keyClicks(passwordEdit, &quot;password&quot;);        // 4. 模拟点击        QTest::mouseClick(loginButton, Qt::LeftButton);        // 5. 验证信号是否被发射        QCOMPARE(loginSpy.count(), 1);    &#125;&#125;;QTEST_MAIN(TestLoginDialog) // GUI 测试需要 QApplication，使用 QTEST_MAIN#include &quot;test_login_dialog.moc&quot;\n\n第五步：使用模拟对象 (Mocking)当被测试的代码依赖于外部系统（如网络、数据库）时，使用模拟对象（Mock）来隔离依赖，使测试更快速、更稳定。\n// --- 1. 定义一个通用接口 ---class INetworkManager &#123;public:    virtual ~INetworkManager() &#123;&#125;    virtual QString fetchData(const QUrl &amp;url) = 0;&#125;;// --- 2. 业务类依赖于接口，而不是具体实现 ---class DataProcessor &#123;public:    DataProcessor(INetworkManager *networkManager) : m_net(networkManager) &#123;&#125;    QString processUrl(const QUrl &amp;url) &#123;        QString data = m_net-&gt;fetchData(url);        return &quot;Processed: &quot; + data.toUpper();    &#125;private:    INetworkManager *m_net;&#125;;// --- 3. 创建一个模拟实现用于测试 ---class MockNetworkManager : public INetworkManager &#123;public:    QString fetchData(const QUrl &amp;url) override &#123;        // 在测试中，我们不进行真实网络请求，而是直接返回一个预设值        if (url.toString().contains(&quot;test&quot;)) &#123;            return &quot;mock_data&quot;;        &#125;        return &quot;&quot;;    &#125;&#125;;// --- 4. 编写测试用例 ---class TestDataProcessor : public QObject &#123;    Q_OBJECTprivate slots:    void testProcessing() &#123;        MockNetworkManager mockNet;        DataProcessor processor(&amp;mockNet);        QString result = processor.processUrl(QUrl(&quot;http://test.com&quot;));        QCOMPARE(result, QString(&quot;Processed: MOCK_DATA&quot;));    &#125;&#125;;\n\n第六步：运行测试与生成报告编译你的测试项目后，会生成一个可执行文件。直接运行它将在控制台显示测试结果。\n命令行参数Qt Test 支持丰富的命令行参数来控制测试执行和输出。\n\n运行特定测试: my_test_executable testAddition\n输出为 XML 格式: my_test_executable -o my_report.xml,xunitxml\n输出为 CSV 格式: my_test_executable -o my_report.csv,csv\n\n生成的 xunitxml 格式的报告可以被 Jenkins、GitLab CI、GitHub Actions 等几乎所有 CI&#x2F;CD 工具识别和展示。\n附录：持续集成 (CI&#x2F;CD)在 CI&#x2F;CD 流程中自动运行单元测试是保证项目质量的关键。以下是一个简化的 GitHub Actions 工作流示例。\n.github/workflows/ci.yml:\nname: Qt CIon: [push, pull_request]jobs:  test:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v3    - name: Install Qt      uses: jurplel/install-qt-action@v3      with:        version: &#x27;6.2.4&#x27; # 选择你的 Qt 版本    - name: Build Project      run: |        qmake        make -j$(nproc)    - name: Run Tests      run: |        ./test_project # 运行测试可执行文件\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","单元测试","Qt Test","TDD","自动化测试"]},{"title":"Qt 国际化指南","url":"/posts/6d91761d/","content":"Qt 国际化指南目录\n概述：Qt 的 i18n 工作流程\n第一步：在代码中标记待翻译文本\n第二步：配置项目 (.pro) 文件\n第三步：使用工具生成和翻译\n第四步：在应用程序中加载翻译\n第五步：实现动态语言切换\n处理数字、日期和货币的本地化\n\n概述：Qt 的 i18n 工作流程国际化 (i18n) 是指让你的应用程序能够适应不同语言和地区的过程。Qt 提供了一套强大而直接的工具链来完成这项工作，其核心流程如下：\n\n包裹 (Wrap): 在你的 C++ 源代码中，将所有需要被翻译的用户界面字符串用 tr() 函数包裹起来。\n更新 (Update): 使用 Qt 的命令行工具 lupdate 扫描你的项目文件，它会找到所有被 tr() 包裹的字符串，并生成或更新 .ts (Translation Source) 格式的翻译源文件。\n翻译 (Translate): 使用 Qt 提供的图形化工具 Qt Linguist 打开 .ts 文件，然后由翻译人员逐条填写目标语言的译文。\n发布 (Release): 使用 Qt 的命令行工具 lrelease 将翻译完成的 .ts 文件编译成紧凑的二进制 .qm (Qt Message) 文件。你的应用程序在运行时实际加载的是这个 .qm 文件。\n加载 (Load): 在你的应用程序中，创建一个 QTranslator 对象，加载对应的 .qm 文件，并将其安装到应用程序实例中。\n\n第一步：在代码中标记待翻译文本这是国际化的基础。为了让 lupdate 工具能识别出哪些文本需要翻译，你必须将它们用 tr() 函数包裹起来。tr() 是 QObject 的一个成员函数。\n// mywidget.cpp#include &lt;QPushButton&gt;#include &lt;QLabel&gt;MyWidget::MyWidget(QWidget *parent) : QWidget(parent) &#123;    // 正确的做法：使用 tr()    auto *label = new QLabel(tr(&quot;Username:&quot;), this);    auto *button = new QPushButton(tr(&quot;Submit&quot;), this);    // 错误的做法：使用裸字符串    // auto *label = new QLabel(&quot;Username:&quot;, this); // 这个字符串不会被翻译&#125;\n\n处理复数当文本需要根据数量变化时（例如“1个文件” vs “多个文件”），可以使用 tr() 的第三个参数。\nint fileCount = getFileCount();QString text = tr(&quot;%n file(s) found.&quot;, &quot;&quot;, fileCount);// 当 fileCount 为 1 时，翻译工具会让你翻译 &quot;%n file found.&quot;// 当 fileCount 不为 1 时，会让你翻译 &quot;%n files found.&quot;\n\n第二步：配置项目 (.pro) 文件在你的 .pro 项目文件中，使用 TRANSLATIONS 变量来声明你计划支持的语言以及对应的 .ts 文件。\n# Qt 国际化指南SOURCES += main.cpp \\           mainwindow.cppHEADERS += mainwindow.hFORMS += mainwindow.ui# Qt 国际化指南TRANSLATIONS = \\    translations/my_app_de.ts \\    translations/my_app_fr.ts \\    translations/my_app_zh_CN.ts\n\n第三步：使用工具生成和翻译1. lupdate - 生成&#x2F;更新 .ts 文件打开一个 Qt 命令行工具（例如 Qt Creator 中的命令行，或手动配置好环境的终端），进入你的项目根目录，然后运行：\n# Qt 国际化指南lupdate my_app.pro\n\n执行后，translations/ 目录下就会生成 my_app_de.ts, my_app_fr.ts 等文件。\n2. Qt Linguist - 进行翻译Qt Linguist 是一个图形化的翻译工具。\n\n打开 Qt Linguist。\n文件 -&gt; 打开… -&gt; 选择一个 .ts 文件（例如 my_app_zh_CN.ts）。\n在左侧的“上下文”列表中选择一项，然后在右侧的“翻译”区域填入中文译文。\n完成后，点击工具栏上的“完成”复选框。\n保存文件。\n\n3. lrelease - 发布 .qm 文件翻译完成后，使用 lrelease 工具将 .ts 文件编译成应用程序最终使用的 .qm 文件。\nlrelease my_app.pro\n执行后，每个 .ts 文件旁边都会生成一个同名的 .qm 文件。\n提示: 将 .qm 文件添加到你的项目的资源文件 (.qrc) 中是最佳实践，这样它们会被编译进最终的可执行文件中。\n第四步：在应用程序中加载翻译在 main.cpp 中，根据当前的系统语言环境，加载对应的 .qm 文件。\n// main.cpp#include &lt;QApplication&gt;#include &lt;QTranslator&gt;#include &lt;QLocale&gt;#include &lt;QLibraryInfo&gt;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    QTranslator translator;    // 获取系统当前的语言环境    QLocale currentLocale = QLocale::system();    // 加载我们自己的翻译文件    // 注意：路径 &quot;:/translations&quot; 是指在 qrc 资源文件中的路径    if (translator.load(currentLocale, &quot;my_app&quot;, &quot;_&quot;, &quot;:/translations&quot;)) &#123;        app.installTranslator(&amp;translator);    &#125;    // (可选) 加载 Qt 自身的标准翻译（例如 &quot;OK&quot;, &quot;Cancel&quot; 按钮的翻译）    QTranslator qtBaseTranslator;    if (qtBaseTranslator.load(&quot;qtbase_&quot; + currentLocale.name(),                               QLibraryInfo::location(QLibraryInfo::TranslationsPath))) &#123;        app.installTranslator(&amp;qtBaseTranslator);    &#125;    MainWindow w;    w.show();    return app.exec();&#125;\n\n第五步：实现动态语言切换要让用户在程序运行时切换语言，你需要：\n\n一个加载新翻译文件的机制。\n一个让所有窗口和控件刷新其文本的机制。\n\nQt 通过 QEvent::LanguageChange 事件来优雅地处理第二点。\n// 在你的主窗口或设置对话框中// 成员变量QTranslator m_translator;void switchLanguage(const QString&amp; langCode) &#123; // e.g., &quot;zh_CN&quot;    // 1. 移除旧的翻译器    qApp-&gt;removeTranslator(&amp;m_translator);    // 2. 加载新的 .qm 文件    if (m_translator.load(&quot;:/translations/my_app_&quot; + langCode)) &#123;        // 3. 安装新的翻译器        qApp-&gt;installTranslator(&amp;m_translator);    &#125;&#125;// 在需要更新界面的 QWidget 子类中，重写 changeEventvoid MyWidget::changeEvent(QEvent *event) &#123;    if (event-&gt;type() == QEvent::LanguageChange) &#123;        // 当语言改变时，这个事件会被发送到所有顶级窗口        // 在这里重新翻译所有 UI 文本        ui-&gt;retranslateUi(this); // 如果使用 .ui 文件        // 或者手动调用 tr()        // ui-&gt;myButton-&gt;setText(tr(&quot;Submit&quot;));    &#125;    QWidget::changeEvent(event);&#125;\n当你安装一个新的翻译器后，Qt 会自动向所有窗口发送 LanguageChange 事件，触发 changeEvent，从而刷新整个 UI。\n处理数字、日期和货币的本地化翻译文本只是国际化的一部分。不同地区对数字、日期和货币的格式要求也不同。QLocale 是处理这些问题的关键。\n#include &lt;QLocale&gt;#include &lt;QDate&gt;// 假设当前 locale 是 &quot;de_DE&quot; (德国)QLocale german(QLocale::German, QLocale::Germany);double number = 12345.67;QDate date(2025, 9, 21);// 使用德国的格式debug() &lt;&lt; german.toString(number, &#x27;f&#x27;, 2); // 输出: &quot;12.345,67&quot;debug() &lt;&lt; german.toString(date, QLocale::LongFormat); // 输出: &quot;Sonntag, 21. September 2025&quot;// 使用美国的格式QLocale american(QLocale::English, QLocale::UnitedStates);debug() &lt;&lt; american.toString(number, &#x27;f&#x27;, 2); // 输出: &quot;12,345.67&quot;debug() &lt;&lt; american.toString(date, QLocale::LongFormat); // 输出: &quot;Sunday, September 21, 2025&quot;\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","国际化","i18n","本地化","QTranslator","lupdate"]},{"title":"Qt 多线程编程指南","url":"/posts/f6798f2a/","content":"Qt 多线程编程指南目录\n概述：为什么需要多线程\nQt 线程基础：QThread\n方法一：Worker-Object 模式 (官方推荐)\n方法二：继承 QThread (特定场景)\n线程同步\n高级并发：QThreadPool 与 QtConcurrent\n最佳实践与核心原则\n\n概述：为什么需要多线程在 GUI 应用程序中，主线程（或称 GUI 线程）负责处理用户交互和界面更新。如果在这个线程中执行耗时操作（如复杂的计算、网络请求、文件 I&#x2F;O），界面将会冻结，无法响应用户操作，导致糟糕的用户体验。多线程允许我们将这些耗时操作移到后台线程中执行，从而保持界面的流畅响应。\nQt 线程基础：QThreadQThread 是 Qt 中管理线程的核心类。一个常见的误解是 QThread 本身就是一个线程。更准确地说，QThread 是一个线程的控制器，它可以管理一个在操作系统层面上运行的独立执行流。\n线程亲和性 (Thread Affinity)每个 QObject 对象都有一个“线程亲和性”，意味着它“属于”某个特定的线程。默认情况下，对象属于创建它的那个线程。我们可以使用 object-&gt;moveToThread(thread) 来改变对象的线程亲和性。一旦一个对象被移动到新线程，它的所有槽函数都会在该线程的事件循环中执行。\n方法一：Worker-Object 模式 (官方推荐)这是使用 QThread 最常见也是最被推荐的方式。它遵循“将工作对象移到线程中，而不是继承 QThread”的原则。\n\n创建 Worker 类: 创建一个继承自 QObject 的普通类，将耗时任务封装在一个槽函数中。\n创建 QThread 实例: QThread 作为一个独立的控制器存在。\n移动 Worker: 调用 worker-&gt;moveToThread(thread) 将工作对象移到新线程。\n连接信号槽: 使用信号槽机制来触发任务开始、报告进度和返回结果。\n启动线程: 调用 thread-&gt;start() 启动线程的事件循环。\n\n示例代码worker.h:\n#ifndef WORKER_H#define WORKER_H#include &lt;QObject&gt;#include &lt;QDebug&gt;#include &lt;QThread&gt;class Worker : public QObject &#123;    Q_OBJECTpublic slots:    void doWork(int parameter) &#123;        qDebug() &lt;&lt; &quot;Worker started in thread:&quot; &lt;&lt; QThread::currentThread();        for (int i = 0; i &lt;= parameter; ++i) &#123;            qDebug() &lt;&lt; &quot;Working...&quot; &lt;&lt; i;            QThread::msleep(100); // 模拟耗时操作        &#125;        emit resultReady(&quot;Work finished!&quot;);    &#125;signals:    void resultReady(const QString &amp;result);&#125;;#endif // WORKER_H\n\nmain.cpp (或你的主控类中):\n#include &lt;QCoreApplication&gt;#include &lt;QThread&gt;#include &quot;worker.h&quot;int main(int argc, char *argv[]) &#123;    QCoreApplication a(argc, argv);    QThread *thread = new QThread();    Worker *worker = new Worker();    worker-&gt;moveToThread(thread);    // 当线程启动时，开始工作    QObject::connect(thread, &amp;QThread::started, worker, [=]() &#123; worker-&gt;doWork(10); &#125;);    // 当工作完成时，打印结果并退出线程    QObject::connect(worker, &amp;Worker::resultReady, [&amp;](const QString &amp;result) &#123;        qDebug() &lt;&lt; &quot;Result from worker thread:&quot; &lt;&lt; result;        thread-&gt;quit();    &#125;);    // 当线程退出时，清理资源    QObject::connect(thread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);    QObject::connect(thread, &amp;QThread::finished, thread, &amp;QObject::deleteLater);    thread-&gt;start();    qDebug() &lt;&lt; &quot;Main thread continues...&quot;;    return a.exec();&#125;\n\n方法二：继承 QThread (特定场景)只有当你需要一个没有事件循环、只执行一个长期阻塞任务的线程时，才应考虑继承 QThread 并重写 run() 方法。这种方法无法在线程中使用信号槽。\n#include &lt;QThread&gt;#include &lt;QDebug&gt;class SimpleThread : public QThread &#123;    Q_OBJECTprotected:    void run() override &#123;        qDebug() &lt;&lt; &quot;Subclassed thread started in thread:&quot; &lt;&lt; currentThread();        // 执行一个独立的、阻塞的任务        for (int i = 0; i &lt; 5; ++i) &#123;            qDebug() &lt;&lt; &quot;Processing in run():&quot; &lt;&lt; i;            msleep(500);        &#125;        qDebug() &lt;&lt; &quot;Subclassed thread finished.&quot;;    &#125;&#125;;// 使用SimpleThread *myThread = new SimpleThread();myThread-&gt;start(); // run() 方法将在新线程中执行myThread-&gt;wait();  // 等待线程执行完毕delete myThread;\n\n\n\n\n对比\nWorker-Object (moveToThread)\n继承 QThread (run())\n\n\n\n推荐度\n高 (官方推荐)\n低 (仅限特定场景)\n\n\n事件循环\n有\n无\n\n\n信号槽\n支持\n不支持 (在 run 内部)\n\n\n适用场景\n大部分需要与主线程通信的后台任务\n纯粹的、独立的、阻塞的计算任务\n\n\n线程同步当多个线程需要访问共享数据时，必须使用同步机制来避免数据竞争和不一致。\n\nQMutex (互斥锁): 最基本的同步工具。在任何时刻，只有一个线程能锁定互斥锁。使用 QMutexLocker 可以方便地实现 RAII 式的加锁和解锁。\nQMutex mutex;int shared_counter = 0;void increment() &#123;    QMutexLocker locker(&amp;mutex); // 构造时加锁，析构时解锁    shared_counter++;&#125;\n\nQReadWriteLock (读写锁):允许多个“读者”同时访问数据，但“写者”是独占的。适用于“读多写少”的场景，可以提高并发性。\nQReadWriteLock lock;QString readData() &#123;    QReadLocker locker(&amp;lock); // 多个读者可以同时进入    return shared_data;&#125;void writeData(const QString &amp;data) &#123;    QWriteLocker locker(&amp;lock); // 写者是独占的    shared_data = data;&#125;\n\nQSemaphore (信号量): 用于保护一定数量的相同资源。例如，一个大小为 N 的资源池，可以有 N 个线程同时获取资源。\n\nQWaitCondition (等待条件): 用于实现复杂的线程同步，通常与 QMutex 配合使用。一个线程可以等待 (wait()) 某个条件变为真，而另一个线程在改变条件后可以唤醒 (wakeOne() 或 wakeAll()) 等待的线程。\n\n\n高级并发：QThreadPool 与 QtConcurrent对于许多常见的并发任务，你甚至不需要直接使用 QThread。Qt 提供了更高级的 API。\n\nQThreadPool: 一个全局的线程池，用于执行简短的、独立的任务。你需要创建一个继承自 QRunnable 的任务类，然后将其添加到线程池中。\nclass MyTask : public QRunnable &#123;    void run() override &#123; /* ... 耗时操作 ... */ &#125;&#125;;MyTask *task = new MyTask();QThreadPool::globalInstance()-&gt;start(task);\n\nQtConcurrent: 一个功能强大的框架，用于以并行方式处理数据集合，类似于函数式编程。它自动使用 QThreadPool。\n#include &lt;QtConcurrent&gt;#include &lt;QStringList&gt;#include &lt;QFuture&gt;QStringList strings = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;;// 1. 并行映射 (map): 对每个元素应用一个函数QFuture&lt;QString&gt; future = QtConcurrent::mapped(strings, [](const QString &amp;s) &#123;    return s.toUpper();&#125;);future.waitForFinished();qDebug() &lt;&lt; future.results(); // 输出: (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;)// 2. 并行过滤 (filter): 筛选满足条件的元素QFuture&lt;QString&gt; future2 = QtConcurrent::filtered(strings, [](const QString &amp;s) &#123;    return s &gt; &quot;b&quot;;&#125;);// ...// 3. 并行规约 (reduce): 将所有元素合并为一个结果QFuture&lt;int&gt; future3 = QtConcurrent::reduced(QList&lt;int&gt;&#123;1,2,3,4&#125;, [](int &amp;sum, int val) &#123;    sum += val;&#125;);// ...\n\n最佳实践与核心原则\n优先使用高级 API: 尽可能优先使用 QtConcurrent 或 QThreadPool。只有在需要对线程生命周期进行精细控制时，才直接使用 QThread。\n优先使用 Worker-Object 模式: 当你必须使用 QThread 时，moveToThread 模式是首选。它能让你在工作线程中安全地使用信号槽，是与 Qt 事件驱动模型结合得最好的方式。\n严禁直接操作 GUI: 任何时候都不要在主线程以外的线程中直接创建、访问或修改 QWidget 及其子类对象。所有与 GUI 的交互都必须通过信号槽机制，将任务的执行结果发送到主线程的槽函数中，再由该槽函数更新界面。\n保护共享数据: 只要有数据可能被多个线程同时访问，就必须使用 QMutex 或其他同步工具来保护它。\n注意对象所有权: 当使用 moveToThread 时，要确保 Worker 对象和 QThread 对象的生命周期被正确管理。通常的做法是将它们都设置为某个主线程对象的子对象，或者在线程结束后使用 deleteLater() 来安全地删除它们。\n\n","categories":["C++核心开发","Qt框架"],"tags":["C++","Qt","多线程","并发","QThread","QtConcurrent","线程同步"]}]